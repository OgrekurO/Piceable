import {
  GLOBAL_EVENT_KEYS,
  VxeCore,
  VxeUI,
  checkVersion,
  clipboard,
  commands,
  component,
  coreVersion,
  createEvent,
  formats,
  getComponent,
  getConfig,
  getI18n,
  getIcon,
  getLanguage,
  getSlotVNs,
  getTheme,
  globalEvents,
  globalResize,
  globalStore,
  handleCheckInfo,
  hasComponent,
  hasLanguage,
  hooks,
  index_esm_default,
  interceptor,
  log,
  menus,
  permission,
  renderCustomIcon,
  renderEmptyElement,
  renderGlobalIcon,
  renderer,
  require_xe_utils,
  setConfig,
  setI18n,
  setIcon,
  setLanguage,
  setTheme,
  use,
  useFns,
  usePermission,
  useSize,
  validators
} from "./chunk-2OEJLEM6.js";
import {
  Teleport,
  TransitionGroup,
  __export,
  __toESM,
  computed,
  createApp,
  createCommentVNode,
  defineComponent,
  h,
  inject,
  nextTick,
  onActivated,
  onBeforeUnmount,
  onDeactivated,
  onMounted,
  onUnmounted,
  provide,
  reactive,
  ref,
  resolveComponent,
  watch
} from "./chunk-WJTW4RN3.js";

// node_modules/vxe-pc-ui/es/components.js
var components_exports = {};
__export(components_exports, {
  Alert: () => Alert,
  Anchor: () => Anchor,
  AnchorLink: () => AnchorLink,
  Avatar: () => Avatar,
  Badge: () => Badge,
  Breadcrumb: () => Breadcrumb,
  BreadcrumbItem: () => BreadcrumbItem,
  Button: () => Button,
  ButtonGroup: () => ButtonGroup,
  Calendar: () => Calendar,
  Card: () => Card,
  Carousel: () => Carousel,
  CarouselItem: () => CarouselItem,
  Checkbox: () => Checkbox,
  CheckboxButton: () => CheckboxButton,
  CheckboxGroup: () => CheckboxGroup,
  Col: () => Col,
  Collapse: () => Collapse,
  CollapsePane: () => CollapsePane,
  ColorPicker: () => ColorPicker,
  Countdown: () => Countdown,
  DatePanel: () => DatePanel,
  DatePicker: () => DatePicker,
  DateRangePicker: () => DateRangePicker,
  Drawer: () => Drawer,
  DrawerController: () => DrawerController,
  Empty: () => Empty,
  Form: () => Form,
  FormGather: () => FormGather,
  FormGroup: () => FormGroup,
  FormItem: () => FormItem,
  GLOBAL_EVENT_KEYS: () => GLOBAL_EVENT_KEYS,
  Icon: () => Icon,
  IconPicker: () => IconPicker,
  Image: () => Image2,
  ImageGroup: () => ImageGroup,
  ImagePreview: () => ImagePreview,
  Input: () => Input,
  LayoutAside: () => LayoutAside,
  LayoutBody: () => LayoutBody,
  LayoutContainer: () => LayoutContainer,
  LayoutFooter: () => LayoutFooter,
  LayoutHeader: () => LayoutHeader,
  Link: () => Link,
  List: () => List,
  Loading: () => Loading,
  LoadingController: () => LoadingController,
  Menu: () => Menu,
  Modal: () => Modal,
  ModalController: () => ModalController,
  NoticeBar: () => NoticeBar,
  NumberInput: () => NumberInput,
  Optgroup: () => Optgroup,
  Option: () => Option,
  Pager: () => Pager,
  PasswordInput: () => PasswordInput,
  Print: () => Print,
  PrintPageBreak: () => PrintPageBreak,
  Pulldown: () => Pulldown,
  Radio: () => Radio,
  RadioButton: () => RadioButton,
  RadioGroup: () => RadioGroup,
  Rate: () => Rate,
  Result: () => Result,
  Row: () => Row,
  Select: () => Select,
  Slider: () => Slider,
  Split: () => Split,
  SplitPane: () => SplitPane,
  Splitter: () => Splitter,
  SplitterPanel: () => SplitterPanel,
  Steps: () => Steps,
  Switch: () => Switch,
  TabPane: () => TabPane,
  TableSelect: () => TableSelect,
  Tabs: () => Tabs,
  Tag: () => Tag,
  Text: () => Text,
  TextEllipsis: () => TextEllipsis,
  Textarea: () => Textarea,
  Tip: () => Tip,
  Tips: () => Tips,
  Tooltip: () => Tooltip,
  Tree: () => Tree,
  TreeSelect: () => TreeSelect,
  Upload: () => Upload,
  VxeAlert: () => VxeAlert,
  VxeAnchor: () => VxeAnchor,
  VxeAnchorLink: () => VxeAnchorLink,
  VxeAvatar: () => VxeAvatar,
  VxeBadge: () => VxeBadge,
  VxeBreadcrumb: () => VxeBreadcrumb,
  VxeBreadcrumbItem: () => VxeBreadcrumbItem,
  VxeButton: () => VxeButton,
  VxeButtonGroup: () => VxeButtonGroup,
  VxeCalendar: () => VxeCalendar,
  VxeCard: () => VxeCard,
  VxeCarousel: () => VxeCarousel,
  VxeCarouselItem: () => VxeCarouselItem,
  VxeCheckbox: () => VxeCheckbox,
  VxeCheckboxButton: () => VxeCheckboxButton,
  VxeCheckboxGroup: () => VxeCheckboxGroup,
  VxeCol: () => VxeCol,
  VxeCollapse: () => VxeCollapse,
  VxeCollapsePane: () => VxeCollapsePane,
  VxeColorPicker: () => VxeColorPicker,
  VxeCore: () => VxeCore,
  VxeCountdown: () => VxeCountdown,
  VxeDatePanel: () => VxeDatePanel,
  VxeDatePicker: () => VxeDatePicker,
  VxeDateRangePicker: () => VxeDateRangePicker,
  VxeDrawer: () => VxeDrawer,
  VxeEmpty: () => VxeEmpty,
  VxeForm: () => VxeForm,
  VxeFormGather: () => VxeFormGather,
  VxeFormGroup: () => VxeFormGroup,
  VxeFormItem: () => VxeFormItem,
  VxeIcon: () => VxeIcon,
  VxeIconPicker: () => VxeIconPicker,
  VxeImage: () => VxeImage,
  VxeImageGroup: () => VxeImageGroup,
  VxeImagePreview: () => VxeImagePreview,
  VxeInput: () => VxeInput,
  VxeLayoutAside: () => VxeLayoutAside,
  VxeLayoutBody: () => VxeLayoutBody,
  VxeLayoutContainer: () => VxeLayoutContainer,
  VxeLayoutFooter: () => VxeLayoutFooter,
  VxeLayoutHeader: () => VxeLayoutHeader,
  VxeLink: () => VxeLink,
  VxeList: () => VxeList,
  VxeLoading: () => VxeLoading,
  VxeMenu: () => VxeMenu,
  VxeModal: () => VxeModal,
  VxeNoticeBar: () => VxeNoticeBar,
  VxeNumberInput: () => VxeNumberInput,
  VxeOptgroup: () => VxeOptgroup,
  VxeOption: () => VxeOption,
  VxePager: () => VxePager,
  VxePasswordInput: () => VxePasswordInput,
  VxePrint: () => VxePrint,
  VxePrintPageBreak: () => VxePrintPageBreak,
  VxePulldown: () => VxePulldown,
  VxeRadio: () => VxeRadio,
  VxeRadioButton: () => VxeRadioButton,
  VxeRadioGroup: () => VxeRadioGroup,
  VxeRate: () => VxeRate,
  VxeResult: () => VxeResult,
  VxeRow: () => VxeRow,
  VxeSelect: () => VxeSelect,
  VxeSlider: () => VxeSlider,
  VxeSplit: () => VxeSplit,
  VxeSplitPane: () => VxeSplitPane,
  VxeSplitter: () => VxeSplitter,
  VxeSplitterPanel: () => VxeSplitterPanel,
  VxeSteps: () => VxeSteps,
  VxeSwitch: () => VxeSwitch,
  VxeTabPane: () => VxeTabPane,
  VxeTableSelect: () => VxeTableSelect,
  VxeTabs: () => VxeTabs,
  VxeTag: () => VxeTag,
  VxeText: () => VxeText,
  VxeTextEllipsis: () => VxeTextEllipsis,
  VxeTextarea: () => VxeTextarea,
  VxeTip: () => VxeTip,
  VxeTooltip: () => VxeTooltip,
  VxeTree: () => VxeTree,
  VxeTreeSelect: () => VxeTreeSelect,
  VxeUI: () => VxeUI,
  VxeUpload: () => VxeUpload,
  VxeWatermark: () => VxeWatermark,
  Watermark: () => Watermark,
  WatermarkController: () => WatermarkController,
  checkVersion: () => checkVersion,
  clipboard: () => clipboard,
  commands: () => commands,
  component: () => component,
  config: () => config,
  coreVersion: () => coreVersion,
  createEvent: () => createEvent,
  drawer: () => drawer,
  formats: () => formats,
  getComponent: () => getComponent,
  getConfig: () => getConfig,
  getI18n: () => getI18n,
  getIcon: () => getIcon,
  getLanguage: () => getLanguage,
  getSlotVNs: () => getSlotVNs,
  getTheme: () => getTheme,
  globalEvents: () => globalEvents,
  globalResize: () => globalResize,
  globalStore: () => globalStore,
  handleCheckInfo: () => handleCheckInfo,
  hasComponent: () => hasComponent,
  hasLanguage: () => hasLanguage,
  hooks: () => hooks,
  install: () => install,
  interceptor: () => interceptor,
  loading: () => loading,
  log: () => log,
  menus: () => menus,
  modal: () => modal,
  permission: () => permission,
  print: () => print,
  readFile: () => readFile,
  renderCustomIcon: () => renderCustomIcon,
  renderEmptyElement: () => renderEmptyElement,
  renderGlobalIcon: () => renderGlobalIcon,
  renderer: () => renderer,
  saveFile: () => saveFile,
  setConfig: () => setConfig,
  setI18n: () => setI18n,
  setIcon: () => setIcon,
  setLanguage: () => setLanguage,
  setTheme: () => setTheme,
  setup: () => setup,
  use: () => use,
  useFns: () => useFns,
  usePermission: () => usePermission,
  useSize: () => useSize,
  validators: () => validators,
  version: () => version2,
  watermark: () => watermark
});

// node_modules/vxe-pc-ui/es/ui/src/comp.js
var defineVxeComponent = defineComponent;

// node_modules/vxe-pc-ui/es/dynamics/index.js
var dynamicContainerElem;
var dynamicStore = reactive({
  modals: [],
  drawers: [],
  globalLoading: null,
  globalWatermark: null
});
var VxeDynamics = defineVxeComponent({
  setup() {
    const VxeUIModalComponent = VxeUI.getComponent("vxe-modal");
    const VxeUIDrawerComponent = VxeUI.getComponent("vxe-drawer");
    const VxeUILoadingComponent = VxeUI.getComponent("vxe-loading");
    const VxeUIWatermarkComponent = VxeUI.getComponent("vxe-watermark");
    return () => {
      const { modals, drawers, globalWatermark, globalLoading } = dynamicStore;
      return [
        modals.length ? h("div", {
          key: 1,
          class: "vxe-dynamics--modal"
        }, modals.map((item) => h(VxeUIModalComponent, item))) : createCommentVNode(),
        drawers.length ? h("div", {
          key: 2,
          class: "vxe-dynamics--drawer"
        }, drawers.map((item) => h(VxeUIDrawerComponent, item))) : createCommentVNode(),
        globalWatermark ? h(VxeUIWatermarkComponent, globalWatermark) : createCommentVNode(),
        globalLoading ? h(VxeUILoadingComponent, globalLoading) : createCommentVNode()
      ];
    };
  }
});
var dynamicApp = createApp(VxeDynamics);
function checkDynamic() {
  if (!dynamicContainerElem) {
    dynamicContainerElem = document.createElement("div");
    dynamicContainerElem.className = "vxe-dynamics";
    document.body.appendChild(dynamicContainerElem);
    dynamicApp.mount(dynamicContainerElem);
  }
}

// node_modules/vxe-pc-ui/es/ui/src/log.js
var version = `ui v${"4.10.27"}`;
var warnLog = log.create("warn", version);
var errLog = log.create("error", version);

// node_modules/vxe-pc-ui/es/ui/index.js
var version2 = "4.10.27";
VxeUI.uiVersion = version2;
VxeUI.dynamicApp = dynamicApp;
function config(options) {
  warnLog("vxe.error.delFunc", ["config", "setConfig"]);
  return setConfig(options);
}
function setup(options) {
  warnLog("vxe.error.delFunc", ["setup", "setConfig"]);
  return setConfig(options);
}
VxeUI.config = config;
VxeUI.setup = setup;
setConfig({
  alert: {},
  anchor: {},
  anchorLink: {},
  avatar: {},
  badge: {},
  breadcrumb: {
    separator: "/"
  },
  breadcrumbItem: {},
  button: {
    trigger: "hover",
    // destroyOnClose: false,
    prefixTooltip: {
      enterable: true
    },
    suffixTooltip: {
      enterable: true
    }
  },
  buttonGroup: {},
  calendar: {
    minDate: new Date(1900, 0, 1),
    maxDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1
  },
  card: {
    border: true,
    padding: true
  },
  carousel: {
    height: 200,
    loop: true,
    interval: 5e3
  },
  carouselItem: {},
  checkbox: {},
  checkboxButton: {},
  checkboxGroup: {},
  col: {},
  collapse: {
    padding: true,
    expandConfig: {
      showIcon: true
    }
  },
  collapsePane: {},
  countdown: {},
  colorPicker: {
    type: "rgb",
    clearable: true,
    showAlpha: true,
    clickToCopy: true,
    showColorExtractor: true,
    showQuick: true
  },
  datePanel: {
    // parseFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
    // labelFormat: '',
    // valueFormat: '',
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1
  },
  datePicker: {
    // size: null,
    // transfer: false,
    shortcutConfig: {
      // position: 'left',
      align: "left",
      mode: "text",
      autoClose: true
    },
    startDay: 1,
    selectDay: 1,
    autoClose: true,
    showClearButton: null,
    showConfirmButton: null
  },
  dateRangePicker: {
    // size: null,
    // transfer: false,
    shortcutConfig: {
      // position: 'left',
      align: "left",
      mode: "text",
      autoClose: true
    },
    startDay: 1,
    selectDay: 1,
    separator: " ~ ",
    autoClose: true,
    showClearButton: null,
    showConfirmButton: null
  },
  drawer: {
    // size: null,
    position: "right",
    showHeader: true,
    lockView: true,
    mask: true,
    showTitleOverflow: true,
    showClose: true,
    padding: true,
    // destroyOnClose: false,
    cancelClosable: true,
    confirmClosable: true
  },
  empty: {},
  form: {
    // preventSubmit: false,
    // size: null,
    // colon: false,
    validConfig: {
      showErrorMessage: true,
      autoPos: true,
      theme: "beautify"
    },
    tooltipConfig: {
      enterable: true
    },
    titleAsterisk: true,
    titleOverflow: false,
    padding: true
  },
  formDesign: {
    height: 400,
    showHeader: true,
    showPc: true
  },
  formGather: {},
  formGroup: {},
  formItem: {},
  formView: {},
  icon: {},
  iconPicker: {
    icons: ["home", "company", "comment", "setting", "send", "envelope", "envelope-open", "bell", "search", "print", "pc", "goods", "chart-line", "edit", "delete", "save", "folder", "microphone", "flag", "link", "location", "sunny", "rmb", "usd", "user", "add-user", "add-users", "star", "unlock", "time", "text", "feedback", "calendar", "association-form", "cloud-download", "cloud-upload", "file", "subtable", "chart-bar-x", "chart-bar-y", "chart-line", "chart-pie", "chart-radar"]
  },
  image: {
    showPreview: true,
    showPrintButton: true,
    maskClosable: true
  },
  imageGroup: {
    showPreview: true,
    showPrintButton: true
  },
  imagePreview: {
    showPrintButton: true
  },
  input: {
    // size: null,
    // transfer: false
    // parseFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
    // labelFormat: '',
    // valueFormat: '',
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1,
    digits: 2,
    controls: true
  },
  layoutAside: {},
  layoutBody: {},
  layoutContainer: {},
  layoutFooter: {},
  layoutHeader: {},
  link: {
    underline: true
  },
  listDesign: {
    height: 400,
    showPc: true
  },
  listView: {},
  list: {
    // size: null,
    virtualYConfig: {
      enabled: true,
      gt: 100
      // oSize: 0
    }
  },
  loading: {
    showIcon: true,
    showText: true
  },
  menu: {},
  modal: {
    // size: null,
    top: 16,
    showHeader: true,
    minWidth: 340,
    minHeight: 140,
    lockView: true,
    mask: true,
    duration: 3e3,
    marginSize: 0,
    dblclickZoom: true,
    showTitleOverflow: true,
    animat: true,
    showClose: true,
    padding: true,
    draggable: true,
    showConfirmButton: null,
    cancelClosable: true,
    confirmClosable: true,
    zoomConfig: {
      minimizeMaxSize: 10,
      minimizeVerticalOffset: {
        top: -24,
        left: 0
      },
      minimizeHorizontalOffset: {
        top: 0,
        left: 32
      }
    },
    // destroyOnClose: false,
    // remember: false,
    // storage: false,
    storageKey: "VXE_MODAL_POSITION"
  },
  noticeBar: {},
  numberInput: {
    // size: null,
    // transfer: false
    digits: 2,
    autoFill: true,
    controlConfig: {
      enabled: true,
      layout: "right",
      showButton: true,
      isWheel: true,
      isArrow: true
    }
  },
  optgroup: {},
  option: {},
  pager: {
    pageSizePlacement: "top"
    // size: null,
    // autoHidden: false,
    // perfect: true,
    // pageSize: 10,
    // pagerCount: 7,
    // pageSizes: [10, 15, 20, 50, 100],
    // layouts: ['PrevJump', 'PrevPage', 'Jump', 'PageCount', 'NextPage', 'NextJump', 'Sizes', 'Total']
  },
  print: {
    pageStyle: {}
  },
  passwordInput: {
    controls: true
  },
  printPageBreak: {},
  pulldown: {
    // destroyOnClose: false
  },
  radio: {
    strict: true
  },
  radioButton: {
    strict: true
  },
  radioGroup: {
    strict: true
  },
  rate: {},
  result: {},
  row: {},
  select: {
    multiCharOverflow: 8,
    remoteConfig: {
      enabled: true,
      autoLoad: true
    },
    virtualYConfig: {
      enabled: true,
      gt: 50,
      oSize: 2
    }
  },
  splitter: {
    resize: true,
    itemConfig: {
      minWidth: 40,
      minHeight: 40
    },
    resizeConfig: {
      // immediate: false,
      showTip: true
    }
  },
  splitterPanel: {},
  slider: {
    max: 100,
    min: 0
  },
  steps: {},
  switch: {},
  tabPane: {},
  tableSelect: {
    gridConfig: {
      showOverflow: true,
      showHeaderOverflow: true,
      showFooterOverflow: true,
      rowConfig: {
        isHover: true
      },
      virtualXConfig: {
        enabled: true,
        gt: 0
      },
      virtualYConfig: {
        enabled: true,
        gt: 0
      }
    }
  },
  tabs: {
    // destroyOnClose: false
  },
  tag: {},
  textEllipsis: {
    underline: true
  },
  text: {
    copyConfig: {
      showMessage: true
    }
  },
  textarea: {
    resize: "none"
  },
  tip: {},
  tooltip: {
    // size: null,
    // enterable: false,
    trigger: "hover",
    theme: "dark",
    enterDelay: 500,
    leaveDelay: 300,
    isArrow: true
  },
  tree: {
    // autoResize: false,
    indent: 20,
    minHeight: 60,
    radioConfig: {
      strict: true
    },
    virtualYConfig: {
      enabled: true,
      gt: 50,
      oSize: 2
    }
  },
  treeSelect: {
    autoClose: true,
    virtualYConfig: {
      enabled: true,
      gt: 0,
      oSize: 2
    },
    treeConfig: {
      maxHeight: 300,
      radioConfig: {},
      checkboxConfig: {},
      filterConfig: {
        autoExpandAll: true
      }
    }
  },
  upload: {
    mode: "all",
    imageTypes: ["jpg", "jpeg", "png", "gif"],
    showList: true,
    showUploadButton: true,
    showButtonText: true,
    showRemoveButton: true,
    showButtonIcon: true,
    showPreview: true,
    dragToUpload: true,
    // imageConfig: {},
    showLimitSize: true,
    showLimitCount: true,
    autoSubmit: true,
    // urlArgs: false,
    maxSimultaneousUploads: 5
  },
  watermark: {
    rotate: -30,
    gap: [100, 100]
  },
  table: {},
  colgroup: {},
  column: {},
  toolbar: {},
  grid: {},
  gantt: {}
});
var iconPrefix = "vxe-icon-";
setIcon({
  // loading
  LOADING: iconPrefix + "spinner roll vxe-loading--default-icon",
  // button
  BUTTON_DROPDOWN: iconPrefix + "arrow-down",
  BUTTON_LOADING: iconPrefix + "spinner roll",
  BUTTON_TOOLTIP_ICON: iconPrefix + "question-circle-fill",
  // menu
  MENU_ITEM_EXPAND_OPEN: iconPrefix + "arrow-down rotate180",
  MENU_ITEM_EXPAND_CLOSE: iconPrefix + "arrow-down",
  // select
  SELECT_LOADED: iconPrefix + "spinner roll",
  SELECT_OPEN: iconPrefix + "caret-down rotate180",
  SELECT_CLOSE: iconPrefix + "caret-down",
  SELECT_ADD_OPTION: iconPrefix + "add",
  // icon-picker
  ICON_PICKER_OPEN: iconPrefix + "caret-down rotate180",
  ICON_PICKER_CLOSE: iconPrefix + "caret-down",
  // pager
  PAGER_HOME: iconPrefix + "home-page",
  PAGER_END: iconPrefix + "end-page",
  PAGER_JUMP_PREV: iconPrefix + "arrow-double-left",
  PAGER_JUMP_NEXT: iconPrefix + "arrow-double-right",
  PAGER_PREV_PAGE: iconPrefix + "arrow-left",
  PAGER_NEXT_PAGE: iconPrefix + "arrow-right",
  PAGER_JUMP_MORE: iconPrefix + "ellipsis-h",
  // radio
  RADIO_CHECKED: iconPrefix + "radio-checked-fill",
  RADIO_UNCHECKED: iconPrefix + "radio-unchecked",
  RADIO_DISABLED_UNCHECKED: iconPrefix + "radio-unchecked-fill",
  // checkbox
  CHECKBOX_INDETERMINATE: iconPrefix + "checkbox-indeterminate-fill",
  CHECKBOX_CHECKED: iconPrefix + "checkbox-checked-fill",
  CHECKBOX_UNCHECKED: iconPrefix + "checkbox-unchecked",
  CHECKBOX_DISABLED_UNCHECKED: iconPrefix + "checkbox-unchecked-fill",
  // input
  INPUT_CLEAR: iconPrefix + "error-circle-fill",
  INPUT_SEARCH: iconPrefix + "search",
  INPUT_PLUS_NUM: iconPrefix + "caret-up",
  INPUT_MINUS_NUM: iconPrefix + "caret-down",
  // number-picker
  NUMBER_INPUT_MINUS_NUM: iconPrefix + "minus",
  NUMBER_INPUT_PLUS_NUM: iconPrefix + "add",
  // date-picker
  DATE_PICKER_DATE: iconPrefix + "calendar",
  // password-input
  PASSWORD_INPUT_SHOW_PWD: iconPrefix + "eye-fill-close",
  PASSWORD_INPUT_HIDE_PWD: iconPrefix + "eye-fill",
  // modal
  MODAL_ZOOM_MIN: iconPrefix + "minus",
  MODAL_ZOOM_REVERT: iconPrefix + "recover",
  MODAL_ZOOM_IN: iconPrefix + "square",
  MODAL_ZOOM_OUT: iconPrefix + "maximize",
  MODAL_CLOSE: iconPrefix + "close",
  MODAL_INFO: iconPrefix + "info-circle-fill",
  MODAL_SUCCESS: iconPrefix + "success-circle-fill",
  MODAL_WARNING: iconPrefix + "warning-circle-fill",
  MODAL_ERROR: iconPrefix + "error-circle-fill",
  MODAL_QUESTION: iconPrefix + "question-circle-fill",
  MODAL_LOADING: iconPrefix + "spinner roll",
  // drawer
  DRAWER_CLOSE: iconPrefix + "close",
  // form
  FORM_PREFIX: iconPrefix + "question-circle-fill",
  FORM_SUFFIX: iconPrefix + "question-circle-fill",
  FORM_FOLDING: iconPrefix + "arrow-up rotate180",
  FORM_UNFOLDING: iconPrefix + "arrow-up",
  FORM_VALID_ERROR_ICON: iconPrefix + "warning-circle-fill",
  // form-design
  FORM_DESIGN_STYLE_SETTING: iconPrefix + "layout",
  FORM_DESIGN_PROPS_PC: iconPrefix + "pc",
  FORM_DESIGN_PROPS_MOBILE: iconPrefix + "mobile",
  FORM_DESIGN_PROPS_ADD: iconPrefix + "add",
  FORM_DESIGN_PROPS_EDIT: iconPrefix + "edit",
  FORM_DESIGN_WIDGET_ADD: iconPrefix + "square-plus-fill",
  FORM_DESIGN_WIDGET_COPY: iconPrefix + "copy",
  FORM_DESIGN_WIDGET_DELETE: iconPrefix + "delete",
  FORM_DESIGN_WIDGET_SWAP_LR: iconPrefix + "swap",
  FORM_DESIGN_WIDGET_OPTION_DELETE: iconPrefix + "delete",
  FORM_DESIGN_WIDGET_OPTION_EXPAND_OPEN: iconPrefix + "square-plus",
  FORM_DESIGN_WIDGET_OPTION_EXPAND_CLOSE: iconPrefix + "square-minus",
  // list-design
  LIST_DESIGN_FIELD_SETTING: iconPrefix + "custom-column",
  LIST_DESIGN_LIST_SETTING: iconPrefix + "menu",
  LIST_DESIGN_LIST_SETTING_SEARCH_DELETE: iconPrefix + "delete",
  LIST_DESIGN_LIST_SETTING_ACTIVE_DELETE: iconPrefix + "delete",
  // upload
  UPLOAD_FILE_ERROR: iconPrefix + "warning-circle-fill",
  UPLOAD_FILE_ADD: iconPrefix + "upload",
  UPLOAD_FILE_REMOVE: iconPrefix + "delete",
  UPLOAD_FILE_DOWNLOAD: iconPrefix + "download",
  UPLOAD_IMAGE_UPLOAD: iconPrefix + "upload",
  UPLOAD_IMAGE_RE_UPLOAD: iconPrefix + "repeat",
  UPLOAD_IMAGE_ADD: iconPrefix + "add",
  UPLOAD_IMAGE_REMOVE: iconPrefix + "close",
  UPLOAD_LOADING: iconPrefix + "spinner roll vxe-loading--default-icon",
  UPLOAD_FILE_TYPE_DEFAULT: iconPrefix + "file",
  UPLOAD_FILE_TYPE_XLSX: iconPrefix + "file-excel",
  UPLOAD_FILE_TYPE_XLS: iconPrefix + "file-excel",
  UPLOAD_FILE_TYPE_PDF: iconPrefix + "file-pdf",
  UPLOAD_FILE_TYPE_PNG: iconPrefix + "file-image",
  UPLOAD_FILE_TYPE_GIF: iconPrefix + "file-image",
  UPLOAD_FILE_TYPE_JPG: iconPrefix + "file-image",
  UPLOAD_FILE_TYPE_JPEG: iconPrefix + "file-image",
  UPLOAD_FILE_TYPE_MD: iconPrefix + "file-markdown",
  UPLOAD_FILE_TYPE_PPD: iconPrefix + "file-ppt",
  UPLOAD_FILE_TYPE_DOCX: iconPrefix + "file-word",
  UPLOAD_FILE_TYPE_DOC: iconPrefix + "file-word",
  UPLOAD_FILE_TYPE_ZIP: iconPrefix + "file-zip",
  UPLOAD_FILE_TYPE_TXT: iconPrefix + "file-txt",
  // image-preview
  IMAGE_PREVIEW_CLOSE: iconPrefix + "close",
  IMAGE_PREVIEW_PREVIOUS: iconPrefix + "arrow-left",
  IMAGE_PREVIEW_NEXT: iconPrefix + "arrow-right",
  IMAGE_PREVIEW_PCT_FULL: iconPrefix + "pct-full",
  IMAGE_PREVIEW_PCT_1_1: iconPrefix + "pct-1-1",
  IMAGE_PREVIEW_ZOOM_OUT: iconPrefix + "search-zoom-out",
  IMAGE_PREVIEW_ZOOM_IN: iconPrefix + "search-zoom-in",
  IMAGE_PREVIEW_ROTATE_LEFT: iconPrefix + "rotate-left",
  IMAGE_PREVIEW_ROTATE_RIGHT: iconPrefix + "rotate-right",
  IMAGE_PREVIEW_PRINT: iconPrefix + "print",
  IMAGE_PREVIEW_DOWNLOAD: iconPrefix + "download",
  // alert
  ALERT_CLOSE: iconPrefix + "close",
  ALERT_INFO: iconPrefix + "info-circle-fill",
  ALERT_SUCCESS: iconPrefix + "success-circle-fill",
  ALERT_WARNING: iconPrefix + "warning-circle-fill",
  ALERT_ERROR: iconPrefix + "error-circle-fill",
  // tree
  TREE_NODE_OPEN: iconPrefix + "caret-right rotate90",
  TREE_NODE_CLOSE: iconPrefix + "caret-right",
  TREE_NODE_LOADED: iconPrefix + "spinner roll",
  // tree-select
  TREE_SELECT_LOADED: iconPrefix + "spinner roll",
  TREE_SELECT_OPEN: iconPrefix + "caret-down rotate180",
  TREE_SELECT_CLOSE: iconPrefix + "caret-down",
  // table-select
  TABLE_SELECT_LOADED: iconPrefix + "spinner roll",
  TABLE_SELECT_OPEN: iconPrefix + "caret-down rotate180",
  TABLE_SELECT_CLOSE: iconPrefix + "caret-down",
  // tabs
  TABS_TAB_BUTTON_TOP: iconPrefix + "arrow-up",
  TABS_TAB_BUTTON_BOTTOM: iconPrefix + "arrow-down",
  TABS_TAB_BUTTON_LEFT: iconPrefix + "arrow-left",
  TABS_TAB_BUTTON_RIGHT: iconPrefix + "arrow-right",
  TABS_TAB_CLOSE: iconPrefix + "close",
  TABS_TAB_REFRESH: iconPrefix + "refresh",
  TABS_TAB_REFRESH_LOADING: iconPrefix + "refresh roll",
  // text
  TEXT_COPY: iconPrefix + "copy",
  TEXT_LOADING: iconPrefix + "spinner roll",
  // tag
  TAG_CLOSE: iconPrefix + "close",
  TAG_LOADING: iconPrefix + "spinner roll",
  // carousel
  CAROUSEL_HORIZONTAL_PREVIOUS: iconPrefix + "arrow-left",
  CAROUSEL_HORIZONTAL_NEXT: iconPrefix + "arrow-right",
  CAROUSEL_VERTICAL_PREVIOUS: iconPrefix + "arrow-up",
  CAROUSEL_VERTICAL_NEXT: iconPrefix + "arrow-down",
  // collapse
  COLLAPSE_OPEN: iconPrefix + "arrow-right rotate90",
  COLLAPSE_CLOSE: iconPrefix + "arrow-right",
  // empty
  EMPTY_DEFAULT: iconPrefix + "empty",
  // result
  RESULT_INFO: iconPrefix + "info-circle-fill",
  RESULT_SUCCESS: iconPrefix + "success-circle-fill",
  RESULT_WARNING: iconPrefix + "warning-circle-fill",
  RESULT_ERROR: iconPrefix + "error-circle-fill",
  RESULT_QUESTION: iconPrefix + "question-circle-fill",
  RESULT_LOADING: iconPrefix + "spinner roll",
  // rate
  RATE_CHECKED: iconPrefix + "star-fill",
  RATE_UNCHECKED: iconPrefix + "star",
  // color-picker
  COLOR_PICKER_COLOR_COPY: iconPrefix + "copy",
  COLOR_PICKER_EYE_DROPPER: iconPrefix + "dropper",
  COLOR_PICKER_TPTY_OPEN: iconPrefix + "arrow-down rotate180",
  COLOR_PICKER_TPTY_CLOSE: iconPrefix + "arrow-down",
  // split
  SPLIT_TOP_ACTION: iconPrefix + "arrow-up",
  SPLIT_BOTTOM_ACTION: iconPrefix + "arrow-down",
  SPLIT_LEFT_ACTION: iconPrefix + "arrow-left",
  SPLIT_RIGHT_ACTION: iconPrefix + "arrow-right"
});

// node_modules/vxe-pc-ui/es/language/zh-CN.js
var zh_CN_default = {
  vxe: {
    base: {
      pleaseInput: "请输入",
      pleaseSelect: "请选择",
      comma: "，",
      fullStop: "。"
    },
    loading: {
      text: "加载中..."
    },
    error: {
      downErr: "下载失败",
      errLargeData: "当绑定的数据量过大时，应该请使用 {0}，否则可能会出现卡顿",
      groupFixed: "如果使用分组表头，冻结列必须按组设置",
      groupMouseRange: '分组表头与 "{0}" 不能同时使用，这可能会出现错误',
      groupTag: '分组列头应该使用 "{0}" 而不是 "{1}"，这可能会出现错误',
      scrollErrProp: '启用虚拟滚动后不支持该参数 "{0}"',
      errConflicts: '参数 "{0}" 与 "{1}" 有冲突',
      modelConflicts: '绑定的字段值 "{0}" 与 "{1}" 存在冲突，将会出现错误',
      notSupportProp: '当启用参数 "{0}" 时不支持 "{1}"，应该为 "{2}"，否则将会出现错误',
      reqSupportProp: '当使用 "{0}" 时，应该设置 "{1}"，否则可能会出现错误',
      notConflictProp: '当使用 "{0}" 时，应该设置 "{1}"，否则可能会存在功能冲突',
      unableInsert: "无法插入到指定位置，请检查参数是否正确",
      useErr: '安装 "{0}" 模块时发生错误，可能顺序不正确，依赖的模块需要在 Table 之前安装',
      barUnableLink: "工具栏无法关联表格",
      expandContent: '展开行的插槽应该是 "content"，请检查是否正确',
      reqComp: '缺少 "{0}" 组件，请检查是否正确安装。 https://vxeui.com/#/start/useGlobal',
      reqModule: '缺少 "{0}" 模块',
      reqProp: '缺少必要的 "{0}" 参数，这可能会导致出现错误',
      emptyProp: '参数 "{0}" 不允许为空',
      errProp: '不支持的参数 "{0}"，可能为 "{1}"',
      colRepet: 'column.{0}="{1}" 重复了，这可能会导致某些功能无法使用',
      notFunc: '方法 "{0}" 不存在',
      errFunc: '参数 "{0}" 不是一个方法',
      notValidators: '全局校验 "{0}" 不存在',
      notFormats: '全局格式化 "{0}" 不存在',
      notCommands: '全局指令 "{0}" 不存在',
      notSlot: '插槽 "{0}" 不存在',
      noTree: '树结构不支持 "{0}"',
      noGroup: '数据分组后不支持 "{0}"',
      notProp: '不支持的参数 "{0}"',
      checkProp: '当数据量过大时可能会导致复选框卡顿，建议设置参数 "{0}" 提升渲染速度',
      coverProp: '"{0}" 的参数 "{1}" 重复定义，这可能会出现错误',
      uniField: '字段名 "{0}" 重复定义，这可能会出现错误',
      repeatKey: '主键重复 {0}="{1}"，这可能会出现错误',
      repeatProp: '参数重复 {0}="{1}"，这可能会出现错误',
      delFunc: '方法 "{0}" 已废弃，请使用 "{1}"',
      delProp: '参数 "{0}" 已废弃，请使用 "{1}"',
      delEvent: '事件 "{0}" 已废弃，请使用 "{1}"',
      removeProp: '参数 "{0}" 已废弃，不建议使用，这可能会导致出现错误',
      errFormat: '全局的格式化内容应该使用 "VXETable.formats" 定义，挂载 "formatter={0}" 的方式已不建议使用',
      notType: '不支持的文件类型 "{0}"',
      notExp: "该浏览器不支持导入/导出功能",
      impFields: "导入失败，请检查字段名和数据格式是否正确",
      treeNotImp: "树表格不支持导入",
      treeCrossDrag: "只能拖拽第一层级",
      treeDragChild: "父级不能拖拽到自己的子级中",
      reqPlugin: '扩展插件未安装 "{1}" https://vxeui.com/other{0}/#/{1}/install',
      errMaxRow: "超过支持的最大数据量 {0} 行，这可能会导致出现错误",
      useNew: "不建议使用 {0}，请使用 {1}",
      errorVersion: "版本不匹配，当前版本 {0}，最低支持版本为 {1}"
    },
    table: {
      emptyText: "暂无数据",
      allTitle: "全选/取消",
      seqTitle: "序号",
      actionTitle: "操作",
      confirmFilter: "筛选",
      resetFilter: "重置",
      allFilter: "全部",
      sortAsc: "升序：最低到最高",
      sortDesc: "降序：最高到最低",
      filter: "对所选的列启用筛选",
      impSuccess: "成功导入 {0} 条记录",
      expLoading: "正在导出中",
      expSuccess: "导出成功",
      expError: "导出失败",
      expFilename: "导出_{0}",
      expOriginFilename: "导出_源_{0}",
      customTitle: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customClose: "关闭",
      customCancel: "取消",
      customRestore: "恢复默认",
      maxFixedCol: "最大冻结列的数量不能超过 {0} 个",
      maxGroupCol: "最大分组字段的数量不能超过 {0} 个",
      dragTip: "移动：{0}",
      resizeColTip: "宽：{0} 像素",
      resizeRowTip: "高：{0} 像素",
      rowGroupContentTotal: "{0}（{1}）",
      menuLoading: "加载中..."
    },
    grid: {
      selectOneRecord: "请至少选择一条记录！",
      deleteSelectRecord: "您确定要删除所选记录吗？",
      removeSelectRecord: "您确定要移除所选记录吗？",
      dataUnchanged: "数据未改动！",
      delSuccess: "成功删除所选记录！",
      saveSuccess: "保存成功！",
      operError: "发生错误，操作失败！"
    },
    select: {
      clear: "清除",
      allChecked: "全选",
      total: "{0} / {1}",
      search: "搜索",
      loadingText: "加载中",
      emptyText: "暂无数据",
      maxSize: "最大可选择的数量不能超过 {0} 个",
      overSizeErr: "已超出最大可选数量 {0} 个，超出部分将被忽略！",
      searchEmpty: "未匹配到数据！"
    },
    tree: {
      searchEmpty: "未匹配到数据！"
    },
    treeSelect: {
      clearChecked: "清除",
      allChecked: "全选",
      allExpand: "全部展开",
      clearExpand: "全部收起",
      total: "已选 {0}",
      search: "搜索",
      emptyText: "暂无数据"
    },
    pager: {
      goto: "前往",
      gotoTitle: "页数",
      pagesize: "{0}条/页",
      total: "共 {0} 条记录",
      pageClassifier: "页",
      homePage: "首页",
      homePageTitle: "首页",
      prevPage: "上一页",
      prevPageTitle: "上一页",
      nextPage: "下一页",
      nextPageTitle: "下一页",
      prevJump: "向上跳页",
      prevJumpTitle: "向上跳页",
      nextJump: "向下跳页",
      nextJumpTitle: "向下跳页",
      endPage: "末页",
      endPageTitle: "末页"
    },
    alert: {
      title: "系统提示"
    },
    button: {
      confirm: "确认",
      cancel: "取消",
      clear: "清除"
    },
    filter: {
      search: "搜索"
    },
    custom: {
      cstmTitle: "列设置",
      cstmRestore: "恢复默认",
      cstmCancel: "取消",
      cstmConfirm: "确定",
      cstmConfirmRestore: "请确认是否恢复成默认列配置？",
      cstmDragTarget: "移动：{0}",
      setting: {
        colSort: "排序",
        sortHelpTip: "点击并拖动图标可以调整顺序",
        colTitle: "列标题",
        colResizable: "列宽（像素）",
        colVisible: "是否显示",
        colFixed: "冻结列",
        colFixedMax: "冻结列（最多 {0} 列）",
        fixedLeft: "左侧",
        fixedUnset: "不设置",
        fixedRight: "右侧"
      }
    },
    import: {
      modes: {
        covering: "覆盖方式（直接覆盖表格数据）",
        insert: "底部追加（在表格的底部追加新数据）",
        insertTop: "顶部追加（在表格的顶部追加新数据）",
        insertBottom: "底部追加（在表格的底部追加新数据）"
      },
      impTitle: "导入数据",
      impFile: "文件名",
      impSelect: "选择文件",
      impType: "文件类型",
      impOpts: "参数设置",
      impMode: "导入模式",
      impConfirm: "导入",
      impCancel: "取消"
    },
    export: {
      types: {
        csv: "CSV (逗号分隔)(*.csv)",
        html: "网页(*.html)",
        xml: "XML 数据(*.xml)",
        txt: "文本文件(制表符分隔)(*.txt)",
        xls: "Excel 97-2003 工作簿(*.xls)",
        xlsx: "Excel 工作簿(*.xlsx)",
        pdf: "PDF (*.pdf)"
      },
      modes: {
        empty: "空数据",
        current: "当前数据（当前页的数据）",
        selected: "选中数据（当前页选中的数据）",
        all: "全量数据（包括所有分页的数据）"
      },
      printTitle: "打印数据",
      expTitle: "导出数据",
      expName: "文件名",
      expNamePlaceholder: "请输入文件名",
      expSheetName: "标题",
      expSheetNamePlaceholder: "请输入标题",
      expType: "保存类型",
      expMode: "选择数据",
      expCurrentColumn: "全部字段",
      expColumn: "选择字段",
      expOpts: "参数设置",
      expOptHeader: "表头",
      expHeaderTitle: "是否需要表头",
      expOptFooter: "表尾",
      expFooterTitle: "是否需要表尾",
      expOptColgroup: "分组表头",
      expOptTitle: "列标题",
      expTitleTitle: "是否为列标题，否则显示为列的字段名",
      expColgroupTitle: "如果存在，则支持带有分组结构的表头",
      expOptMerge: "合并",
      expMergeTitle: "如果存在，则支持带有合并结构的单元格",
      expOptAllExpand: "展开树",
      expAllExpandTitle: "如果存在，则支持将带有层级结构的数据全部展开",
      expOptUseStyle: "样式",
      expUseStyleTitle: "如果存在，则支持带样式的单元格",
      expOptOriginal: "源数据",
      expOriginalTitle: "如果为源数据，则支持导入到表格中",
      expPrint: "打印",
      expConfirm: "导出",
      expCancel: "取消"
    },
    modal: {
      errTitle: "错误提示",
      zoomMin: "最小化",
      zoomIn: "最大化",
      zoomOut: "还原",
      close: "关闭",
      miniMaxSize: "最小化窗口的数量不能超过 {0} 个",
      footPropErr: "show-footer 仅用于启用表尾，需配合 show-confirm-button | show-cancel-button | 插槽使用"
    },
    drawer: {
      close: "关闭"
    },
    form: {
      folding: "收起",
      unfolding: "展开"
    },
    toolbar: {
      import: "导入",
      export: "导出",
      print: "打印",
      refresh: "刷新",
      zoomIn: "全屏",
      zoomOut: "还原",
      custom: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customRestore: "重置",
      fixedLeft: "冻结在左侧",
      fixedRight: "冻结在右侧",
      cancelFixed: "取消冻结列"
    },
    datePicker: {
      yearTitle: "{0} 年"
    },
    dateRangePicker: {
      pleaseRange: "请选择开始日期与结束日期"
    },
    input: {
      date: {
        m1: "01 月",
        m2: "02 月",
        m3: "03 月",
        m4: "04 月",
        m5: "05 月",
        m6: "06 月",
        m7: "07 月",
        m8: "08 月",
        m9: "09 月",
        m10: "10 月",
        m11: "11 月",
        m12: "12 月",
        quarterLabel: "{0} 年",
        monthLabel: "{0} 年",
        dayLabel: "{0} 年 {1}",
        labelFormat: {
          date: "yyyy-MM-dd",
          time: "HH:mm:ss",
          datetime: "yyyy-MM-dd HH:mm:ss",
          week: "yyyy 年第 WW 周",
          month: "yyyy-MM",
          quarter: "yyyy 年第 q 季度",
          year: "yyyy"
        },
        weeks: {
          w: "",
          w0: "周日",
          w1: "周一",
          w2: "周二",
          w3: "周三",
          w4: "周四",
          w5: "周五",
          w6: "周六"
        },
        months: {
          m0: "一月",
          m1: "二月",
          m2: "三月",
          m3: "四月",
          m4: "五月",
          m5: "六月",
          m6: "七月",
          m7: "八月",
          m8: "九月",
          m9: "十月",
          m10: "十一月",
          m11: "十二月"
        },
        quarters: {
          q1: "第一季度",
          q2: "第二季度",
          q3: "第三季度",
          q4: "第四季度"
        }
      }
    },
    numberInput: {
      currencySymbol: "¥"
    },
    imagePreview: {
      popupTitle: "预览",
      operBtn: {
        zoomOut: "缩小",
        zoomIn: "放大",
        pctFull: "等比例缩放",
        pct11: "显示原始尺寸",
        rotateLeft: "向左旋转",
        rotateRight: "向右旋转",
        print: "点击打印图片",
        download: "点击下载图片"
      }
    },
    upload: {
      fileBtnText: "点击或拖拽上传",
      imgBtnText: "点击或拖拽上传",
      dragPlaceholder: "请把文件拖放到这个区域即可上传",
      imgSizeHint: "单张{0}",
      imgCountHint: "最多{0}张",
      fileTypeHint: "支持 {0} 文件类型",
      fileSizeHint: "单个文件大小不超过{0}",
      fileCountHint: "最多可上传{0}个文件",
      uploadTypeErr: "文件类型不匹配！",
      overCountErr: "最多只能选择{0}个文件！",
      overCountExtraErr: "已超出最大数量{0}个，超出的{1}个文件将被忽略！",
      overSizeErr: "文件大小最大不能超过{0}！",
      manualUpload: "点击上传",
      reUpload: "重新上传",
      uploadProgress: "上传中 {0}%",
      uploadErr: "上传失败",
      uploadSuccess: "上传成功",
      moreBtnText: "更多（{0}）",
      viewItemTitle: "点击查看",
      morePopup: {
        readTitle: "查看列表",
        imageTitle: "上传图片",
        fileTitle: "上传文件"
      }
    },
    empty: {
      defText: "暂无数据"
    },
    colorPicker: {
      clear: "清除",
      confirm: "确认",
      copySuccess: "已复制到剪贴板：{0}",
      hex: "十六进制"
    },
    formDesign: {
      formName: "表单名称",
      defFormTitle: "未命名的表单",
      widgetPropTab: "控件属性",
      widgetFormTab: "表单属性",
      error: {
        wdFormUni: "该类型的控件在表单中只允许添加一个",
        wdSubUni: "该类型的控件在子表中只允许添加一个"
      },
      styleSetting: {
        btn: "样式设置",
        title: "表单的样式设置",
        layoutTitle: "控件布局",
        verticalLayout: "上下布局",
        horizontalLayout: "横向布局",
        styleTitle: "标题样式",
        boldTitle: "标题加粗",
        fontBold: "加粗",
        fontNormal: "常规",
        colonTitle: "显示冒号",
        colonVisible: "显示",
        colonHidden: "隐藏",
        alignTitle: "对齐方式",
        widthTitle: "标题宽度",
        alignLeft: "居左",
        alignRight: "居右",
        unitPx: "像素",
        unitPct: "百分比"
      },
      widget: {
        group: {
          base: "基础控件",
          layout: "布局控件",
          system: "系统控件",
          module: "模块控件",
          chart: "图表控件",
          advanced: "高级控件"
        },
        copyTitle: "副本_{0}",
        component: {
          input: "输入框",
          textarea: "文本域",
          select: "下拉选择",
          row: "一行多列",
          title: "标题",
          text: "文本",
          subtable: "子表",
          VxeSwitch: "是/否",
          VxeInput: "输入框",
          VxeNumberInput: "数字",
          VxeDatePicker: "日期",
          VxeTextarea: "文本域",
          VxeSelect: "下拉选择",
          VxeTreeSelect: "树形选择",
          VxeRadioGroup: "单选框",
          VxeCheckboxGroup: "复选框",
          VxeUploadFile: "文件",
          VxeUploadImage: "图片",
          VxeRate: "评分",
          VxeSlider: "滑块"
        }
      },
      widgetProp: {
        name: "控件名称",
        placeholder: "提示语",
        required: "必填校验",
        multiple: "允许多选",
        displaySetting: {
          name: "显示设置",
          pc: "电脑端",
          mobile: "手机端",
          visible: "显示",
          hidden: "隐藏"
        },
        dataSource: {
          name: "数据源",
          defValue: "选项{0}",
          addOption: "添加选项",
          batchEditOption: "批量编辑",
          batchEditTip: "每行对应一个选项，支持从表格、Excel、WPS 中直接复制粘贴。",
          batchEditSubTip: "每行对应一个选项，如果是分组，子项可以是空格或制表键开头，支持从表格、Excel、WPS 中直接复制粘贴。",
          buildOption: "生成选项"
        },
        rowProp: {
          colSize: "列数",
          col2: "两列",
          col3: "三列",
          col4: "四列",
          col6: "六列",
          layout: "布局"
        },
        textProp: {
          name: "内容",
          alignTitle: "对齐方式",
          alignLeft: "居左",
          alignCenter: "居中",
          alignRight: "居右",
          colorTitle: "字体颜色",
          sizeTitle: "字体大小",
          boldTitle: "字体加粗",
          fontNormal: "常规",
          fontBold: "加粗"
        },
        subtableProp: {
          seqTitle: "序号",
          showSeq: "显示序号",
          showCheckbox: "允许多选",
          errSubDrag: "子表不支持该控件，请使用其他控件",
          colPlace: "将控件拖拽进来"
        },
        uploadProp: {
          limitFileCount: "文件数量限制",
          limitFileSize: "文件大小限制",
          multiFile: "允许上传多个文件",
          limitImgCount: "图片数量限制",
          limitImgSize: "图片大小限制",
          multiImg: "允许上传多张图片"
        }
      }
    },
    listDesign: {
      fieldSettingTab: "字段设置",
      listSettingTab: "参数设置",
      searchTitle: "查询条件",
      listTitle: "列表字段",
      searchField: "查询字段",
      listField: "列表字段",
      activeBtn: {
        ActionButtonUpdate: "编辑",
        ActionButtonDelete: "删除"
      },
      search: {
        addBtn: "编辑",
        emptyText: "未配置查询条件",
        editPopupTitle: "编辑查询字段"
      },
      searchPopup: {
        colTitle: "标题",
        saveBtn: "保存"
      }
    },
    text: {
      copySuccess: "已复制到剪贴板",
      copyError: "当前环境不支持该操作"
    },
    countdown: {
      formats: {
        yyyy: "年",
        MM: "月",
        dd: "天",
        HH: "时",
        mm: "分",
        ss: "秒"
      }
    },
    gantt: {
      tFullFormat: {
        year: "{yy}年",
        quarter: "{yy}年第{q}季度",
        month: "{yy}年{M}月",
        week: "{yy}年第{W}周",
        day: "{yy}年{M}月{E}日",
        date: "{yy}年{M}月{d}日",
        hour: "{yy}年 {M}月{d}日{H}时",
        minute: "{yy}年{M}月{d}日{H}时{m}分"
      },
      tSimpleFormat: {
        year: "{yy}年",
        quarter: "{q}季度",
        month: "{M}月",
        week: "{W}周",
        day: "{d}",
        date: "{d}",
        hour: "{H}时",
        minute: "{m}分"
      },
      dayss: {
        w0: "日",
        w1: "一",
        w2: "二",
        w3: "三",
        w4: "四",
        w5: "五",
        w6: "六"
      }
    },
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: "无法对合并单元格进行该操作",
          multiErr: "无法对多重选择区域进行该操作",
          selectErr: "无法操作指定区域的单元格",
          extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
          pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作",
          cpInvalidErr: "该操作无法进行，您选择的区域中存在被禁止的列（{0}）"
        },
        fnr: {
          title: "查找和替换",
          findLabel: "查找",
          replaceLabel: "替换",
          findTitle: "查找内容：",
          replaceTitle: "替换为：",
          tabs: {
            find: "查找",
            replace: "替换"
          },
          filter: {
            re: "正则表达式",
            whole: "全词匹配",
            sensitive: "区分大小写"
          },
          btns: {
            findNext: "查找下一个",
            findAll: "查找全部",
            replace: "替换",
            replaceAll: "替换全部",
            cancel: "取消"
          },
          header: {
            seq: "#",
            cell: "单元格",
            value: "值"
          },
          body: {
            row: "行：{0}",
            col: "列：{0}"
          },
          empty: "(空值)",
          reError: "无效的正则表达式",
          recordCount: "已找到 {0} 个单元格",
          notCell: "找不到匹配的单元格",
          replaceSuccess: "成功替换 {0} 个单元格"
        }
      },
      extendPivotTable: {
        aggregation: {
          grouping: "分组",
          values: "值",
          groupPlaceholder: "拖至此处进行分组",
          valuesPlaceholder: "拖至此处进行聚合",
          dragExistCol: "该列已存在",
          sortHelpTip: "点击并拖动图标可以调整顺序"
        },
        aggFuncs: {
          sum: "求和",
          count: "计数",
          avg: "平均值",
          min: "最小值",
          max: "最大值",
          first: "首个值",
          last: "末尾值"
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧"
        },
        cases: {
          equal: "等于",
          gt: "大于",
          lt: "小于",
          begin: "开头是",
          endin: "结尾是",
          include: "包含",
          isSensitive: "区分大小写"
        }
      },
      filterCombination: {
        menus: {
          sort: "排序",
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        cases: {
          equal: "等于",
          unequal: "不等于",
          gt: "大于",
          ge: "大于或等于",
          lt: "小于",
          le: "小于或等于",
          begin: "开头是",
          notbegin: "开头不是",
          endin: "结尾是",
          notendin: "结尾不是",
          include: "包含",
          exclude: "不包含",
          between: "介于",
          custom: "自定义筛选",
          insensitive: "不区分大小写",
          isSensitive: "区分大小写"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    },
    pro: {
      area: {
        mergeErr: "无法对合并单元格进行该操作",
        multiErr: "无法对多重选择区域进行该操作",
        extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
        pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作"
      },
      fnr: {
        title: "查找和替换",
        findLabel: "查找",
        replaceLabel: "替换",
        findTitle: "查找内容：",
        replaceTitle: "替换为：",
        tabs: {
          find: "查找",
          replace: "替换"
        },
        filter: {
          re: "正则表达式",
          whole: "全词匹配",
          sensitive: "区分大小写"
        },
        btns: {
          findNext: "查找下一个",
          findAll: "查找全部",
          replace: "替换",
          replaceAll: "替换全部",
          cancel: "取消"
        },
        header: {
          seq: "#",
          cell: "单元格",
          value: "值"
        },
        empty: "(空值)",
        reError: "无效的正则表达式",
        recordCount: "已找到 {0} 个单元格",
        notCell: "找不到匹配的单元格",
        replaceSuccess: "成功替换 {0} 个单元格"
      }
    },
    renderer: {
      search: "搜索",
      cases: {
        equal: "等于",
        unequal: "不等于",
        gt: "大于",
        ge: "大于或等于",
        lt: "小于",
        le: "小于或等于",
        begin: "开头是",
        notbegin: "开头不是",
        endin: "结尾是",
        notendin: "结尾不是",
        include: "包含",
        exclude: "不包含",
        between: "介于",
        custom: "自定义筛选",
        insensitive: "不区分大小写",
        isSensitive: "区分大小写"
      },
      combination: {
        menus: {
          sort: "排序",
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结到左侧",
          fixedRight: "冻结到右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    }
  }
};

// node_modules/vxe-pc-ui/es/alert/src/alert.js
var import_xe_utils2 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/ui/src/vn.js
var import_xe_utils = __toESM(require_xe_utils());
function getOnName(type) {
  return "on" + type.substring(0, 1).toLocaleUpperCase() + type.substring(1);
}
function getModelEvent(renderOpts) {
  switch (renderOpts.name) {
    case "input":
    case "textarea":
      return "input";
    case "select":
      return "change";
  }
  return "update:modelValue";
}
function getChangeEvent(renderOpts) {
  switch (renderOpts.name) {
    case "input":
    case "textarea":
    case "VxeInput":
    case "VxeTextarea":
    case "$input":
    // 已废弃
    case "$textarea":
      return "input";
  }
  return "change";
}
function getSlotVNs2(vns) {
  if (import_xe_utils.default.isArray(vns)) {
    return vns;
  }
  return vns ? [vns] : [];
}

// node_modules/vxe-pc-ui/es/alert/src/alert.js
var alert_default = defineVxeComponent({
  name: "VxeAlert",
  props: {
    title: {
      type: [String, Number],
      default: () => getConfig().alert.title
    },
    content: [String, Number],
    status: String,
    showIcon: Boolean,
    showClose: Boolean,
    icon: {
      type: String,
      default: () => getConfig().alert.icon
    }
  },
  emits: [
    "close"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils2.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeAlert = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const alertMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $alert: $xeAlert }, params));
      }
    };
    const closeEvent = (evnt) => {
      alertMethods.dispatchEvent("close", {}, evnt);
    };
    const alertPrivateMethods = {};
    Object.assign($xeAlert, alertMethods, alertPrivateMethods);
    const renderVN = () => {
      const { status, content, icon, title, showIcon, showClose } = props;
      const defaultSlot = slots.default;
      const titleSlot = slots.title;
      const iconSlot = slots.icon;
      return h("div", {
        ref: refElem,
        class: ["vxe-alert", {
          [`theme--${status}`]: status
        }]
      }, [
        iconSlot || showIcon && status || icon ? h("div", {
          class: "vxe-alert--icon"
        }, iconSlot ? getSlotVNs2(iconSlot({})) : [
          h("i", {
            class: icon || getIcon()[`ALERT_${status === null || status === void 0 ? void 0 : status.toUpperCase()}`]
          })
        ]) : renderEmptyElement($xeAlert),
        h("div", {
          class: "vxe-alert--body"
        }, [
          titleSlot || title ? h("div", {
            class: "vxe-alert--title"
          }, titleSlot ? getSlotVNs2(titleSlot({})) : import_xe_utils2.default.toValueString(title)) : renderEmptyElement($xeAlert),
          h("div", {
            class: "vxe-alert--content"
          }, defaultSlot ? getSlotVNs2(defaultSlot({})) : import_xe_utils2.default.toValueString(content))
        ]),
        showClose ? h("div", {
          class: "vxe-alert--close-btn",
          onClick: closeEvent
        }, [
          h("i", {
            class: getIcon().ALERT_CLOSE
          })
        ]) : renderEmptyElement($xeAlert)
      ]);
    };
    $xeAlert.renderVN = renderVN;
    return $xeAlert;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/alert/index.js
var VxeAlert = Object.assign({}, alert_default, {
  install(app) {
    app.component(alert_default.name, alert_default);
  }
});
dynamicApp.use(VxeAlert);
VxeUI.component(alert_default);
var Alert = VxeAlert;
var alert_default2 = VxeAlert;

// node_modules/vxe-pc-ui/es/anchor/src/anchor.js
var import_xe_utils6 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/ui/src/dom.js
var import_xe_utils3 = __toESM(require_xe_utils());
var tpImgEl;
function initTpImg() {
  if (!tpImgEl) {
    tpImgEl = new Image();
    tpImgEl.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=";
  }
  return tpImgEl;
}
function getTpImg() {
  if (!tpImgEl) {
    return initTpImg();
  }
  return tpImgEl;
}
var reClsMap = {};
function getClsRE(cls) {
  if (!reClsMap[cls]) {
    reClsMap[cls] = new RegExp(`(?:^|\\s)${cls}(?!\\S)`, "g");
  }
  return reClsMap[cls];
}
function getNodeOffset(elem, container, rest) {
  if (elem) {
    const parentElem = elem.parentNode;
    rest.top += elem.offsetTop;
    rest.left += elem.offsetLeft;
    if (parentElem && parentElem !== document.documentElement && parentElem !== document.body) {
      rest.top -= parentElem.scrollTop;
      rest.left -= parentElem.scrollLeft;
    }
    if (container && (elem === container || elem.offsetParent === container) ? 0 : elem.offsetParent) {
      return getNodeOffset(elem.offsetParent, container, rest);
    }
  }
  return rest;
}
function isScale(val) {
  return val && /^\d+%$/.test(val);
}
function hasClass(elem, cls) {
  return !!(elem && elem.className && elem.className.match && elem.className.match(getClsRE(cls)));
}
function removeClass(elem, cls) {
  if (elem && hasClass(elem, cls)) {
    elem.className = elem.className.replace(getClsRE(cls), "");
  }
}
function addClass(elem, cls) {
  if (elem && !hasClass(elem, cls)) {
    removeClass(elem, cls);
    elem.className = `${elem.className} ${cls}`;
  }
}
function hasControlKey(evnt) {
  return evnt.ctrlKey || evnt.metaKey;
}
function toCssUnit(val, unit = "px") {
  if (import_xe_utils3.default.isNumber(val) || /^\d+$/.test(`${val}`)) {
    return `${val}${unit}`;
  }
  return `${val || ""}`;
}
function getDomNode() {
  const documentElement = document.documentElement;
  const bodyElem = document.body;
  return {
    scrollTop: documentElement.scrollTop || bodyElem.scrollTop,
    scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft,
    visibleHeight: documentElement.clientHeight || bodyElem.clientHeight,
    visibleWidth: documentElement.clientWidth || bodyElem.clientWidth
  };
}
function getEventTargetNode(evnt, container, queryCls, queryMethod) {
  let targetElem;
  let target = evnt.target.shadowRoot && evnt.composed ? evnt.composedPath()[0] || evnt.target : evnt.target;
  while (target && target.nodeType && target !== document) {
    if (queryCls && hasClass(target, queryCls) && (!queryMethod || queryMethod(target))) {
      targetElem = target;
    } else if (target === container) {
      return { flag: queryCls ? !!targetElem : true, container, targetElem };
    }
    target = target.parentNode;
  }
  return { flag: false };
}
function getOffsetPos(elem, container) {
  return getNodeOffset(elem, container, { left: 0, top: 0 });
}
function getAbsolutePos(elem) {
  const bounding = elem.getBoundingClientRect();
  const boundingTop = bounding.top;
  const boundingLeft = bounding.left;
  const { scrollTop, scrollLeft, visibleHeight, visibleWidth } = getDomNode();
  return { boundingTop, top: scrollTop + boundingTop, boundingLeft, left: scrollLeft + boundingLeft, visibleHeight, visibleWidth };
}
function getPaddingTopBottomSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingTop = import_xe_utils3.default.toNumber(computedStyle.paddingTop);
    const paddingBottom = import_xe_utils3.default.toNumber(computedStyle.paddingBottom);
    return paddingTop + paddingBottom;
  }
  return 0;
}
var scrollIntoViewIfNeeded = "scrollIntoViewIfNeeded";
var scrollIntoView = "scrollIntoView";
function scrollToView(elem) {
  if (elem) {
    if (elem[scrollIntoViewIfNeeded]) {
      elem[scrollIntoViewIfNeeded]();
    } else if (elem[scrollIntoView]) {
      elem[scrollIntoView]();
    }
  }
}
function updatePanelPlacement(targetElem, panelElem, options) {
  const { placement, teleportTo, marginSize } = Object.assign({ teleportTo: false, marginSize: 18 }, options);
  let panelPlacement = "bottom";
  let top = "";
  let bottom = "";
  let left = "";
  const right = "";
  let minWidth = "";
  const stys = {};
  if (panelElem && targetElem) {
    const documentElement = document.documentElement;
    const bodyElem = document.body;
    const targetHeight = targetElem.offsetHeight;
    const panelHeight = panelElem.offsetHeight;
    const panelWidth = panelElem.offsetWidth;
    const panelRect = panelElem.getBoundingClientRect();
    const targetRect = targetElem.getBoundingClientRect();
    const visibleHeight = documentElement.clientHeight || bodyElem.clientHeight;
    const visibleWidth = documentElement.clientWidth || bodyElem.clientWidth;
    minWidth = targetElem.offsetWidth;
    if (teleportTo) {
      left = targetRect.left;
      top = targetRect.top + targetHeight;
      if (placement === "top") {
        panelPlacement = "top";
        top = targetRect.top - panelHeight;
      } else if (!placement) {
        if (top + panelHeight + marginSize > visibleHeight) {
          panelPlacement = "top";
          top = targetRect.top - panelHeight;
        }
        if (top < marginSize) {
          panelPlacement = "bottom";
          top = targetRect.top + targetHeight;
        }
      }
      if (left + panelWidth + marginSize > visibleWidth) {
        left -= left + panelWidth + marginSize - visibleWidth;
      }
      if (left < marginSize) {
        left = marginSize;
      }
    } else {
      if (placement === "top") {
        panelPlacement = "top";
        bottom = targetHeight;
      } else if (!placement) {
        top = targetHeight;
        if (targetRect.top + targetRect.height + marginSize > visibleHeight) {
          if (targetRect.top - targetHeight - panelHeight > marginSize) {
            panelPlacement = "top";
            top = "";
            bottom = targetHeight;
          }
        }
      }
      if (panelRect.left + panelRect.width + marginSize > visibleWidth) {
        left = -(panelRect.left + panelRect.width + marginSize - visibleWidth);
      }
    }
    if (import_xe_utils3.default.isNumber(top)) {
      stys.top = toCssUnit(top);
    }
    if (import_xe_utils3.default.isNumber(bottom)) {
      stys.bottom = toCssUnit(bottom);
    }
    if (import_xe_utils3.default.isNumber(left)) {
      stys.left = toCssUnit(left);
    }
    if (import_xe_utils3.default.isNumber(right)) {
      stys.right = toCssUnit(right);
    }
    if (import_xe_utils3.default.isNumber(minWidth)) {
      stys.minWidth = toCssUnit(minWidth);
    }
  }
  return {
    top: top || 0,
    bottom: bottom || 0,
    left: left || 0,
    right: right || 0,
    style: stys,
    placement: panelPlacement
  };
}

// node_modules/vxe-pc-ui/es/anchor/src/anchor-link.js
var import_xe_utils5 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/anchor/src/util.js
var import_xe_utils4 = __toESM(require_xe_utils());
function assembleAnchorLink($xeAnchor, elem, linkConfig, $xeParentAnchorLink) {
  const staticLinks = $xeAnchor.reactData.staticLinks;
  const parentElem = elem.parentNode;
  const parentLinkConfig = $xeParentAnchorLink ? $xeParentAnchorLink.linkConfig : null;
  const parentLinks = parentLinkConfig ? parentLinkConfig.children : staticLinks;
  if (parentElem && parentLinks) {
    parentLinks.splice(import_xe_utils4.default.arrayIndexOf(parentElem.children, elem), 0, linkConfig);
    $xeAnchor.reactData.staticLinks = staticLinks.slice(0);
  }
}
function destroyAnchorLink($xeAnchor, linkConfig) {
  const staticLinks = $xeAnchor.reactData.staticLinks;
  const matchObj = import_xe_utils4.default.findTree(staticLinks, (item) => item.id === linkConfig.id, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeAnchor.reactData.staticLinks = staticLinks.slice(0);
}

// node_modules/vxe-pc-ui/es/anchor/src/anchor-link.js
var anchor_link_default = defineVxeComponent({
  name: "VxeAnchorLink",
  props: {
    content: [String, Number],
    title: [String, Number],
    href: String
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const $xeAnchor = inject("$xeAnchor", null);
    const $xeParentAnchorLink = inject("$xeAnchorLink", null);
    const xID = import_xe_utils5.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const linkConfig = reactive({
      id: xID,
      href: props.href,
      children: []
    });
    const refMaps = {
      refElem
    };
    const computeIsActive = computed(() => {
      const { href } = props;
      if ($xeAnchor) {
        return $xeAnchor.reactData.activeHref === href;
      }
      return null;
    });
    const computeMaps = {};
    const $xeAnchorLink = {
      xID,
      props,
      context,
      reactData,
      linkConfig,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clickEvent = (event) => {
      const { href } = props;
      if ($xeAnchor) {
        $xeAnchor.handleClickLink(event, href);
      }
    };
    watch(() => props.href, (val) => {
      linkConfig.href = val;
    });
    onMounted(() => {
      const elem = refElem.value;
      if ($xeAnchor && elem) {
        assembleAnchorLink($xeAnchor, elem, linkConfig, $xeParentAnchorLink);
      }
    });
    onUnmounted(() => {
      if ($xeAnchor) {
        destroyAnchorLink($xeAnchor, linkConfig);
      }
    });
    const renderVN = () => {
      const { href, content, title } = props;
      const defaultSlot = slots.default;
      const subSlot = slots.sub;
      const isActive = computeIsActive.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-anchor-link", {
          "is--active": isActive
        }]
      }, [
        h("a", {
          class: "vxe-anchor-link--item",
          href,
          title,
          onClick: clickEvent
        }, defaultSlot ? defaultSlot({}) : import_xe_utils5.default.toValueString(content)),
        subSlot ? h("div", {
          class: "vxe-anchor-link--sub-items"
        }, subSlot({})) : renderEmptyElement($xeAnchorLink)
      ]);
    };
    provide("$xeAnchorLink", $xeAnchorLink);
    $xeAnchorLink.renderVN = renderVN;
    return $xeAnchorLink;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/anchor/src/anchor.js
var anchor_default = defineVxeComponent({
  name: "VxeAnchor",
  props: {
    modelValue: String,
    options: Array,
    container: [String, Object, Function],
    showMarker: {
      type: Boolean,
      default: true
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils6.default.uniqueId();
    const refElem = ref();
    const refMarkerElem = ref();
    const reactData = reactive({
      activeHref: null,
      staticLinks: [],
      containerElem: null
    });
    const refMaps = {
      refElem
    };
    const computeAllHrefList = computed(() => {
      const list = [];
      import_xe_utils6.default.eachTree(reactData.staticLinks, (item) => {
        list.push(item.href || "");
      }, { children: "children" });
      return list;
    });
    const computeMaps = {};
    const $xeAnchor = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const anchorMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $anchor: $xeAnchor }, params));
      }
    };
    const getContainerElem = () => {
      const { container } = props;
      if (container) {
        if (import_xe_utils6.default.isElement(container)) {
          return container;
        }
        if (import_xe_utils6.default.isString(container)) {
          return document.querySelector(container);
        }
        if (import_xe_utils6.default.isFunction(container)) {
          return container({ $anchor: $xeAnchor });
        }
      }
      return null;
    };
    const emitEvent = (value) => {
      reactData.activeHref = value;
      emit("update:modelValue", value);
    };
    const handleContainerScrollEvent = () => {
      const allHrefList = computeAllHrefList.value;
      const { containerElem } = reactData;
      if (containerElem) {
        const wrapperElList = containerElem.querySelectorAll(allHrefList.map((href) => `${href}`).join(","));
        for (let i = 0; i < wrapperElList.length; i++) {
          const wrapperEl = wrapperElList[i];
          const wrapperRect = wrapperEl.getBoundingClientRect();
          if (wrapperRect.top > 0) {
            const href = wrapperEl.id;
            reactData.activeHref = `#${href}`;
            break;
          }
        }
      }
    };
    const removeContainerElemScroll = () => {
      const { containerElem } = reactData;
      if (containerElem) {
        containerElem.removeEventListener("scroll", handleContainerScrollEvent);
      }
    };
    const updateContainerElem = () => {
      const containerElem = getContainerElem();
      reactData.containerElem = containerElem;
      if (containerElem) {
        containerElem.addEventListener("scroll", handleContainerScrollEvent, {
          passive: false
        });
      }
    };
    const updateMarkerPos = () => {
      nextTick(() => {
        const { activeHref } = reactData;
        const elem = refElem.value;
        const markerEl = refMarkerElem.value;
        if (elem && markerEl) {
          if (activeHref) {
            const linkEl = elem.querySelector(`[href="${activeHref}"]`);
            if (linkEl) {
              const { top } = getOffsetPos(linkEl, elem);
              markerEl.style.top = `${top}px`;
            }
          }
        }
      });
    };
    const anchorPrivateMethods = {
      handleClickLink(evnt, href) {
        evnt.preventDefault();
        const targetEl = document.getElementById(`${href}`.replace("#", ""));
        if (targetEl) {
          targetEl.scrollIntoView({
            behavior: "smooth"
          });
        }
        emitEvent(href);
        anchorMethods.dispatchEvent("click", { href }, evnt);
      }
    };
    Object.assign($xeAnchor, anchorMethods, anchorPrivateMethods);
    const renderSubItems = (options) => {
      const itemVNs = [];
      if (options) {
        options.forEach((item) => {
          const subItems = item.children;
          if (subItems && subItems.length) {
            itemVNs.push(h(anchor_link_default, {
              content: item.content,
              title: item.title,
              href: item.href
            }, {
              sub: () => renderSubItems(subItems)
            }));
          } else {
            itemVNs.push(h(anchor_link_default, {
              content: item.content,
              title: item.title,
              href: item.href
            }));
          }
        });
      }
      return itemVNs;
    };
    const renderVN = () => {
      const { options, showMarker } = props;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-anchor", {
          "is--marker": showMarker
        }]
      }, [
        h("div", {
          class: "vxe-anchor--list"
        }, defaultSlot ? defaultSlot({}) : renderSubItems(options)),
        showMarker ? h("div", {
          ref: refMarkerElem,
          class: "vxe-anchor--marker"
        }) : renderEmptyElement($xeAnchor)
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.activeHref = val;
    });
    watch(() => reactData.activeHref, () => {
      updateMarkerPos();
    });
    watch(() => props.container, () => {
      removeContainerElemScroll();
      updateContainerElem();
    });
    onMounted(() => {
      nextTick(() => {
        updateContainerElem();
      });
    });
    onBeforeUnmount(() => {
      removeContainerElemScroll();
    });
    provide("$xeAnchor", $xeAnchor);
    $xeAnchor.renderVN = renderVN;
    return $xeAnchor;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/anchor/index.js
var VxeAnchor = Object.assign({}, anchor_default, {
  install(app) {
    app.component(anchor_default.name, anchor_default);
  }
});
dynamicApp.use(VxeAnchor);
VxeUI.component(anchor_default);
var Anchor = VxeAnchor;
var anchor_default2 = VxeAnchor;

// node_modules/vxe-pc-ui/es/anchor-link/index.js
var VxeAnchorLink = Object.assign({}, anchor_link_default, {
  install(app) {
    app.component(anchor_link_default.name, anchor_link_default);
  }
});
dynamicApp.use(VxeAnchorLink);
VxeUI.component(anchor_link_default);
var AnchorLink = VxeAnchorLink;
var anchor_link_default2 = VxeAnchorLink;

// node_modules/vxe-pc-ui/es/avatar/src/avatar.js
var import_xe_utils7 = __toESM(require_xe_utils());
var avatar_default = defineVxeComponent({
  name: "VxeAvatar",
  props: {
    count: [String, Number],
    dot: Boolean,
    content: [String, Number],
    icon: String,
    src: String,
    width: [String, Number],
    height: [String, Number],
    circle: {
      type: Boolean,
      default: () => getConfig().avatar.circle
    },
    status: {
      type: String,
      default: () => getConfig().avatar.status
    },
    size: {
      type: String,
      default: () => getConfig().avatar.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils7.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeAvatarStyle = computed(() => {
      const { width, height } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeCountNum = computed(() => {
      const { count } = props;
      return count ? import_xe_utils7.default.toNumber(count) : 0;
    });
    const computeMaps = {};
    const $xeAvatar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $avatar: $xeAvatar }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeAvatar, collapsePaneMethods, collapsePanePrivateMethods);
    const renderContent = () => {
      const { icon, content, src } = props;
      if (icon) {
        return h("span", {
          class: "vxe-avatar--icon"
        }, [
          h("i", {
            class: icon
          })
        ]);
      }
      if (content) {
        return h("span", {
          class: "vxe-avatar--content"
        }, `${content}`);
      }
      if (src) {
        return h("img", {
          class: "vxe-avatar--img",
          src
        });
      }
      return renderEmptyElement($xeAvatar);
    };
    const renderVN = () => {
      const { circle, dot, status } = props;
      const vSize = computeSize.value;
      const countNum = computeCountNum.value;
      const avatarStyle = computeAvatarStyle.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-avatar", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--circle": circle,
          "is--dot": dot
        }],
        style: avatarStyle
      }, [
        renderContent(),
        countNum ? h("span", {
          class: "vxe-avatar--count"
        }, countNum > 99 ? "99+" : `${countNum}`) : renderEmptyElement($xeAvatar)
      ]);
    };
    $xeAvatar.renderVN = renderVN;
    return $xeAvatar;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/avatar/index.js
var VxeAvatar = Object.assign({}, avatar_default, {
  install(app) {
    app.component(avatar_default.name, avatar_default);
  }
});
dynamicApp.use(VxeAvatar);
VxeUI.component(avatar_default);
var Avatar = VxeAvatar;
var avatar_default2 = VxeAvatar;

// node_modules/vxe-pc-ui/es/badge/src/badge.js
var import_xe_utils8 = __toESM(require_xe_utils());
var badge_default = defineVxeComponent({
  name: "VxeBadge",
  props: {
    count: [String, Number],
    dot: Boolean,
    content: [String, Number],
    size: {
      type: String,
      default: () => getConfig().badge.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils8.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeCountNum = computed(() => {
      const { count } = props;
      return count ? import_xe_utils8.default.toNumber(count) : 0;
    });
    const computeMaps = {};
    const $xeBadge = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $badge: $xeBadge }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeBadge, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { dot, content } = props;
      const vSize = computeSize.value;
      const countNum = computeCountNum.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-badge", {
          [`size--${vSize}`]: vSize,
          "is--dot": dot
        }]
      }, [
        defaultSlot || content ? h("div", {
          class: "vxe-badge--content"
        }, defaultSlot ? defaultSlot({}) : `${content || ""}`) : [],
        countNum ? h("span", {
          class: "vxe-badge--count"
        }, countNum > 99 ? "99+" : `${countNum}`) : renderEmptyElement($xeBadge)
      ]);
    };
    $xeBadge.renderVN = renderVN;
    return $xeBadge;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/badge/index.js
var VxeBadge = Object.assign({}, badge_default, {
  install(app) {
    app.component(badge_default.name, badge_default);
  }
});
dynamicApp.use(VxeBadge);
VxeUI.component(badge_default);
var Badge = VxeBadge;
var badge_default2 = VxeBadge;

// node_modules/vxe-pc-ui/es/breadcrumb/src/breadcrumb.js
var import_xe_utils10 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/breadcrumb/src/breadcrumb-item.js
var import_xe_utils9 = __toESM(require_xe_utils());
var breadcrumb_item_default = defineVxeComponent({
  name: "VxeBreadcrumbItem",
  props: {
    title: String,
    routerLink: Object
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils9.default.uniqueId();
    const refElem = ref();
    const $xeBreadcrumb = inject("$xeBreadcrumb", null);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeSeparator = computed(() => {
      if ($xeBreadcrumb) {
        return $xeBreadcrumb.props.separator;
      }
      return "";
    });
    const clickEvent = (evnt) => {
      if ($xeBreadcrumb) {
        const item = {
          title: props.title,
          routerLink: props.routerLink
        };
        $xeBreadcrumb.handleClickLink(evnt, item);
      }
    };
    const computeMaps = {};
    const $xeBreadcrumbItem = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const { title, routerLink } = props;
      const separator = computeSeparator.value;
      const defaultSlot = slots.default;
      return h("span", {
        ref: refElem,
        class: "vxe-breadcrumb-item",
        onClick: clickEvent
      }, [
        h("span", {
          class: "vxe-breadcrumb-item--content"
        }, [
          routerLink ? h(resolveComponent("router-link"), {
            class: "vxe-breadcrumb-item--content-link",
            title,
            to: routerLink
          }, {
            default() {
              return h("span", {
                class: "vxe-breadcrumb-item--content-text"
              }, defaultSlot ? defaultSlot({}) : `${title || ""}`);
            }
          }) : h("span", {
            class: "vxe-breadcrumb-item--content-text"
          }, defaultSlot ? defaultSlot({}) : `${title || ""}`)
        ]),
        separator ? h("span", {
          class: "vxe-breadcrumb-item--separator"
        }, `${separator}`) : renderEmptyElement($xeBreadcrumbItem)
      ]);
    };
    $xeBreadcrumbItem.renderVN = renderVN;
    return $xeBreadcrumbItem;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/breadcrumb/src/breadcrumb.js
var breadcrumb_default = defineVxeComponent({
  name: "VxeBreadcrumb",
  props: {
    separator: {
      type: String,
      default: () => getConfig().breadcrumb.separator
    },
    options: Array
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils10.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeBreadcrumb = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const breadcrumbMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $breadcrumb: $xeBreadcrumb }, params));
      }
    };
    const breadcrumbPrivateMethods = {
      handleClickLink(evnt, option) {
        breadcrumbMethods.dispatchEvent("click", { option }, evnt);
      }
    };
    Object.assign($xeBreadcrumb, breadcrumbMethods, breadcrumbPrivateMethods);
    const renderItems = () => {
      const { options } = props;
      if (options && options.length) {
        return options.map((item) => {
          return h(breadcrumb_item_default, {
            title: item.title,
            routerLink: item.routerLink
          });
        });
      }
      return [];
    };
    const renderVN = () => {
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: "vxe-breadcrumb"
      }, defaultSlot ? defaultSlot({}) : renderItems());
    };
    provide("$xeBreadcrumb", $xeBreadcrumb);
    $xeBreadcrumb.renderVN = renderVN;
    return $xeBreadcrumb;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/breadcrumb/index.js
var VxeBreadcrumb = Object.assign({}, breadcrumb_default, {
  install(app) {
    app.component(breadcrumb_default.name, breadcrumb_default);
  }
});
dynamicApp.use(VxeBreadcrumb);
VxeUI.component(breadcrumb_default);
var Breadcrumb = VxeBreadcrumb;
var breadcrumb_default2 = VxeBreadcrumb;

// node_modules/vxe-pc-ui/es/breadcrumb-item/index.js
var VxeBreadcrumbItem = Object.assign({}, breadcrumb_item_default, {
  install(app) {
    app.component(breadcrumb_item_default.name, breadcrumb_item_default);
  }
});
dynamicApp.use(VxeBreadcrumbItem);
VxeUI.component(breadcrumb_item_default);
var BreadcrumbItem = VxeBreadcrumbItem;
var breadcrumb_item_default2 = VxeBreadcrumbItem;

// node_modules/vxe-pc-ui/es/button/src/button.js
var import_xe_utils13 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/ui/src/utils.js
var import_xe_utils11 = __toESM(require_xe_utils());
function isEnableConf(conf) {
  return conf && conf.enabled !== false;
}
function nextZIndex() {
  return index_esm_default.getNext();
}
function getLastZIndex() {
  return index_esm_default.getCurrent();
}
function nextSubZIndex() {
  return index_esm_default.getSubNext();
}
function getSubLastZIndex() {
  return index_esm_default.getSubCurrent();
}
function getGlobalDefaultConfig(value, globalValue) {
  if (import_xe_utils11.default.eqNull(value)) {
    return globalValue;
  }
  return value;
}
function getFuncText(content, args) {
  if (import_xe_utils11.default.eqNull(content)) {
    return "";
  }
  const translate = getConfig().translate;
  return `${translate ? translate("" + content, args) : content}`;
}
function eqEmptyValue(cellValue) {
  return cellValue === null || cellValue === void 0 || cellValue === "";
}
function handleBooleanDefaultValue(value) {
  return import_xe_utils11.default.isBoolean(value) ? value : null;
}

// node_modules/vxe-pc-ui/es/tooltip/src/tooltip.js
var import_xe_utils12 = __toESM(require_xe_utils());
var tooltip_default = defineVxeComponent({
  name: "VxeTooltip",
  props: {
    modelValue: Boolean,
    size: {
      type: String,
      default: () => getConfig().tooltip.size || getConfig().size
    },
    selector: String,
    trigger: {
      type: String,
      default: () => getConfig().tooltip.trigger || "hover"
    },
    theme: {
      type: String,
      default: () => getConfig().tooltip.theme || "dark"
    },
    content: {
      type: [String, Number],
      default: null
    },
    useHTML: Boolean,
    zIndex: [String, Number],
    popupClassName: [String, Function],
    width: {
      type: [String, Number],
      default: () => getConfig().tooltip.Width
    },
    height: {
      type: [String, Number],
      default: () => getConfig().tooltip.height
    },
    minWidth: {
      type: [String, Number],
      default: () => getConfig().tooltip.minWidth
    },
    minHeight: {
      type: [String, Number],
      default: () => getConfig().tooltip.minHeight
    },
    maxWidth: {
      type: [String, Number],
      default: () => getConfig().tooltip.maxWidth
    },
    maxHeight: {
      type: [String, Number],
      default: () => getConfig().tooltip.maxHeight
    },
    isArrow: {
      type: Boolean,
      default: () => getConfig().tooltip.isArrow
    },
    enterable: {
      type: Boolean,
      default: () => getConfig().tooltip.enterable
    },
    enterDelay: {
      type: Number,
      default: () => getConfig().tooltip.enterDelay
    },
    leaveDelay: {
      type: Number,
      default: () => getConfig().tooltip.leaveDelay
    }
  },
  emits: [
    "update:modelValue"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils12.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      target: null,
      isUpdate: false,
      visible: false,
      tipContent: "",
      tipActive: false,
      tipTarget: null,
      tipZindex: 0,
      tipStore: {
        style: {},
        placement: "",
        arrowStyle: {}
      }
    });
    const internalData = {};
    const refElem = ref();
    const contentWrapperfElem = ref();
    const computeWrapperStyle = computed(() => {
      const { width, height, minHeight, minWidth, maxHeight, maxWidth } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (minWidth) {
        stys.minWidth = toCssUnit(minWidth);
      }
      if (minHeight) {
        stys.minHeight = toCssUnit(minHeight);
      }
      if (maxWidth) {
        stys.maxWidth = toCssUnit(maxWidth);
      }
      if (maxHeight) {
        stys.maxHeight = toCssUnit(maxHeight);
      }
      return stys;
    });
    const refMaps = {
      refElem
    };
    const $xeTooltip = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let tooltipMethods = {};
    const updateTipStyle = () => {
      const { tipTarget, tipStore } = reactData;
      if (tipTarget) {
        const { scrollTop, scrollLeft, visibleWidth } = getDomNode();
        const { top, left } = getAbsolutePos(tipTarget);
        const el = refElem.value;
        if (!el) {
          return;
        }
        const marginSize = 6;
        const offsetHeight = el.offsetHeight;
        const offsetWidth = el.offsetWidth;
        let tipLeft = left;
        let tipTop = top - offsetHeight - marginSize;
        tipLeft = Math.max(marginSize, left + Math.floor((tipTarget.offsetWidth - offsetWidth) / 2));
        if (tipLeft + offsetWidth + marginSize > scrollLeft + visibleWidth) {
          tipLeft = scrollLeft + visibleWidth - offsetWidth - marginSize;
        }
        if (top - offsetHeight < scrollTop + marginSize) {
          tipStore.placement = "bottom";
          tipTop = top + tipTarget.offsetHeight + marginSize;
        }
        tipStore.style.top = `${tipTop}px`;
        tipStore.style.left = `${tipLeft}px`;
        tipStore.arrowStyle.left = `${left - tipLeft + tipTarget.offsetWidth / 2}px`;
      }
    };
    const updateValue = (value) => {
      if (value !== reactData.visible) {
        reactData.visible = value;
        reactData.isUpdate = true;
        emit("update:modelValue", value);
      }
    };
    const updateZindex = () => {
      if (reactData.tipZindex < getLastZIndex()) {
        reactData.tipZindex = nextZIndex();
      }
    };
    const clickEvent = () => {
      if (reactData.visible) {
        tooltipMethods.close();
      } else {
        handleVisible(reactData.target || getSelectorEl(), props.content);
      }
    };
    const targetMouseenterEvent = () => {
      handleVisible(reactData.target || getSelectorEl(), props.content);
    };
    const targetMouseleaveEvent = () => {
      const { trigger, enterable, leaveDelay } = props;
      reactData.tipActive = false;
      if (enterable && trigger === "hover") {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      } else {
        tooltipMethods.close();
      }
    };
    const wrapperMouseenterEvent = () => {
      reactData.tipActive = true;
    };
    const wrapperMouseleaveEvent = () => {
      const { trigger, enterable, leaveDelay } = props;
      reactData.tipActive = false;
      if (enterable && trigger === "hover") {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      }
    };
    const showTip = () => {
      const { tipStore } = reactData;
      const el = refElem.value;
      if (el) {
        const parentNode = el.parentNode;
        if (!parentNode) {
          document.body.appendChild(el);
        }
      }
      updateValue(true);
      updateZindex();
      tipStore.placement = "top";
      tipStore.style = { width: "auto", left: 0, top: 0, zIndex: props.zIndex || reactData.tipZindex };
      tipStore.arrowStyle = { left: "50%" };
      return tooltipMethods.updatePlacement();
    };
    const handleDelayFn = () => {
      internalData.showDelayTip = import_xe_utils12.default.debounce(() => {
        if (reactData.tipActive) {
          showTip();
        }
      }, props.enterDelay, { leading: false, trailing: true });
    };
    const handleVisible = (target, content) => {
      const contentSlot = slots.content;
      if (!contentSlot && (content === "" || import_xe_utils12.default.eqNull(content))) {
        return nextTick();
      }
      if (target) {
        const { showDelayTip } = internalData;
        const { trigger, enterDelay } = props;
        reactData.tipActive = true;
        reactData.tipTarget = target;
        reactData.tipContent = content;
        if (enterDelay && trigger === "hover") {
          if (showDelayTip) {
            showDelayTip();
          }
        } else {
          return showTip();
        }
      }
      return nextTick();
    };
    const getSelectorEl = () => {
      const { selector } = props;
      if (selector) {
        if (import_xe_utils12.default.isElement(selector)) {
          return selector;
        }
        if (import_xe_utils12.default.isString(selector)) {
          return document.querySelector(selector);
        }
      }
      return null;
    };
    tooltipMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $tooltip: $xeTooltip }, params));
      },
      open(target, content) {
        return handleVisible(target || reactData.target || getSelectorEl(), content);
      },
      close() {
        reactData.tipTarget = null;
        reactData.tipActive = false;
        Object.assign(reactData.tipStore, {
          style: {},
          placement: "",
          arrowStyle: null
        });
        updateValue(false);
        return nextTick();
      },
      toVisible(target, content) {
        return handleVisible(target, content);
      },
      updatePlacement() {
        return nextTick().then(() => {
          const { tipTarget } = reactData;
          const el = refElem.value;
          if (tipTarget && el) {
            updateTipStyle();
            return nextTick().then(() => {
              updateTipStyle();
            });
          }
        });
      },
      isActived() {
        return reactData.tipActive;
      },
      setActived(active) {
        reactData.tipActive = !!active;
      }
    };
    const wheelEvent = (evnt) => {
      evnt.stopPropagation();
    };
    Object.assign($xeTooltip, tooltipMethods);
    const renderContent = () => {
      const { useHTML } = props;
      const { tipContent } = reactData;
      const wrapperStyle = computeWrapperStyle.value;
      const contentSlot = slots.content;
      const contVNs = [];
      if (contentSlot) {
        contVNs.push(h("div", {
          key: 1
        }, getSlotVNs2(contentSlot({}))));
      } else if (useHTML) {
        contVNs.push(h("div", {
          key: 2,
          innerHTML: tipContent
        }));
      } else {
        contVNs.push(h("span", {
          key: 3
        }, `${tipContent}`));
      }
      return h("div", {
        key: 3,
        ref: contentWrapperfElem,
        class: "vxe-tooltip--content",
        style: wrapperStyle
      }, contVNs);
    };
    const renderVN = () => {
      const { popupClassName, theme, isArrow, enterable } = props;
      const { tipActive, visible, tipStore } = reactData;
      const defaultSlot = slots.default;
      const vSize = computeSize.value;
      let ons;
      if (enterable) {
        ons = {
          onMouseenter: wrapperMouseenterEvent,
          onMouseleave: wrapperMouseleaveEvent
        };
      }
      return h("div", Object.assign({ ref: refElem, class: ["vxe-tooltip--wrapper", `theme--${theme}`, popupClassName ? import_xe_utils12.default.isFunction(popupClassName) ? popupClassName({ $tooltip: $xeTooltip }) : popupClassName : "", {
        [`size--${vSize}`]: vSize,
        [`placement--${tipStore.placement}`]: tipStore.placement,
        "is--enterable": enterable,
        "is--visible": visible,
        "is--arrow": isArrow,
        "is--active": tipActive
      }], style: tipStore.style }, ons), [
        renderContent(),
        h("div", {
          class: "vxe-tooltip--arrow",
          style: tipStore.arrowStyle
        }),
        ...defaultSlot ? getSlotVNs2(defaultSlot({})) : []
      ]);
    };
    watch(() => props.enterDelay, () => {
      handleDelayFn();
    });
    watch(() => props.content, (val) => {
      reactData.tipContent = val;
    });
    watch(() => props.modelValue, (val) => {
      if (!reactData.isUpdate) {
        if (val) {
          handleVisible(reactData.target || getSelectorEl(), props.content);
        } else {
          tooltipMethods.close();
        }
      }
      reactData.isUpdate = false;
    });
    onMounted(() => {
      const contentWrapperfEl = contentWrapperfElem.value;
      if (contentWrapperfEl) {
        contentWrapperfEl.addEventListener("wheel", wheelEvent, { passive: false });
      }
      nextTick(() => {
        const { trigger, content } = props;
        const wrapperElem = refElem.value;
        if (wrapperElem) {
          const parentNode = wrapperElem.parentNode;
          if (parentNode) {
            reactData.tipContent = content;
            reactData.tipZindex = nextZIndex();
            import_xe_utils12.default.arrayEach(wrapperElem.children, (elem, index) => {
              if (index > 1) {
                parentNode.insertBefore(elem, wrapperElem);
                if (!reactData.target) {
                  reactData.target = elem;
                }
              }
            });
            parentNode.removeChild(wrapperElem);
            const { target } = reactData;
            if (target) {
              if (trigger === "hover") {
                target.onmouseenter = targetMouseenterEvent;
                target.onmouseleave = targetMouseleaveEvent;
              } else if (trigger === "click") {
                target.onclick = clickEvent;
              }
            }
            if (props.modelValue) {
              handleVisible(target || getSelectorEl(), content);
            }
          }
        }
      });
    });
    onBeforeUnmount(() => {
      const { target } = reactData;
      const wrapperElem = refElem.value;
      if (target) {
        target.onmouseenter = null;
        target.onmouseleave = null;
        target.onclick = null;
      }
      const contentWrapperfEl = contentWrapperfElem.value;
      if (contentWrapperfEl) {
        contentWrapperfEl.removeEventListener("wheel", wheelEvent);
      }
      if (wrapperElem) {
        const parentNode = wrapperElem.parentNode;
        if (parentNode) {
          parentNode.removeChild(wrapperElem);
        }
      }
    });
    handleDelayFn();
    $xeTooltip.renderVN = renderVN;
    return $xeTooltip;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/button/src/button.js
var VxeButtonComponent = defineVxeComponent({
  name: "VxeButton",
  props: {
    /**
     * 按钮类型
     */
    type: String,
    mode: String,
    className: [String, Function],
    popupClassName: [String, Function],
    /**
     * 按钮尺寸
     */
    size: {
      type: String,
      default: () => getConfig().button.size || getConfig().size
    },
    zIndex: Number,
    /**
     * 用来标识这一项
     */
    name: [String, Number],
    routerLink: Object,
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    /**
     * 按钮内容
     */
    content: String,
    /**
     * 固定显示下拉面板的方向
     */
    placement: String,
    /**
     * 按钮状态
     */
    status: String,
    /**
     * 标题
     */
    title: String,
    /**
     * 按钮的前缀图标，属于 prefix-icon 的简写
     */
    icon: String,
    iconRender: Object,
    /**
     * 按钮的前缀图标
     */
    prefixIcon: String,
    prefixRender: Object,
    /**
     * 按钮的后缀图标
     */
    suffixIcon: String,
    suffixRender: Object,
    /**
     * 圆角边框
     */
    round: Boolean,
    /**
     * 圆角按钮
     */
    circle: Boolean,
    /**
     * 是否禁用
     */
    disabled: Boolean,
    /**
     * 是否加载中
     */
    loading: Boolean,
    trigger: {
      type: String,
      default: () => getConfig().button.trigger
    },
    align: String,
    prefixTooltip: Object,
    suffixTooltip: Object,
    options: Array,
    /**
     * 在下拉面板关闭时销毁内容
     */
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().button.destroyOnClose
    },
    /**
     * 是否将弹框容器插入于 body 内
     */
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "click",
    "mouseenter",
    "mouseleave",
    "dropdown-click",
    "dropdownClick"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const $xeButtonGroup = inject("$xeButtonGroup", null);
    const xID = import_xe_utils13.default.uniqueId();
    const { computeSize } = useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const reactData = reactive({
      initialized: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: ""
    });
    const internalData = {
      showTime: void 0,
      tooltipTimeout: void 0
    };
    const refElem = ref();
    const refButton = ref();
    const refBtnPanel = ref();
    const refMaps = {
      refElem
    };
    const $xeButton = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let buttonMethods = {};
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().button.transfer;
        if (import_xe_utils13.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeBtnDisabled = computed(() => {
      const { disabled } = props;
      const permissionInfo = computePermissionInfo.value;
      return disabled || permissionInfo.disabled;
    });
    const computeIsFormBtn = computed(() => {
      const { type } = props;
      if (type) {
        return ["submit", "reset", "button"].indexOf(type) > -1;
      }
      return false;
    });
    const computeBtnMode = computed(() => {
      const { type, mode } = props;
      if (mode === "text" || type === "text" || $xeButtonGroup && $xeButtonGroup.props.mode === "text") {
        return "text";
      }
      return "button";
    });
    const computeBtnStatus = computed(() => {
      const { status } = props;
      if (status) {
        return status;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.status;
      }
      return "";
    });
    const computeBtnAlign = computed(() => {
      const { align } = props;
      if (align) {
        return align;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.align;
      }
      return false;
    });
    const computeBtnRound = computed(() => {
      const { round } = props;
      if (round) {
        return round;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.round;
      }
      return false;
    });
    const computeBtnCircle = computed(() => {
      const { circle } = props;
      if (circle) {
        return circle;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.circle;
      }
      return false;
    });
    const computeDownBtnList = computed(() => {
      const { options } = props;
      if (options) {
        return options.filter((item) => {
          const { permissionCode } = item;
          return !permissionCode || permission.checkVisible(permissionCode);
        });
      }
      return [];
    });
    const computePrefixTipOpts = computed(() => {
      return Object.assign({}, getConfig().button.prefixTooltip, props.prefixTooltip);
    });
    const computeSuffixTipOpts = computed(() => {
      return Object.assign({}, getConfig().button.suffixTooltip, props.suffixTooltip);
    });
    const updateZindex = () => {
      const { zIndex } = props;
      if (zIndex) {
        reactData.panelIndex = zIndex;
      } else if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const { placement } = props;
      const { panelIndex } = reactData;
      const targetElem = refButton.value;
      const panelElem = refBtnPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return nextTick().then(handleStyle);
    };
    const clickEvent = (evnt) => {
      if ($xeButtonGroup) {
        $xeButtonGroup.handleClick({ name: props.name }, evnt);
      }
      dispatchEvent("click", { $event: evnt }, evnt);
    };
    const downBtnClickEvent = (params, option) => {
      const { $event } = params;
      hidePanel();
      dispatchEvent("dropdown-click", { name: option.name, option }, $event);
    };
    const mousedownDropdownEvent = (evnt) => {
      const isLeftBtn = evnt.button === 0;
      if (isLeftBtn) {
        evnt.stopPropagation();
      }
    };
    const clickDropdownEvent = (evnt) => {
      const dropdownElem = evnt.currentTarget;
      const panelElem = refBtnPanel.value;
      const { flag, targetElem } = getEventTargetNode(evnt, dropdownElem, "vxe-button");
      if (flag) {
        if (panelElem) {
          panelElem.dataset.active = "N";
        }
        reactData.visiblePanel = false;
        setTimeout(() => {
          if (!panelElem || panelElem.dataset.active !== "Y") {
            reactData.isAniVisible = false;
          }
        }, 350);
        dispatchEvent("dropdown-click", { name: targetElem.getAttribute("name"), option: null }, evnt);
      }
    };
    const mouseenterDropdownEvent = () => {
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = "Y";
        reactData.isAniVisible = true;
        setTimeout(() => {
          if (panelElem.dataset.active === "Y") {
            reactData.visiblePanel = true;
            updateZindex();
            updatePlacement();
            setTimeout(() => {
              if (reactData.visiblePanel) {
                updatePlacement();
              }
            }, 50);
          }
        }, 20);
      }
    };
    const mouseenterTargetEvent = (evnt) => {
      const { loading: loading2 } = props;
      const btnDisabled = computeBtnDisabled.value;
      if (!(btnDisabled || loading2)) {
        openPanel();
        mouseenterEvent(evnt);
      }
    };
    const mouseleaveTargetEvent = (evnt) => {
      hidePanel();
      mouseleaveEvent(evnt);
    };
    const mouseenterEvent = (evnt) => {
      dispatchEvent("mouseenter", {}, evnt);
    };
    const mouseleaveEvent = (evnt) => {
      dispatchEvent("mouseleave", {}, evnt);
    };
    const clickTargetEvent = (evnt) => {
      const { loading: loading2, trigger } = props;
      const btnDisabled = computeBtnDisabled.value;
      if (!(btnDisabled || loading2)) {
        if (trigger === "click") {
          if (reactData.visiblePanel) {
            hidePanel();
          } else {
            openPanel();
          }
        }
        clickEvent(evnt);
      }
    };
    const openPanel = () => {
      const { trigger } = props;
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = "Y";
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        internalData.showTime = setTimeout(() => {
          if (panelElem.dataset.active === "Y") {
            mouseenterDropdownEvent();
          } else {
            reactData.isAniVisible = false;
          }
        }, trigger === "click" ? 50 : 250);
      }
      return nextTick();
    };
    const hidePanel = () => {
      const panelElem = refBtnPanel.value;
      clearTimeout(internalData.showTime);
      if (panelElem) {
        panelElem.dataset.active = "N";
        setTimeout(() => {
          if (panelElem.dataset.active !== "Y") {
            reactData.visiblePanel = false;
            setTimeout(() => {
              if (panelElem.dataset.active !== "Y") {
                reactData.isAniVisible = false;
              }
            }, 350);
          }
        }, 100);
      } else {
        reactData.isAniVisible = false;
        reactData.visiblePanel = false;
      }
      return nextTick();
    };
    const mouseleaveDropdownEvent = () => {
      hidePanel();
    };
    const renderTooltipIcon = (tipOpts, type) => {
      return h(tooltip_default, {
        useHTML: tipOpts.useHTML,
        content: tipOpts.content,
        enterable: tipOpts.enterable,
        theme: tipOpts.theme
      }, {
        default() {
          return h("span", {
            class: `vxe-button--item vxe-button--tooltip-${type}-icon`
          }, [
            h("i", {
              class: tipOpts.icon || getIcon().BUTTON_TOOLTIP_ICON
            })
          ]);
        }
      });
    };
    const renderContent = () => {
      const { content, suffixIcon, loading: loading2, prefixTooltip, suffixTooltip, suffixRender } = props;
      const prefixIcon = props.prefixIcon || props.icon;
      const prefixRender = props.prefixRender || props.iconRender;
      const prefixTipOpts = computePrefixTipOpts.value;
      const suffixTipOpts = computeSuffixTipOpts.value;
      const prefixIconSlot = slots.prefix || slots.icon;
      const suffixIconSlot = slots.suffix;
      const defaultSlot = slots.default;
      const contVNs = [];
      if (prefixTooltip) {
        contVNs.push(renderTooltipIcon(prefixTipOpts, "prefix"));
      }
      if (loading2) {
        contVNs.push(h("i", {
          class: ["vxe-button--item vxe-button--loading-icon", getIcon().BUTTON_LOADING]
        }));
      } else if (prefixIconSlot) {
        contVNs.push(h("span", {
          class: "vxe-button--item vxe-button--custom-prefix-icon"
        }, prefixIconSlot({})));
      } else if (prefixRender) {
        const compConf = renderer.get(prefixRender.name);
        const pIconMethod = compConf ? compConf.renderButtonPrefix : null;
        contVNs.push(h("span", {
          class: ["vxe-button--item vxe-button--custom-prefix-icon"]
        }, pIconMethod ? getSlotVNs2(pIconMethod(prefixRender, { $button: $xeButton })) : []));
      } else if (prefixIcon) {
        contVNs.push(h("i", {
          class: ["vxe-button--item vxe-button--prefix-icon", prefixIcon]
        }));
      }
      if (defaultSlot) {
        contVNs.push(h("span", {
          class: "vxe-button--item vxe-button--content"
        }, defaultSlot({})));
      } else if (content) {
        contVNs.push(h("span", {
          class: "vxe-button--item vxe-button--content"
        }, getFuncText(content)));
      }
      if (suffixIconSlot) {
        contVNs.push(h("span", {
          class: "vxe-button--item vxe-button--custom-suffix-icon"
        }, suffixIconSlot({})));
      } else if (suffixRender) {
        const compConf = renderer.get(suffixRender.name);
        const sIconMethod = compConf ? compConf.renderButtonSuffix : null;
        contVNs.push(h("span", {
          class: ["vxe-button--item vxe-button--custom-suffix-icon"]
        }, sIconMethod ? getSlotVNs2(sIconMethod(suffixRender, { $button: $xeButton })) : []));
      } else if (suffixIcon) {
        contVNs.push(h("i", {
          class: ["vxe-button--item vxe-button--suffix-icon", suffixIcon]
        }));
      }
      if (suffixTooltip) {
        contVNs.push(renderTooltipIcon(suffixTipOpts, "suffix"));
      }
      return contVNs;
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $button: $xeButton }, params));
    };
    buttonMethods = {
      dispatchEvent,
      openPanel,
      closePanel: hidePanel,
      focus() {
        const btnElem = refButton.value;
        if (btnElem) {
          btnElem.focus();
        }
        return nextTick();
      },
      blur() {
        const btnElem = refButton.value;
        if (btnElem) {
          btnElem.blur();
        }
        return nextTick();
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const panelElem = refBtnPanel.value;
      if (reactData.visiblePanel && !getEventTargetNode(evnt, panelElem).flag) {
        hidePanel();
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const btnDisabled = computeBtnDisabled.value;
      const { visiblePanel } = reactData;
      if (!btnDisabled) {
        const el = refElem.value;
        const panelElem = refBtnPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hidePanel();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const { visiblePanel } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    Object.assign($xeButton, buttonMethods);
    const renderVN = () => {
      const { className, popupClassName, trigger, title, routerLink, type, destroyOnClose, name, loading: loading2 } = props;
      const { initialized, isAniVisible, visiblePanel } = reactData;
      const isFormBtn = computeIsFormBtn.value;
      const btnMode = computeBtnMode.value;
      const btnStatus = computeBtnStatus.value;
      const btnRound = computeBtnRound.value;
      const btnAlign = computeBtnAlign.value;
      const btnCircle = computeBtnCircle.value;
      const btnTransfer = computeBtnTransfer.value;
      const btnDisabled = computeBtnDisabled.value;
      const permissionInfo = computePermissionInfo.value;
      const downBtnList = computeDownBtnList.value;
      const vSize = computeSize.value;
      const dropdownsSlot = slots.dropdowns;
      if (!permissionInfo.visible) {
        return renderEmptyElement($xeButton);
      }
      if (dropdownsSlot || downBtnList.length) {
        const btnOns = {};
        const panelOns = {};
        if (trigger === "hover") {
          btnOns.onMouseenter = mouseenterTargetEvent;
          btnOns.onMouseleave = mouseleaveTargetEvent;
          panelOns.onMouseenter = mouseenterDropdownEvent;
          panelOns.onMouseleave = mouseleaveDropdownEvent;
        }
        return h("div", {
          ref: refElem,
          class: ["vxe-button--dropdown", className ? import_xe_utils13.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
            [`size--${vSize}`]: vSize,
            "is--active": visiblePanel
          }]
        }, [
          routerLink ? h(resolveComponent("router-link"), Object.assign({
            ref: refButton,
            class: ["vxe-button", "vxe-button--link", `type--${btnMode}`, btnAlign ? `align--${btnAlign}` : "", className ? import_xe_utils13.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
              [`size--${vSize}`]: vSize,
              [`theme--${btnStatus}`]: btnStatus,
              "is--round": btnRound,
              "is--circle": btnCircle,
              "is--disabled": btnDisabled || loading2,
              "is--loading": loading2
            }],
            title,
            name,
            type: isFormBtn ? type : "button",
            disabled: btnDisabled || loading2,
            to: routerLink,
            onClick: clickTargetEvent
          }, btnOns), {
            default() {
              return renderContent().concat([
                h("i", {
                  class: `vxe-button--dropdown-arrow ${getIcon().BUTTON_DROPDOWN}`
                })
              ]);
            }
          }) : h("button", Object.assign({
            ref: refButton,
            class: ["vxe-button", `type--${btnMode}`, btnAlign ? `align--${btnAlign}` : "", className ? import_xe_utils13.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
              [`size--${vSize}`]: vSize,
              [`theme--${btnStatus}`]: btnStatus,
              "is--round": btnRound,
              "is--circle": btnCircle,
              "is--disabled": btnDisabled || loading2,
              "is--loading": loading2
            }],
            title,
            name,
            type: isFormBtn ? type : "button",
            disabled: btnDisabled || loading2,
            onClick: clickTargetEvent
          }, btnOns), renderContent().concat([
            h("i", {
              class: `vxe-button--dropdown-arrow ${getIcon().BUTTON_DROPDOWN}`
            })
          ])),
          h(Teleport, {
            to: "body",
            disabled: btnTransfer ? !initialized : true
          }, [
            h("div", Object.assign({ ref: refBtnPanel, class: ["vxe-button--dropdown-panel", popupClassName ? import_xe_utils13.default.isFunction(popupClassName) ? popupClassName({ $button: $xeButton }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }], placement: reactData.panelPlacement, style: reactData.panelStyle }, panelOns), initialized && (visiblePanel || isAniVisible) ? [
              dropdownsSlot ? h("div", {
                class: "vxe-button--dropdown-wrapper",
                onMousedown: mousedownDropdownEvent,
                onClick: clickDropdownEvent
              }, initialized && (destroyOnClose ? visiblePanel || isAniVisible : true) ? dropdownsSlot({}) : []) : h("div", {
                class: "vxe-button--dropdown-wrapper"
              }, initialized && (destroyOnClose ? visiblePanel || isAniVisible : true) ? downBtnList.map((option, i) => {
                return h(VxeButtonComponent, {
                  key: i,
                  type: option.type,
                  mode: option.mode || btnMode,
                  className: option.className,
                  name: option.name,
                  routerLink: option.routerLink,
                  permissionCode: option.permissionCode,
                  title: option.title,
                  content: option.content,
                  status: option.status,
                  icon: option.icon,
                  round: import_xe_utils13.default.isBoolean(option.round) ? option.round : btnMode === "text" ? false : btnRound,
                  circle: import_xe_utils13.default.isBoolean(option.circle) ? option.circle : btnMode === "text" ? false : btnCircle,
                  disabled: option.disabled,
                  loading: option.loading,
                  align: option.align,
                  onClick(params) {
                    downBtnClickEvent(params, option);
                  }
                });
              }) : [])
            ] : [])
          ])
        ]);
      }
      if (routerLink) {
        return h(resolveComponent("router-link"), {
          ref: refButton,
          class: ["vxe-button", "vxe-button--link", `type--${btnMode}`, btnAlign ? `align--${btnAlign}` : "", className ? import_xe_utils13.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
            [`size--${vSize}`]: vSize,
            [`theme--${btnStatus}`]: btnStatus,
            "is--round": btnRound,
            "is--circle": btnCircle,
            "is--disabled": btnDisabled || loading2,
            "is--loading": loading2
          }],
          title,
          name,
          type: isFormBtn ? type : "button",
          disabled: btnDisabled || loading2,
          to: routerLink,
          onClick: clickEvent,
          onMouseenter: mouseenterEvent,
          onMouseleave: mouseleaveEvent
        }, {
          default() {
            return renderContent();
          }
        });
      }
      return h("button", {
        ref: refButton,
        class: ["vxe-button", `type--${btnMode}`, btnAlign ? `align--${btnAlign}` : "", className ? import_xe_utils13.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
          [`size--${vSize}`]: vSize,
          [`theme--${btnStatus}`]: btnStatus,
          "is--round": btnRound,
          "is--circle": btnCircle,
          "is--disabled": btnDisabled || loading2,
          "is--loading": loading2
        }],
        title,
        name,
        type: isFormBtn ? type : "button",
        disabled: btnDisabled || loading2,
        onClick: clickEvent,
        onMouseenter: mouseenterEvent,
        onMouseleave: mouseleaveEvent
      }, renderContent());
    };
    $xeButton.renderVN = renderVN;
    onMounted(() => {
      if (props.type === "text") {
        warnLog("vxe.error.delProp", ["[button] type=text", "mode=text"]);
      }
      globalEvents.on($xeButton, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeButton, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeButton, "resize", handleGlobalResizeEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeButton, "mousewheel");
      globalEvents.off($xeButton, "mousedown");
      globalEvents.off($xeButton, "resize");
    });
    return $xeButton;
  },
  render() {
    return this.renderVN();
  }
});
var button_default = VxeButtonComponent;

// node_modules/vxe-pc-ui/es/button/index.js
var VxeButton = Object.assign({}, button_default, {
  install(app) {
    app.component(button_default.name, button_default);
  }
});
dynamicApp.use(VxeButton);
VxeUI.component(button_default);
var Button = VxeButton;
var button_default2 = VxeButton;

// node_modules/vxe-pc-ui/es/button/src/button-group.js
var import_xe_utils14 = __toESM(require_xe_utils());
var button_group_default = defineVxeComponent({
  name: "VxeButtonGroup",
  props: {
    options: Array,
    mode: String,
    status: String,
    round: Boolean,
    vertical: Boolean,
    circle: Boolean,
    align: String,
    className: [String, Function],
    disabled: Boolean,
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => getConfig().buttonGroup.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils14.default.uniqueId();
    const reactData = reactive({});
    const computeMaps = {};
    const $xeButtonGroup = {
      xID,
      props,
      context,
      reactData,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const buttonGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $buttonGroup: $xeButtonGroup }, params));
      }
    };
    const buttonGroupPrivateMethods = {
      handleClick(params, evnt) {
        const { options } = props;
        const { name } = params;
        const option = options ? options.find((item) => item.name === name) : null;
        buttonGroupMethods.dispatchEvent("click", Object.assign(Object.assign({}, params), { option }), evnt);
      }
    };
    Object.assign($xeButtonGroup, buttonGroupMethods, buttonGroupPrivateMethods);
    const renderVN = () => {
      const { className, options, vertical } = props;
      const permissionInfo = computePermissionInfo.value;
      const defaultSlot = slots.default;
      if (!permissionInfo.visible) {
        return renderEmptyElement($xeButtonGroup);
      }
      return h("div", {
        class: ["vxe-button-group", className ? import_xe_utils14.default.isFunction(className) ? className({ $buttonGroup: $xeButtonGroup }) : className : "", {
          "is--vertical": vertical
        }]
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item, index) => {
        return h(button_default, Object.assign({ key: index }, item));
      }) : []);
    };
    $xeButtonGroup.renderVN = renderVN;
    provide("$xeButtonGroup", $xeButtonGroup);
    return $xeButtonGroup;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/button-group/index.js
var VxeButtonGroup = Object.assign({}, button_group_default, {
  install(app) {
    app.component(button_group_default.name, button_group_default);
  }
});
dynamicApp.use(VxeButtonGroup);
VxeUI.component(button_group_default);
var ButtonGroup = VxeButtonGroup;
var button_group_default2 = VxeButtonGroup;

// node_modules/vxe-pc-ui/es/date-panel/src/util.js
var import_xe_utils15 = __toESM(require_xe_utils());
function hasTimestampValueType(valueFormat) {
  return valueFormat === "timestamp";
}
function hasDateValueType(valueFormat) {
  return valueFormat === "date";
}
function handleValueFormat(type, valueFormat) {
  if (valueFormat) {
    if (!(hasDateValueType(valueFormat) || hasTimestampValueType(valueFormat))) {
      return valueFormat;
    }
  }
  if (type === "time") {
    return "HH:mm:ss";
  }
  if (type === "datetime") {
    return "yyyy-MM-dd HH:mm:ss";
  }
  return "yyyy-MM-dd";
}
function toStringTimeDate(str) {
  const rest = new Date(2e3, 0, 1);
  if (str) {
    let h2 = 0;
    let m = 0;
    let s = 0;
    if (import_xe_utils15.default.isNumber(str) || /^[0-9]{11,15}$/.test(`${str}`)) {
      str = new Date(Number(str));
    }
    if (import_xe_utils15.default.isDate(str)) {
      h2 = str.getHours();
      m = str.getMinutes();
      s = str.getSeconds();
    } else {
      str = import_xe_utils15.default.toValueString(str);
      const parses = str.match(/^(\d{1,2})(:(\d{1,2}))?(:(\d{1,2}))?/);
      if (parses) {
        h2 = import_xe_utils15.default.toNumber(parses[1]);
        m = import_xe_utils15.default.toNumber(parses[3]);
        s = import_xe_utils15.default.toNumber(parses[5]);
      }
    }
    rest.setHours(h2);
    rest.setMinutes(m);
    rest.setSeconds(s);
    return rest;
  }
  return rest;
}
function getDateQuarter(date) {
  const month = date.getMonth();
  if (month < 3) {
    return 1;
  } else if (month < 6) {
    return 2;
  } else if (month < 9) {
    return 3;
  }
  return 4;
}
var parseDateValue = (val, type, options) => {
  const { valueFormat } = options;
  if (val) {
    if (type === "time") {
      return toStringTimeDate(val);
    }
    if (import_xe_utils15.default.isNumber(val) || /^[0-9]{10,15}$/.test(`${val}`)) {
      return new Date(Number(val));
    }
    if (import_xe_utils15.default.isString(val)) {
      return import_xe_utils15.default.toStringDate(import_xe_utils15.default.last(val.split(",")), valueFormat);
    }
    return import_xe_utils15.default.toStringDate(val, valueFormat);
  }
  return null;
};
var parseDateString = (val, type, options) => {
  const dValue = parseDateValue(val, type, options);
  return dValue ? import_xe_utils15.default.toDateString(dValue, options.valueFormat) : "";
};
function parseDateObj(val, type, options) {
  const { labelFormat, firstDay } = options;
  let dValue = null;
  let dLabel = "";
  if (val) {
    dValue = parseDateValue(val, type, options);
  }
  if (import_xe_utils15.default.isValidDate(dValue)) {
    dLabel = import_xe_utils15.default.toDateString(dValue, labelFormat, { firstDay });
    if (labelFormat && type === "week") {
      const weekNum = import_xe_utils15.default.getYearWeek(dValue, firstDay);
      const weekDate = import_xe_utils15.default.getWhatWeek(dValue, 0, weekNum === 1 ? (6 + firstDay) % 7 : firstDay, firstDay);
      const weekFullYear = weekDate.getFullYear();
      if (weekFullYear !== dValue.getFullYear()) {
        const yyIndex = labelFormat.indexOf("yyyy");
        if (yyIndex > -1) {
          const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
          if (yyNum && !isNaN(yyNum)) {
            dLabel = dLabel.replace(`${yyNum}`, `${weekFullYear}`);
          }
        }
      }
    }
  } else {
    dValue = null;
  }
  return { label: dLabel, value: dValue };
}
function getDateByCode(code, val, type, options) {
  const { valueFormat, firstDay } = options;
  let dValue = null;
  const value = (code === "prev" || code === "next" ? /* @__PURE__ */ new Date() : val ? parseDateValue(val, type, options) : null) || /* @__PURE__ */ new Date();
  switch (code) {
    case "prev":
    case "next":
    case "minus":
    case "plus": {
      const offsetNum = code === "plus" || code === "next" ? 1 : -1;
      switch (type) {
        case "date":
        case "datetime":
          dValue = import_xe_utils15.default.getWhatDay(value, offsetNum);
          break;
        case "week":
          dValue = import_xe_utils15.default.getWhatWeek(value, offsetNum, firstDay, firstDay);
          break;
        case "month":
          dValue = import_xe_utils15.default.getWhatMonth(value, offsetNum);
          break;
        case "quarter":
          dValue = import_xe_utils15.default.getWhatQuarter(value, offsetNum);
          break;
        case "year":
          dValue = import_xe_utils15.default.getWhatYear(value, offsetNum);
          break;
      }
      break;
    }
    default:
      dValue = /* @__PURE__ */ new Date();
      break;
  }
  return {
    value: dValue ? import_xe_utils15.default.toDateString(dValue, valueFormat) : ""
  };
}
var rangeDateOffsetNumMaps = {
  last180: -180,
  last90: -90,
  last60: -60,
  last30: -30,
  last7: -7,
  last3: -3,
  last1: -1
};
function getRangeDateOffsetNum(code) {
  return rangeDateOffsetNumMaps[code] || 0;
}
function getRangeDateByCode(code, val, type, options) {
  const { valueFormat, firstDay } = options;
  if (import_xe_utils15.default.isArray(val)) {
    val = val.join("");
  }
  const value = (val ? parseDateValue(val, type, options) : null) || /* @__PURE__ */ new Date();
  let sValue = null;
  const eValue = value;
  switch (code) {
    case "last1":
    case "last3":
    case "last7":
    case "last30":
    case "last60":
    case "last90":
    case "last180": {
      const offsetNum = getRangeDateOffsetNum(code);
      switch (type) {
        case "date":
        case "datetime":
          sValue = import_xe_utils15.default.getWhatDay(value, offsetNum);
          break;
        case "week":
          sValue = import_xe_utils15.default.getWhatWeek(value, offsetNum, firstDay, firstDay);
          break;
        case "month":
          sValue = import_xe_utils15.default.getWhatMonth(value, offsetNum);
          break;
        case "quarter":
          sValue = import_xe_utils15.default.getWhatQuarter(value, offsetNum);
          break;
        case "year":
          sValue = import_xe_utils15.default.getWhatYear(value, offsetNum);
          break;
      }
      break;
    }
    default:
      sValue = /* @__PURE__ */ new Date();
      break;
  }
  const startValue = sValue ? import_xe_utils15.default.toDateString(sValue, valueFormat) : "";
  const endValue = eValue ? import_xe_utils15.default.toDateString(eValue, valueFormat) : "";
  return {
    startValue,
    endValue
  };
}

// node_modules/vxe-pc-ui/es/calendar/src/calendar.js
var import_xe_utils16 = __toESM(require_xe_utils());
var calendar_default = defineVxeComponent({
  name: "VxeCalendar",
  props: {
    modelValue: [String, Number, Date],
    type: {
      type: String,
      default: "date"
    },
    className: String,
    size: {
      type: String,
      default: () => getConfig().calendar.size || getConfig().size
    },
    multiple: Boolean,
    width: [String, Number],
    height: [String, Number],
    // date、week、month、quarter、year
    minDate: {
      type: [String, Number, Date],
      default: () => getConfig().calendar.minDate
    },
    maxDate: {
      type: [String, Number, Date],
      default: () => getConfig().calendar.maxDate
    },
    startDay: {
      type: [String, Number],
      default: () => getConfig().calendar.startDay
    },
    labelFormat: String,
    valueFormat: String,
    festivalMethod: {
      type: Function,
      default: () => getConfig().calendar.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().calendar.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().calendar.selectDay
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "click",
    "date-prev",
    "date-today",
    "date-next",
    "view-change"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils16.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      selectValue: props.modelValue,
      inputValue: props.modelValue,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    });
    const internalData = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8
    };
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xeCalendar = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeCalendarStyle = computed(() => {
      const { height, width } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeIsDisabled = computed(() => {
      return false;
    });
    const computeIsCalendarType = computed(() => {
      return ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeDateStartTime = computed(() => {
      return props.minDate ? import_xe_utils16.default.toStringDate(props.minDate) : null;
    });
    const computeDateEndTime = computed(() => {
      return props.maxDate ? import_xe_utils16.default.toStringDate(props.maxDate) : null;
    });
    const computeSupportMultiples = computed(() => {
      return ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeDateListValue = computed(() => {
      const { multiple } = props;
      const { selectValue } = reactData;
      const isCalendarType = computeIsCalendarType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && selectValue && isCalendarType) {
        return import_xe_utils16.default.toValueString(selectValue).split(",").map((item) => {
          const date = parseDate(item, dateValueFormat);
          if (import_xe_utils16.default.isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    const computeDateMultipleValue = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map((date) => import_xe_utils16.default.toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map((date) => import_xe_utils16.default.toDateString(date, dateLabelFormat)).join(", ");
    });
    const computeDateValueFormat = computed(() => {
      const { valueFormat } = props;
      if (valueFormat) {
        return valueFormat;
      }
      return "yyyy-MM-dd";
    });
    const computeDateValue = computed(() => {
      const { selectValue } = reactData;
      const isCalendarType = computeIsCalendarType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (selectValue && isCalendarType) {
        const date = parseDate(selectValue, dateValueFormat);
        if (import_xe_utils16.default.isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = computed(() => {
      const dateStartTime = computeDateStartTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = computed(() => {
      const dateEndTime = computeDateEndTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateHMSTime = computed(() => {
      const dateValue = computeDateValue.value;
      return dateValue ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1e3 : 0;
    });
    const computeDateLabelFormat = computed(() => {
      const { labelFormat } = props;
      const isCalendarType = computeIsCalendarType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (isCalendarType) {
        return labelFormat || dateValueFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return null;
    });
    const computeYearList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { yearSize } = internalData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index = -4; index < yearSize + 4; index++) {
          const date = import_xe_utils16.default.getWhatYear(startYearDate, index, "first");
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelObj = computed(() => {
      const isCalendarType = computeIsCalendarType.value;
      let y = "";
      let m = "";
      if (isCalendarType) {
        const { datePanelType, selectMonth } = reactData;
        const yearList = computeYearList.value;
        let year = "";
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === "quarter" || datePanelType === "month") {
          y = `${year}`;
        } else if (datePanelType === "year") {
          y = yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : "";
        } else {
          y = `${year}`;
          m = month ? getI18n(`vxe.input.date.m${month}`) : "-";
        }
      }
      return {
        y,
        m
      };
    });
    const computeFirstDayOfWeek = computed(() => {
      const { startDay } = props;
      return import_xe_utils16.default.toNumber(startDay);
    });
    const computeWeekDatas = computed(() => {
      const weeks = [];
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = computed(() => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map((day) => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = computed(() => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        const dateHeaders = computeDateHeaders.value;
        return [{ label: getI18n("vxe.input.date.weeks.w") }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = computed(() => {
      const yearList = computeYearList.value;
      return import_xe_utils16.default.chunk(yearList, 4);
    });
    const computeQuarterList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { quarterSize } = internalData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = import_xe_utils16.default.getWhatYear(selectMonth, 0, "first");
        const selFullYear = firstYear.getFullYear();
        for (let index = -2; index < quarterSize - 2; index++) {
          const date = import_xe_utils16.default.getWhatQuarter(firstYear, index);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = computed(() => {
      const quarterList = computeQuarterList.value;
      return import_xe_utils16.default.chunk(quarterList, 2);
    });
    const computeMonthList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { monthSize } = internalData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = import_xe_utils16.default.getWhatYear(selectMonth, 0, "first").getFullYear();
        for (let index = -4; index < monthSize - 4; index++) {
          const date = import_xe_utils16.default.getWhatYear(selectMonth, 0, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = computed(() => {
      const monthList = computeMonthList.value;
      return import_xe_utils16.default.chunk(monthList, 4);
    });
    const computeDayList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(import_xe_utils16.default.getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index = 0; index < 42; index++) {
          const date = import_xe_utils16.default.getWhatDay(startDayDate, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = computed(() => {
      const dayList = computeDayList.value;
      return import_xe_utils16.default.chunk(dayList, 7);
    });
    const computeWeekDates = computed(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map((list) => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: import_xe_utils16.default.getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const parseDate = (value, format) => {
      return import_xe_utils16.default.toStringDate(value, format);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      if (import_xe_utils16.default.toValueString(props.modelValue) !== value) {
        dispatchEvent("change", { value }, evnt);
      }
    };
    const dateParseValue = (value) => {
      const { type } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = "";
      if (value) {
        dValue = parseDate(value, dateValueFormat);
      }
      if (import_xe_utils16.default.isValidDate(dValue)) {
        dLabel = import_xe_utils16.default.toDateString(dValue, dateLabelFormat, { firstDay: firstDayOfWeek });
        if (dateLabelFormat && type === "week") {
          const firstWeekDate = import_xe_utils16.default.getWhatWeek(dValue, 0, firstDayOfWeek, firstDayOfWeek);
          if (firstWeekDate.getFullYear() < dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf("yyyy");
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${yyNum - 1}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    const changeValue = () => {
      const isCalendarType = computeIsCalendarType.value;
      const { inputValue } = reactData;
      if (isCalendarType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    const initValue = () => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        changeValue();
      }
    };
    const dateCheckMonth = (date) => {
      const month = import_xe_utils16.default.getWhatMonth(date, 0, "first");
      if (!import_xe_utils16.default.isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = (date) => {
      const { modelValue, multiple } = props;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === "week") {
        const sWeek = import_xe_utils16.default.toNumber(props.selectDay);
        date = import_xe_utils16.default.getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      }
      const inpVal = import_xe_utils16.default.toDateString(date, dateValueFormat, { firstDay: firstDayOfWeek });
      dateCheckMonth(date);
      reactData.selectValue = date;
      if (multiple) {
        const dateMultipleValue = computeDateMultipleValue.value;
        if (dateMultipleValue.some((val) => import_xe_utils16.default.isEqual(val, inpVal))) {
          handleChange(dateMultipleValue.filter((val) => !import_xe_utils16.default.isEqual(val, inpVal)).join(","), { type: "update" });
        } else {
          handleChange(dateMultipleValue.concat([inpVal]).join(","), { type: "update" });
        }
      } else {
        if (!import_xe_utils16.default.isEqual(modelValue, inpVal)) {
          handleChange(inpVal, { type: "update" });
        }
      }
    };
    const dateMonthHandle = (date, offsetMonth) => {
      reactData.selectMonth = import_xe_utils16.default.getWhatMonth(date, offsetMonth, "first");
    };
    const dateNowHandle = () => {
      const currentDate = import_xe_utils16.default.getWhatDay(Date.now(), 0, "first");
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleYearTypeEvent = () => {
      reactData.datePanelType = "year";
    };
    const dateToggleMonthTypeEvent = (evnt) => {
      let { datePanelType } = reactData;
      if (datePanelType === "month" || datePanelType === "quarter") {
        datePanelType = "year";
      } else {
        datePanelType = "month";
      }
      reactData.datePanelType = datePanelType;
      changeViewEvent(evnt);
    };
    const datePrevEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth } = reactData;
      const { yearSize } = internalData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        if (type === "year") {
          reactData.selectMonth = import_xe_utils16.default.getWhatYear(selectMonth, -yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils16.default.getWhatYear(selectMonth, -yearSize, "first");
          } else {
            reactData.selectMonth = import_xe_utils16.default.getWhatYear(selectMonth, -1, "first");
          }
        } else {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils16.default.getWhatYear(selectMonth, -yearSize, "first");
          } else if (datePanelType === "month") {
            reactData.selectMonth = import_xe_utils16.default.getWhatYear(selectMonth, -1, "first");
          } else {
            reactData.selectMonth = import_xe_utils16.default.getWhatMonth(selectMonth, -1, "first");
          }
        }
        dispatchEvent("date-prev", { type }, evnt);
        changeViewEvent(evnt);
      }
    };
    const dateTodayMonthEvent = (evnt) => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
      }
      dispatchEvent("date-today", { type: props.type }, evnt);
      changeViewEvent(evnt);
    };
    const dateNextEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth } = reactData;
      const { yearSize } = internalData;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        if (type === "year") {
          reactData.selectMonth = import_xe_utils16.default.getWhatYear(selectMonth, yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils16.default.getWhatYear(selectMonth, yearSize, "first");
          } else {
            reactData.selectMonth = import_xe_utils16.default.getWhatYear(selectMonth, 1, "first");
          }
        } else {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils16.default.getWhatYear(selectMonth, yearSize, "first");
          } else if (datePanelType === "month") {
            reactData.selectMonth = import_xe_utils16.default.getWhatYear(selectMonth, 1, "first");
          } else {
            reactData.selectMonth = import_xe_utils16.default.getWhatMonth(selectMonth, 1, "first");
          }
        }
        dispatchEvent("date-next", { type }, evnt);
        changeViewEvent(evnt);
      }
    };
    const isDateDisabled = (item) => {
      const { disabledMethod } = props;
      const { datePanelType } = reactData;
      return disabledMethod && disabledMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $calendar: $xeCalendar });
    };
    const changeViewEvent = (evnt) => {
      const { datePanelType } = reactData;
      const yearDatas = computeYearDatas.value;
      const quarterDatas = computeQuarterDatas.value;
      const monthDatas = computeMonthDatas.value;
      const weekDates = computeWeekDates.value;
      const dayDatas = computeDayDatas.value;
      const viewDates = [];
      let dataList = [];
      switch (datePanelType) {
        case "year":
          dataList = yearDatas;
          break;
        case "quarter":
          dataList = quarterDatas;
          break;
        case "month":
          dataList = monthDatas;
          break;
        case "week":
          dataList = weekDates;
          break;
        case "day":
          dataList = dayDatas;
          break;
      }
      dataList.forEach((rows) => {
        rows.forEach((item) => {
          viewDates.push(item.date);
        });
      });
      dispatchEvent("view-change", { viewType: datePanelType, viewDates }, evnt);
    };
    const dateSelectItem = (date) => {
      const { type } = props;
      const { datePanelType } = reactData;
      if (type === "month") {
        if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
          changeViewEvent(null);
        } else {
          dateChange(date);
        }
      } else if (type === "year") {
        dateChange(date);
      } else if (type === "quarter") {
        if (datePanelType === "year") {
          reactData.datePanelType = "quarter";
          dateCheckMonth(date);
          changeViewEvent(null);
        } else {
          dateChange(date);
        }
      } else {
        if (datePanelType === "month") {
          reactData.datePanelType = type === "week" ? type : "day";
          dateCheckMonth(date);
          changeViewEvent(null);
        } else if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
          changeViewEvent(null);
        } else {
          dateChange(date);
        }
      }
    };
    const dateSelectEvent = (item) => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = (offsetDay) => {
      if (!isDateDisabled({ date: offsetDay })) {
        const dayList = computeDayList.value;
        if (!dayList.some((item) => import_xe_utils16.default.isDateSame(item.date, offsetDay, "yyyyMMdd"))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = (offsetYear) => {
      if (!isDateDisabled({ date: offsetYear })) {
        const yearList = computeYearList.value;
        if (!yearList.some((item) => import_xe_utils16.default.isDateSame(item.date, offsetYear, "yyyy"))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = (offsetQuarter) => {
      if (!isDateDisabled({ date: offsetQuarter })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some((item) => import_xe_utils16.default.isDateSame(item.date, offsetQuarter, "yyyyq"))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = (offsetMonth) => {
      if (!isDateDisabled({ date: offsetMonth })) {
        const monthList = computeMonthList.value;
        if (!monthList.some((item) => import_xe_utils16.default.isDateSame(item.date, offsetMonth, "yyyyMM"))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = (item) => {
      if (!isDateDisabled(item)) {
        const { datePanelType } = reactData;
        if (datePanelType === "month") {
          dateMoveMonth(item.date);
        } else if (datePanelType === "quarter") {
          dateMoveQuarter(item.date);
        } else if (datePanelType === "year") {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const dateConfirmEvent = () => {
    };
    const dateOpenPanel = () => {
      const { type } = props;
      const dateValue = computeDateValue.value;
      if (["year", "quarter", "month", "week"].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = "day";
      }
      reactData.currentDate = import_xe_utils16.default.getWhatDay(Date.now(), 0, "first");
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
    };
    const renderDateLabel = (item, label) => {
      const { festivalMethod } = props;
      if (festivalMethod) {
        const { datePanelType } = reactData;
        const festivalRest = festivalMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $calendar: $xeCalendar });
        const festivalItem = festivalRest ? import_xe_utils16.default.isString(festivalRest) ? { label: festivalRest } : festivalRest : {};
        const extraItem = festivalItem.extra ? import_xe_utils16.default.isString(festivalItem.extra) ? { label: festivalItem.extra } : festivalItem.extra : null;
        const labels = [
          h("span", {
            class: ["vxe-calendar--date-label", {
              "is-notice": festivalItem.notice
            }]
          }, extraItem && extraItem.label ? [
            h("span", `${label || ""}`),
            h("span", {
              class: ["vxe-calendar--date-label--extra", extraItem.important ? "is-important" : "", extraItem.className],
              style: extraItem.style
            }, import_xe_utils16.default.toValueString(extraItem.label))
          ] : [`${label || ""}`])
        ];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          const festivalLabels = import_xe_utils16.default.toValueString(festivalLabel).split(",");
          labels.push(h("span", {
            class: ["vxe-calendar--date-festival", festivalItem.important ? "is-important" : "", festivalItem.className],
            style: festivalItem.style
          }, [
            festivalLabels.length > 1 ? h("span", {
              class: ["vxe-calendar--date-festival--overlap", `overlap--${festivalLabels.length}`]
            }, festivalLabels.map((label2) => h("span", label2.substring(0, 3)))) : h("span", {
              class: "vxe-calendar--date-festival--label"
            }, festivalLabels[0].substring(0, 3))
          ]));
        }
        return labels;
      }
      return `${label || ""}`;
    };
    const renderDateDayTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tr", dateHeaders.map((item) => {
            return h("th", {
              class: "vxe-calendar--view-th"
            }, item.label);
          })),
          ...dayDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils16.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils16.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils16.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          })
        ])
      ];
    };
    const renderDateWeekTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tr", weekHeaders.map((item) => {
            return h("td", {
              class: "vxe-calendar--view-th"
            }, item.label);
          })),
          ...weekDates.map((rows) => {
            const isSelected = multiple ? rows.some((item) => dateListValue.some((val) => import_xe_utils16.default.isDateSame(val, item.date, matchFormat))) : rows.some((item) => import_xe_utils16.default.isDateSame(dateValue, item.date, matchFormat));
            const isHover = rows.some((item) => import_xe_utils16.default.isDateSame(datePanelValue, item.date, matchFormat));
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--hover": isHover
                }],
                // event
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          })
        ])
      ];
    };
    const renderDateMonthTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMM";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", monthDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils16.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils16.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils16.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateQuarterTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyq";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", quarterDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils16.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils16.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils16.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateYearTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyy";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", yearDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils16.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils16.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils16.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.year));
            }));
          }))
        ])
      ];
    };
    const renderDateTable = () => {
      const { datePanelType } = reactData;
      switch (datePanelType) {
        case "week":
          return renderDateWeekTable();
        case "month":
          return renderDateMonthTable();
        case "quarter":
          return renderDateQuarterTable();
        case "year":
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const { multiple } = props;
      const { datePanelType } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelObj = computeSelectDatePanelObj.value;
      return [
        h("div", {
          class: "vxe-calendar--header"
        }, [
          h("div", {
            class: "vxe-calendar--type-wrapper"
          }, [
            datePanelType === "year" ? h(button_default, {
              class: "vxe-calendar--date-picker-label",
              disabled: datePanelType === "year",
              content: selectDatePanelObj.y
            }) : h("span", {
              class: "vxe-calendar--date-picker-btns"
            }, [
              h(button_default, {
                class: "vxe-calendar--date-picker-btn",
                content: selectDatePanelObj.y,
                onClick: dateToggleYearTypeEvent
              }),
              selectDatePanelObj.m ? h(button_default, {
                class: "vxe-calendar--date-picker-btn",
                content: selectDatePanelObj.m,
                onClick: dateToggleMonthTypeEvent
              }) : renderEmptyElement($xeCalendar)
            ])
          ]),
          h("div", {
            class: "vxe-calendar--btn-wrapper"
          }, [
            h(button_default, {
              disabled: isDisabledPrevDateBtn,
              icon: "vxe-icon-caret-left",
              onClick: datePrevEvent
            }),
            h(button_default, {
              icon: "vxe-icon-dot",
              onClick: dateTodayMonthEvent
            }),
            h(button_default, {
              disabled: isDisabledNextDateBtn,
              icon: "vxe-icon-caret-right",
              onClick: dateNextEvent
            }),
            multiple && computeSupportMultiples.value ? h("span", {
              class: "vxe-calendar--btn vxe-calendar--confirm-btn"
            }, [
              h("button", {
                class: "vxe-calendar--confirm",
                type: "button",
                onClick: dateConfirmEvent
              }, getI18n("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        h("div", {
          class: "vxe-calendar--body"
        }, renderDateTable())
      ];
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $input: $xeCalendar }, params));
    };
    const calendarMethods = {
      dispatchEvent
    };
    Object.assign($xeCalendar, calendarMethods);
    const renderVN = () => {
      const { className, type } = props;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const calendarStyle = computeCalendarStyle.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-calendar", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          "is--disabled": isDisabled
        }],
        style: calendarStyle
      }, [
        renderDatePanel()
      ]);
    };
    $xeCalendar.renderVN = renderVN;
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
      changeValue();
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        selectValue: null,
        inputValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      });
      initValue();
      dateOpenPanel();
    });
    watch(computeDateLabelFormat, () => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    onMounted(() => {
      dateOpenPanel();
    });
    initValue();
    return $xeCalendar;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/calendar/index.js
var VxeCalendar = Object.assign({}, calendar_default, {
  install(app) {
    app.component(calendar_default.name, calendar_default);
  }
});
dynamicApp.use(VxeCalendar);
VxeUI.component(calendar_default);
var Calendar = VxeCalendar;
var calendar_default2 = VxeCalendar;

// node_modules/vxe-pc-ui/es/loading/src/loading.js
var import_xe_utils17 = __toESM(require_xe_utils());
var loading_default = defineVxeComponent({
  name: "VxeLoading",
  props: {
    modelValue: Boolean,
    icon: {
      type: String,
      default: () => getConfig().loading.icon
    },
    showIcon: {
      type: Boolean,
      default: () => getConfig().loading.showIcon
    },
    text: {
      type: String,
      default: () => getConfig().loading.text
    },
    showText: {
      type: Boolean,
      default: () => getConfig().loading.showText
    },
    status: String,
    size: {
      type: String,
      default: () => getConfig().loading.size || getConfig().size
    }
  },
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils17.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false
    });
    const computeMaps = {
      computeSize
    };
    const $xeLoading = {
      xID,
      props,
      context,
      reactData,
      getComputeMaps: () => computeMaps
    };
    const computeLoadingIcon = computed(() => {
      return props.icon || getIcon().LOADING;
    });
    const computeLoadingText = computed(() => {
      const { text } = props;
      return import_xe_utils17.default.isString(text) ? text : getI18n("vxe.loading.text");
    });
    const handleInit = () => {
      if (!reactData.initialized) {
        reactData.initialized = !!reactData.initialized;
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $loading: $xeLoading }, params));
    };
    const loadingMethods = {
      dispatchEvent
    };
    const loadingPrivateMethods = {};
    Object.assign($xeLoading, loadingMethods, loadingPrivateMethods);
    const renderVN = () => {
      const { modelValue, showIcon, status } = props;
      const { initialized } = reactData;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const textSlot = slots.text;
      const iconSlot = slots.icon;
      const loadingIcon = computeLoadingIcon.value;
      const loadingText = computeLoadingText.value;
      if (!initialized && !modelValue) {
        return renderEmptyElement($xeLoading);
      }
      return h("div", {
        class: ["vxe-loading", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--visible": modelValue
        }]
      }, defaultSlot ? [
        h("div", {
          class: "vxe-loading--wrapper"
        }, getSlotVNs2(defaultSlot({})))
      ] : [
        h("div", {
          class: "vxe-loading--chunk"
        }, [
          showIcon && (iconSlot || loadingIcon) ? h("div", {
            class: "vxe-loading--icon"
          }, iconSlot ? getSlotVNs2(iconSlot({})) : [
            h("i", {
              class: loadingIcon
            })
          ]) : h("div", {
            class: "vxe-loading--spinner"
          }),
          textSlot || loadingText ? h("div", {
            class: "vxe-loading--text"
          }, textSlot ? getSlotVNs2(textSlot({})) : `${loadingText}`) : null
        ])
      ]);
    };
    watch(() => props.modelValue, () => {
      handleInit();
    });
    handleInit();
    $xeLoading.renderVN = renderVN;
    return $xeLoading;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/card/src/card.js
var import_xe_utils18 = __toESM(require_xe_utils());
var card_default = defineVxeComponent({
  name: "VxeCard",
  props: {
    title: String,
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().card.showTitleOverflow
    },
    width: [String, Number],
    height: [String, Number],
    border: {
      type: Boolean,
      default: () => getConfig().card.border
    },
    loading: Boolean,
    shadow: {
      type: Boolean,
      default: () => getConfig().card.shadow
    },
    padding: {
      type: Boolean,
      default: () => getConfig().card.padding
    },
    size: {
      type: String,
      default: () => getConfig().card.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils18.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeCardStyle = computed(() => {
      const { height, width } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {
      computeSize
    };
    const $xeCard = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $card: $xeCard }, params));
    };
    const cardMethods = {
      dispatchEvent
    };
    const cardPrivateMethods = {};
    Object.assign($xeCard, cardMethods, cardPrivateMethods);
    const renderVN = () => {
      const { title, border, shadow, padding, loading: loading2, showTitleOverflow } = props;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const titleSlot = slots.title;
      const extraSlot = slots.extra;
      const footerSlot = slots.footer;
      const leftSlot = slots.left;
      const rightSlot = slots.right;
      const vSize = computeSize.value;
      const cardStyle = computeCardStyle.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-card", {
          [`size--${vSize}`]: vSize,
          "is--border": border,
          "is--shadow": shadow,
          "is--padding": padding
        }],
        style: cardStyle
      }, [
        title || titleSlot || headerSlot ? h("div", {
          class: "vxe-card--header"
        }, headerSlot ? getSlotVNs2(headerSlot({})) : [
          h("div", {
            class: ["vxe-card--header-title", {
              "is--ellipsis": showTitleOverflow
            }]
          }, titleSlot ? getSlotVNs2(titleSlot({})) : `${title || ""}`),
          extraSlot ? h("div", {
            class: "vxe-card--header-extra"
          }, getSlotVNs2(extraSlot({}))) : renderEmptyElement($xeCard)
        ]) : renderEmptyElement($xeCard),
        h("div", {
          class: "vxe-card--body"
        }, [
          leftSlot ? h("div", {
            class: "vxe-card--body-left"
          }, getSlotVNs2(leftSlot({}))) : renderEmptyElement($xeCard),
          h("div", {
            class: "vxe-card--body-content"
          }, defaultSlot ? getSlotVNs2(defaultSlot({})) : []),
          rightSlot ? h("div", {
            class: "vxe-card--body-right"
          }, getSlotVNs2(rightSlot({}))) : renderEmptyElement($xeCard)
        ]),
        footerSlot ? h("div", {
          class: "vxe-card--footer"
        }, getSlotVNs2(footerSlot({}))) : renderEmptyElement($xeCard),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-card--loading",
          modelValue: loading2
        })
      ]);
    };
    $xeCard.renderVN = renderVN;
    return $xeCard;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/card/index.js
var VxeCard = Object.assign({}, card_default, {
  install(app) {
    app.component(card_default.name, card_default);
  }
});
dynamicApp.use(VxeCard);
VxeUI.component(card_default);
var Card = VxeCard;
var card_default2 = VxeCard;

// node_modules/vxe-pc-ui/es/carousel/src/carousel.js
var import_xe_utils19 = __toESM(require_xe_utils());
var carousel_default = defineVxeComponent({
  name: "VxeCarousel",
  props: {
    modelValue: [String, Number],
    options: Array,
    loading: Boolean,
    height: {
      type: [Number, String],
      default: () => getConfig().carousel.height
    },
    width: {
      type: [Number, String],
      default: () => getConfig().carousel.width
    },
    autoPlay: {
      type: Boolean,
      default: () => getConfig().carousel.autoPlay
    },
    interval: {
      type: [Number, String],
      default: () => getConfig().carousel.interval
    },
    loop: {
      type: Boolean,
      default: () => getConfig().carousel.loop
    },
    vertical: {
      type: Boolean,
      default: () => getConfig().carousel.vertical
    },
    showIndicators: {
      type: Boolean,
      default: () => getConfig().carousel.showIndicators
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils19.default.uniqueId();
    const refElem = ref();
    const refWrapperElem = ref();
    const reactData = reactive({
      activeName: "",
      staticItems: [],
      itemWidth: 0,
      itemHeight: 0
    });
    const internalData = {
      apTimeout: void 0,
      stopFlag: false
    };
    const refMaps = {
      refElem
    };
    const computeListStyle = computed(() => {
      const { vertical, options } = props;
      const { activeName, itemWidth, itemHeight, staticItems } = reactData;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      const activeIndex = Math.max(0, import_xe_utils19.default.findIndexOf(list, (item) => item.name === activeName));
      const stys = {};
      if (vertical) {
        stys.transform = `translateY(-${activeIndex * itemHeight}px)`;
      } else {
        stys.width = `${itemWidth * list.length}px`;
        stys.transform = `translateX(-${activeIndex * itemWidth}px)`;
      }
      return stys;
    });
    const computeMaps = {};
    const $xeCarousel = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const updateStyle = () => {
      nextTick(() => {
        const wrapperElem = refWrapperElem.value;
        if (wrapperElem) {
          reactData.itemWidth = wrapperElem.clientWidth;
          reactData.itemHeight = wrapperElem.clientHeight;
        }
      });
    };
    const clickItemEvent = (evnt, item) => {
      const value = item.name;
      reactData.activeName = item.name;
      emit("update:modelValue", value);
      emit("change", { value }, evnt);
      updateStyle();
    };
    const initDefaultActive = (list) => {
      let activeName = null;
      if (list && list.length) {
        let validVal = false;
        activeName = props.modelValue;
        list.forEach((item) => {
          if (activeName === item.name) {
            validVal = true;
          }
        });
        if (!validVal) {
          activeName = list[0].name;
          emit("update:modelValue", activeName);
        }
      }
      reactData.activeName = activeName;
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $carousel: $xeCarousel }, params));
    };
    const handlePrevNext = (isNext) => {
      const { options, loop } = props;
      const { activeName, staticItems } = reactData;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      const index = Math.max(0, import_xe_utils19.default.findIndexOf(list, (item) => item.name === activeName));
      if (index > -1) {
        let item = null;
        if (isNext) {
          if (index < list.length - 1) {
            item = list[index + 1];
          } else {
            if (loop) {
              item = list[0];
            }
          }
        } else {
          if (index > 0) {
            item = list[index - 1];
          } else {
            if (loop) {
              item = list[list.length - 1];
            }
          }
        }
        if (item) {
          const name = item.name;
          const value = name;
          reactData.activeName = name;
          emit("update:modelValue", value);
          return true;
        }
      }
      return false;
    };
    const carouselMethods = {
      dispatchEvent,
      prev() {
        if (handlePrevNext(false)) {
          handleAutoPlay();
        }
        return nextTick();
      },
      next() {
        if (handlePrevNext(true)) {
          handleAutoPlay();
        }
        return nextTick();
      }
    };
    const prevEvent = (evnt) => {
      if (handlePrevNext(false)) {
        const value = reactData.activeName;
        emit("change", { value }, evnt);
      }
    };
    const nextEvent = (evnt) => {
      if (handlePrevNext(true)) {
        const value = reactData.activeName;
        emit("change", { value }, evnt);
      }
    };
    const stopAutoPlay = () => {
      const { apTimeout } = internalData;
      internalData.stopFlag = true;
      if (apTimeout) {
        clearTimeout(apTimeout);
        internalData.apTimeout = void 0;
      }
    };
    const handleAutoPlay = () => {
      const { autoPlay, interval } = props;
      const { stopFlag } = internalData;
      stopAutoPlay();
      if (autoPlay) {
        internalData.stopFlag = false;
        internalData.apTimeout = setTimeout(() => {
          if (!stopFlag) {
            handlePrevNext(true);
          }
        }, import_xe_utils19.default.toNumber(interval) || 300);
      }
    };
    const mouseenterEvent = () => {
      stopAutoPlay();
    };
    const mouseleaveEvent = () => {
      handleAutoPlay();
    };
    const carouselPrivateMethods = {};
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils19.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils19.default.isFunction(slotFunc)) {
          return getSlotVNs2(slotFunc(params));
        }
      }
      return [];
    };
    Object.assign($xeCarousel, carouselMethods, carouselPrivateMethods);
    const renderItemWrapper = (list) => {
      const { height } = props;
      const { activeName } = reactData;
      const listStyle = computeListStyle.value;
      return h("div", {
        class: "vxe-carousel--list",
        style: listStyle
      }, list.map((item) => {
        const { name, url, slots: slots2 } = item;
        const defaultSlot = slots2 ? slots2.default : null;
        return h("div", {
          key: `${name}`,
          class: ["vxe-carousel--item-inner", {
            "is--active": activeName === name
          }],
          style: height ? {
            height: toCssUnit(height)
          } : null
        }, defaultSlot ? callSlot(defaultSlot, {}) : [
          h("img", {
            class: "vxe-carousel--item-img",
            src: url
          })
        ]);
      }));
    };
    const renderIndicators = (list) => {
      const { activeName } = reactData;
      return h("div", {
        class: "vxe-carousel--indicators"
      }, list.map((item) => {
        const { name } = item;
        return h("div", {
          key: `${name}`,
          class: ["vxe-carousel--indicators-item", {
            "is--active": activeName === name
          }],
          onClick(evnt) {
            clickItemEvent(evnt, item);
          }
        });
      }));
    };
    const renderVN = () => {
      const { loading: loading2, height, width, showIndicators, vertical, options } = props;
      const { staticItems } = reactData;
      const defaultSlot = slots.default;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      return h("div", {
        ref: refElem,
        class: ["vxe-carousel", `is--${vertical ? "vertical" : "horizontal"}`],
        style: width ? {
          width: toCssUnit(width)
        } : null,
        onMouseenter: mouseenterEvent,
        onMouseleave: mouseleaveEvent
      }, [
        h("div", {
          class: "vxe-carousel--slots"
        }, defaultSlot ? defaultSlot({}) : []),
        h("div", {
          ref: refWrapperElem,
          class: "vxe-carousel--item-wrapper",
          style: height ? {
            height: toCssUnit(height)
          } : null
        }, [
          renderItemWrapper(list)
        ]),
        showIndicators ? renderIndicators(list) : renderEmptyElement($xeCarousel),
        h("div", {
          class: "vxe-carousel--btn-wrapper"
        }, [
          h("div", {
            class: "vxe-carousel--previous-btn",
            onClick: prevEvent
          }, [
            h("i", {
              class: vertical ? getIcon().CAROUSEL_VERTICAL_PREVIOUS : getIcon().CAROUSEL_HORIZONTAL_PREVIOUS
            })
          ]),
          h("div", {
            class: "vxe-carousel--next-btn",
            onClick: nextEvent
          }, [
            h("i", {
              class: vertical ? getIcon().CAROUSEL_VERTICAL_NEXT : getIcon().CAROUSEL_HORIZONTAL_NEXT
            })
          ])
        ]),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-carousel--loading",
          modelValue: loading2
        })
      ]);
    };
    const optsFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    watch(() => props.options, () => {
      optsFlag.value++;
    });
    watch(optsFlag, () => {
      initDefaultActive(props.options);
    });
    const stFlag = ref(0);
    watch(() => reactData.staticItems ? reactData.staticItems.length : -1, () => {
      stFlag.value++;
    });
    watch(() => reactData.staticItems, () => {
      stFlag.value++;
    });
    watch(stFlag, () => {
      initDefaultActive(reactData.staticItems);
    });
    watch(() => props.autoPlay, () => {
      handleAutoPlay();
    });
    initDefaultActive(reactData.staticItems.length ? reactData.staticItems : props.options);
    onMounted(() => {
      handleAutoPlay();
      updateStyle();
    });
    onUnmounted(() => {
      stopAutoPlay();
    });
    provide("$xeCarousel", $xeCarousel);
    $xeCarousel.renderVN = renderVN;
    return $xeCarousel;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/carousel/index.js
var VxeCarousel = Object.assign({}, carousel_default, {
  install(app) {
    app.component(carousel_default.name, carousel_default);
  }
});
dynamicApp.use(VxeCarousel);
VxeUI.component(carousel_default);
var Carousel = VxeCarousel;
var carousel_default2 = VxeCarousel;

// node_modules/vxe-pc-ui/es/carousel/src/util.js
var import_xe_utils20 = __toESM(require_xe_utils());
function assembleCarouselItem($xeCarousel, elem, itemConfig) {
  const staticItems = $xeCarousel.reactData.staticItems;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticItems.splice(import_xe_utils20.default.arrayIndexOf(parentElem.children, elem), 0, itemConfig);
  }
  $xeCarousel.reactData.staticItems = staticItems.slice(0);
}
function destroyCarouselItem($xeCarousel, itemConfig) {
  const staticItems = $xeCarousel.reactData.staticItems;
  const index = import_xe_utils20.default.findIndexOf(staticItems, (item) => item.id === itemConfig.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  $xeCarousel.reactData.staticItems = staticItems.slice(0);
}

// node_modules/vxe-pc-ui/es/carousel/src/carousel-item.js
var import_xe_utils21 = __toESM(require_xe_utils());
var carousel_item_default = defineVxeComponent({
  name: "VxeCarouselItem",
  props: {
    name: [String, Number],
    className: String,
    url: String
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeCarousel = inject("$xeCarousel", null);
    const xID = import_xe_utils21.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const itemConfig = reactive({
      id: xID,
      name: props.name,
      url: props.url,
      className: props.className,
      slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCarouselItem = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $carouselItem: $xeCarouselItem }, params));
    };
    const carouselItemMethods = {
      dispatchEvent
    };
    const carouselItemPrivateMethods = {};
    Object.assign($xeCarouselItem, carouselItemMethods, carouselItemPrivateMethods);
    const renderVN = () => {
      return h("div", {
        ref: refElem
      });
    };
    watch(() => props.name, (val) => {
      itemConfig.name = val;
    });
    watch(() => props.url, (val) => {
      itemConfig.url = val;
    });
    onMounted(() => {
      const elem = refElem.value;
      if ($xeCarousel && elem) {
        assembleCarouselItem($xeCarousel, elem, itemConfig);
      }
    });
    onUnmounted(() => {
      if ($xeCarousel) {
        destroyCarouselItem($xeCarousel, itemConfig);
      }
    });
    $xeCarouselItem.renderVN = renderVN;
    return $xeCarouselItem;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/carousel-item/index.js
var VxeCarouselItem = Object.assign({}, carousel_item_default, {
  install(app) {
    app.component(carousel_item_default.name, carousel_item_default);
  }
});
dynamicApp.use(VxeCarouselItem);
VxeUI.component(carousel_item_default);
var CarouselItem = VxeCarouselItem;
var carousel_item_default2 = VxeCarouselItem;

// node_modules/vxe-pc-ui/es/checkbox/src/checkbox.js
var import_xe_utils22 = __toESM(require_xe_utils());
var checkbox_default = defineVxeComponent({
  name: "VxeCheckbox",
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number],
      default: null
    },
    indeterminate: Boolean,
    title: [String, Number],
    checkedValue: {
      type: [String, Number, Boolean],
      default: true
    },
    uncheckedValue: {
      type: [String, Number, Boolean],
      default: false
    },
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().checkbox.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const $xeCheckboxGroup = inject("$xeCheckboxGroup", null);
    const xID = import_xe_utils22.default.uniqueId();
    const reactData = reactive({});
    const $xeCheckbox = {
      xID,
      props,
      context,
      reactData
    };
    let checkboxMethods = {};
    const { computeSize } = useSize(props);
    const computeIsChecked = computed(() => {
      if ($xeCheckboxGroup) {
        return import_xe_utils22.default.includes($xeCheckboxGroup.props.modelValue, props.label);
      }
      return props.modelValue === props.checkedValue;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      const isChecked = computeIsChecked.value;
      if (disabled === null) {
        if ($xeCheckboxGroup) {
          const { computeIsDisabled: computeIsGroupDisabled, computeIsMaximize: computeIsGroupMaximize } = $xeCheckboxGroup.getComputeMaps();
          const isGroupDisabled = computeIsGroupDisabled.value;
          const isGroupMaximize = computeIsGroupMaximize.value;
          return isGroupDisabled || isGroupMaximize && !isChecked;
        }
      }
      return disabled;
    });
    const changeEvent = (evnt) => {
      const { checkedValue, uncheckedValue } = props;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const checked = evnt.target.checked;
        const value = checked ? checkedValue : uncheckedValue;
        const params = { checked, value, label: props.label };
        if ($xeCheckboxGroup) {
          $xeCheckboxGroup.handleChecked(params, evnt);
        } else {
          emit("update:modelValue", value);
          checkboxMethods.dispatchEvent("change", params, evnt);
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
          }
        }
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $checkbox: $xeCheckbox }, params));
    };
    checkboxMethods = {
      dispatchEvent
    };
    Object.assign($xeCheckbox, checkboxMethods);
    const renderVN = () => {
      const { label } = props;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isChecked = computeIsChecked.value;
      const indeterminate = !isChecked && props.indeterminate;
      return h("label", {
        key: label,
        class: ["vxe-checkbox vxe-checkbox--default", {
          [`size--${vSize}`]: vSize,
          "is--indeterminate": indeterminate,
          "is--disabled": isDisabled,
          "is--checked": isChecked
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-checkbox--input",
          type: "checkbox",
          disabled: isDisabled,
          checked: isChecked,
          onChange: changeEvent
        }),
        h("span", {
          class: ["vxe-checkbox--icon", indeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : isDisabled ? getIcon().CHECKBOX_DISABLED_UNCHECKED : getIcon().CHECKBOX_UNCHECKED]
        }),
        h("span", {
          class: "vxe-checkbox--label"
        }, slots.default ? slots.default({}) : getFuncText(props.content))
      ]);
    };
    $xeCheckbox.renderVN = renderVN;
    return $xeCheckbox;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/checkbox/index.js
var VxeCheckbox = Object.assign(checkbox_default, {
  install(app) {
    app.component(checkbox_default.name, checkbox_default);
  }
});
dynamicApp.use(VxeCheckbox);
VxeUI.component(checkbox_default);
var Checkbox = VxeCheckbox;
var checkbox_default2 = VxeCheckbox;

// node_modules/vxe-pc-ui/es/checkbox/src/button.js
var import_xe_utils23 = __toESM(require_xe_utils());
var button_default3 = defineVxeComponent({
  name: "VxeCheckboxButton",
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: null
    },
    title: [String, Number],
    checkedValue: {
      type: [String, Number, Boolean],
      default: true
    },
    uncheckedValue: {
      type: [String, Number, Boolean],
      default: false
    },
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().checkboxButton.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const $xeCheckboxGroup = inject("$xeCheckboxGroup", null);
    const xID = import_xe_utils23.default.uniqueId();
    const reactData = reactive({});
    const { computeSize } = useSize(props);
    const $xeCheckboxButton = {
      xID,
      props,
      context,
      reactData
    };
    const computeIsChecked = computed(() => {
      if ($xeCheckboxGroup) {
        return import_xe_utils23.default.includes($xeCheckboxGroup.props.modelValue, props.label);
      }
      return props.modelValue === props.checkedValue;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      const isChecked = computeIsChecked.value;
      if (disabled === null) {
        if ($xeCheckboxGroup) {
          const { computeIsDisabled: computeIsGroupDisabled, computeIsMaximize: computeIsGroupMaximize } = $xeCheckboxGroup.getComputeMaps();
          const isGroupDisabled = computeIsGroupDisabled.value;
          const isGroupMaximize = computeIsGroupMaximize.value;
          return isGroupDisabled || isGroupMaximize && !isChecked;
        }
      }
      return disabled;
    });
    const changeEvent = (evnt) => {
      const { checkedValue, uncheckedValue } = props;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const checked = evnt.target.checked;
        const value = checked ? checkedValue : uncheckedValue;
        const params = { checked, value, label: props.label };
        if ($xeCheckboxGroup) {
          $xeCheckboxGroup.handleChecked(params, evnt);
        } else {
          emit("update:modelValue", value);
          $xeCheckboxButton.dispatchEvent("change", params, evnt);
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
          }
        }
      }
    };
    const checkboxButtonMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $checkboxButton: $xeCheckboxButton }, params));
      }
    };
    const checkboxButtonPrivateMethods = {};
    Object.assign($xeCheckboxButton, checkboxButtonMethods, checkboxButtonPrivateMethods);
    const renderVN = () => {
      const { label } = props;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isChecked = computeIsChecked.value;
      return h("label", {
        key: label,
        class: ["vxe-checkbox vxe-checkbox--button", {
          [`size--${vSize}`]: vSize,
          "is--disabled": isDisabled
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-checkbox--input",
          type: "checkbox",
          disabled: isDisabled,
          checked: isChecked,
          onChange: changeEvent
        }),
        h("span", {
          class: "vxe-checkbox--label"
        }, slots.default ? slots.default({}) : getFuncText(props.content))
      ]);
    };
    $xeCheckboxButton.renderVN = renderVN;
    return renderVN;
  }
});

// node_modules/vxe-pc-ui/es/checkbox-button/index.js
var VxeCheckboxButton = Object.assign(button_default3, {
  install: function(app) {
    app.component(button_default3.name, button_default3);
  }
});
dynamicApp.use(VxeCheckboxButton);
VxeUI.component(button_default3);
var CheckboxButton = VxeCheckboxButton;
var checkbox_button_default = VxeCheckboxButton;

// node_modules/vxe-pc-ui/es/checkbox/src/group.js
var import_xe_utils24 = __toESM(require_xe_utils());
var group_default = defineVxeComponent({
  name: "VxeCheckboxGroup",
  props: {
    modelValue: Array,
    options: Array,
    optionProps: Object,
    disabled: {
      type: Boolean,
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().checkboxGroup.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils24.default.uniqueId();
    const reactData = reactive({});
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsMaximize = computed(() => {
      const { modelValue, max } = props;
      if (max) {
        return (modelValue ? modelValue.length : 0) >= import_xe_utils24.default.toNumber(max);
      }
      return false;
    });
    const computePropsOpts = computed(() => {
      return Object.assign({}, props.optionProps);
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeDisabledField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || "disabled";
    });
    const computeMaps = {
      computeIsMaximize,
      computeIsDisabled
    };
    const $xeCheckboxGroup = {
      xID,
      props,
      context,
      reactData,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $checkboxGroup: $xeCheckboxGroup }, params));
    };
    const checkboxGroupMethods = {
      dispatchEvent
    };
    const checkboxGroupPrivateMethods = {
      handleChecked(params, evnt) {
        const { checked, label } = params;
        const checklist = props.modelValue || [];
        const checkIndex = checklist.indexOf(label);
        if (checked) {
          if (checkIndex === -1) {
            checklist.push(label);
          }
        } else {
          checklist.splice(checkIndex, 1);
        }
        emit("update:modelValue", checklist);
        $xeCheckboxGroup.dispatchEvent("change", Object.assign({}, params, { checklist, value: checklist }), evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, checklist);
        }
      }
    };
    Object.assign($xeCheckboxGroup, checkboxGroupMethods, checkboxGroupPrivateMethods);
    const renderVN = () => {
      const { options } = props;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      return h("div", {
        class: "vxe-checkbox-group"
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item) => {
        return h(checkbox_default, {
          key: item[valueField],
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    provide("$xeCheckboxGroup", $xeCheckboxGroup);
    $xeCheckboxGroup.renderVN = renderVN;
    return renderVN;
  }
});

// node_modules/vxe-pc-ui/es/checkbox-group/index.js
var VxeCheckboxGroup = Object.assign(group_default, {
  install(app) {
    app.component(group_default.name, group_default);
  }
});
dynamicApp.use(VxeCheckboxGroup);
VxeUI.component(group_default);
var CheckboxGroup = VxeCheckboxGroup;
var checkbox_group_default = VxeCheckboxGroup;

// node_modules/vxe-pc-ui/es/row/src/col.js
var import_xe_utils25 = __toESM(require_xe_utils());
var col_default = defineVxeComponent({
  name: "VxeCol",
  props: {
    span: [Number, String],
    align: String,
    width: [Number, String],
    fill: Boolean,
    ellipsis: Boolean,
    size: {
      type: String,
      default: () => getConfig().col.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils25.default.uniqueId();
    useSize(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const $xeRow = inject("$xeRow", null);
    const computeRowGutter = computed(() => {
      if ($xeRow) {
        return $xeRow.props.gutter;
      }
      return null;
    });
    const computeRowVertical = computed(() => {
      if ($xeRow) {
        return $xeRow.props.vertical;
      }
      return null;
    });
    const computeColStyle = computed(() => {
      const { width } = props;
      const rowGutter = computeRowGutter.value;
      const rowVertical = computeRowVertical.value;
      const style = {};
      if (rowGutter) {
        let [lrGutter, tbGutter] = import_xe_utils25.default.isArray(rowGutter) ? rowGutter : [rowGutter];
        if (rowVertical) {
          tbGutter = lrGutter;
          lrGutter = "";
        }
        if (lrGutter) {
          const padding = import_xe_utils25.default.isNumber(lrGutter) ? toCssUnit(lrGutter / 2) : `calc(${toCssUnit(lrGutter)} / 2)`;
          style.paddingLeft = padding;
          style.paddingRight = padding;
        }
        if (tbGutter) {
          const padding = import_xe_utils25.default.isNumber(tbGutter) ? toCssUnit(tbGutter / 2) : `calc(${toCssUnit(tbGutter)} / 2)`;
          style.paddingTop = padding;
          style.paddingBottom = padding;
        }
      }
      if (width) {
        style.width = toCssUnit(width);
      }
      return style;
    });
    const computeMaps = {};
    const $xeCol = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $col: $xeCol }, params));
    };
    const colMethods = {
      dispatchEvent
    };
    const colPrivateMethods = {};
    Object.assign($xeCol, colMethods, colPrivateMethods);
    const renderVN = () => {
      const { span, fill, align, width, ellipsis } = props;
      const colStyle = computeColStyle.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-col", span ? `span${span}` : "", align ? `align--${align}` : "", {
          "is--span": !!span,
          "is--width": !!width,
          "is--fill": fill,
          "is--ellipsis": ellipsis
        }],
        style: colStyle
      }, [
        h("div", {
          class: "vxe-col--inner"
        }, defaultSlot ? defaultSlot({}) : [])
      ]);
    };
    $xeCol.renderVN = renderVN;
    return $xeCol;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/col/index.js
var VxeCol = Object.assign({}, col_default, {
  install(app) {
    app.component(col_default.name, col_default);
  }
});
dynamicApp.use(VxeCol);
VxeUI.component(col_default);
var Col = VxeCol;
var col_default2 = VxeCol;

// node_modules/vxe-pc-ui/es/collapse/src/collapse.js
var import_xe_utils26 = __toESM(require_xe_utils());
var collapse_default = defineVxeComponent({
  name: "VxeCollapse",
  props: {
    modelValue: Array,
    options: Array,
    padding: {
      type: Boolean,
      default: () => getConfig().collapse.padding
    },
    expandConfig: Object,
    size: {
      type: String,
      default: () => getConfig().collapse.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "load",
    "change",
    "toggle-expand"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils26.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({
      staticPanes: [],
      activeNames: [],
      initNames: [],
      cachePaneMaps: {}
    });
    const refMaps = {
      refElem
    };
    const computeItemOptions = computed(() => {
      const { options } = props;
      return (options || []).filter((item) => handleFilterItem(item));
    });
    const computeItemStaticOptions = computed(() => {
      const { staticPanes } = reactData;
      return staticPanes.filter((item) => handleFilterItem(item));
    });
    const computeExpandOpts = computed(() => {
      return Object.assign({}, getConfig().collapse.expandConfig, props.expandConfig);
    });
    const computeMaps = {};
    const $xeCollapse = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const handleFilterItem = (item) => {
      const { permissionCode } = item;
      if (permissionCode) {
        if (!permission.checkVisible(permissionCode)) {
          return false;
        }
      }
      return true;
    };
    const addInitName = (name) => {
      const { initNames } = reactData;
      if (name && !initNames.includes(name)) {
        initNames.push(name);
        dispatchEvent("load", { name }, null);
        return true;
      }
      return false;
    };
    const initDefaultName = (list) => {
      const { activeNames } = reactData;
      const nameMaps = {};
      if (list && list.length) {
        list.forEach((item) => {
          const { name, preload } = item || {};
          if (name) {
            const isActive = activeNames.includes(name);
            nameMaps[`${name}`] = {
              loading: false
            };
            if (isActive) {
              addInitName(name);
            }
            if (preload) {
              if (!isActive) {
                activeNames.push(name);
              }
            }
          }
        });
      }
      reactData.activeNames = activeNames ? activeNames.slice(0) : [];
      reactData.cachePaneMaps = nameMaps;
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $collapse: $xeCollapse }, params));
    };
    const collapseMethods = {
      dispatchEvent
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils26.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils26.default.isFunction(slotFunc)) {
          return getSlotVNs2(slotFunc(params));
        }
      }
      return [];
    };
    const handleClickEvent = (evnt, item) => {
      const { activeNames } = reactData;
      const { name } = item;
      if (name) {
        const aIndex = activeNames.indexOf(name);
        let expanded = false;
        if (aIndex === -1) {
          expanded = true;
          activeNames.push(name);
        } else {
          activeNames.splice(aIndex, 1);
        }
        addInitName(name);
        dispatchEvent("change", { value: activeNames, name }, evnt);
        dispatchEvent("toggle-expand", { value: activeNames, name, expanded }, evnt);
      }
    };
    const collapsePrivateMethods = {};
    Object.assign($xeCollapse, collapseMethods, collapsePrivateMethods);
    const renderList = (itemList) => {
      const { activeNames, initNames } = reactData;
      const expandOpts = computeExpandOpts.value;
      return itemList.map((item) => {
        const { icon, name, title, slots: slots2 } = item;
        const titleSlot = slots2 ? slots2.title : null;
        const defaultSlot = slots2 ? slots2.default : null;
        const isActive = name && activeNames.includes(name);
        return h("div", {
          class: "vxe-collapse-item"
        }, [
          h("div", {
            class: "vxe-collapse--item-header",
            onClick(evnt) {
              handleClickEvent(evnt, item);
            }
          }, [
            expandOpts.showIcon ? h("span", {
              class: "vxe-collapse--item-switch"
            }, [
              h("i", {
                class: isActive ? getIcon().COLLAPSE_OPEN : getIcon().COLLAPSE_CLOSE
              })
            ]) : renderEmptyElement($xeCollapse),
            icon ? h("span", {
              class: "vxe-collapse--item-icon"
            }, [
              h("i", {
                class: icon
              })
            ]) : renderEmptyElement($xeCollapse),
            h("span", {
              class: "vxe-collapse--item-name"
            }, titleSlot ? callSlot(titleSlot, { name, title }) : `${title}`)
          ]),
          h("div", {
            class: ["vxe-collapse--item-content", {
              "is--visible": isActive
            }]
          }, [
            name && initNames.includes(name) ? h("div", {
              class: "vxe-collapse--item-inner"
            }, [
              defaultSlot ? callSlot(defaultSlot, { name, title }) : ""
            ]) : renderEmptyElement($xeCollapse)
          ])
        ]);
      });
    };
    const renderVN = () => {
      const { padding } = props;
      const vSize = computeSize.value;
      const itemOptions = computeItemOptions.value;
      const itemStaticOptions = computeItemStaticOptions.value;
      const defaultSlot = slots.default;
      const itemList = defaultSlot ? itemStaticOptions : itemOptions;
      return h("div", {
        ref: refElem,
        class: ["vxe-collapse", {
          [`size--${vSize}`]: vSize,
          "is--padding": padding
        }]
      }, [
        h("div", {
          class: "vxe-collapse-slots"
        }, defaultSlot ? defaultSlot({}) : []),
        renderList(itemList)
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.activeNames = val || [];
    });
    const optsFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    watch(() => props.options, () => {
      optsFlag.value++;
    });
    watch(optsFlag, () => {
      initDefaultName(props.options);
    });
    const stFlag = ref(0);
    watch(() => reactData.staticPanes ? reactData.staticPanes.length : -1, () => {
      stFlag.value++;
    });
    watch(() => reactData.staticPanes, () => {
      stFlag.value++;
    });
    watch(stFlag, () => {
      initDefaultName(reactData.staticPanes);
    });
    reactData.activeNames = props.modelValue || [];
    initDefaultName(reactData.staticPanes.length ? reactData.staticPanes : props.options);
    provide("$xeCollapse", $xeCollapse);
    $xeCollapse.renderVN = renderVN;
    return $xeCollapse;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/collapse/index.js
var VxeCollapse = Object.assign({}, collapse_default, {
  install(app) {
    app.component(collapse_default.name, collapse_default);
  }
});
dynamicApp.use(VxeCollapse);
VxeUI.component(collapse_default);
var Collapse = VxeCollapse;
var collapse_default2 = VxeCollapse;

// node_modules/vxe-pc-ui/es/collapse/src/collapse-pane.js
var import_xe_utils28 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/collapse/src/util.js
var import_xe_utils27 = __toESM(require_xe_utils());
function assembleCollapseItem($xeCollapse, elem, collapseConfig) {
  const staticPanes = $xeCollapse.reactData.staticPanes;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticPanes.splice(import_xe_utils27.default.arrayIndexOf(parentElem.children, elem), 0, collapseConfig);
    $xeCollapse.reactData.staticPanes = staticPanes.slice(0);
  }
}
function destroyCollapseItem($xeCollapse, collapseConfig) {
  const staticPanes = $xeCollapse.reactData.staticPanes;
  const matchObj = import_xe_utils27.default.findTree(staticPanes, (item) => item.id === collapseConfig.id, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeCollapse.reactData.staticPanes = staticPanes.slice(0);
}

// node_modules/vxe-pc-ui/es/collapse/src/collapse-pane.js
var collapse_pane_default = defineVxeComponent({
  name: "VxeCollapsePane",
  props: {
    title: [String, Number],
    name: [String, Number],
    icon: String,
    preload: Boolean,
    permissionCode: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils28.default.uniqueId();
    const $xeCollapse = inject("$xeCollapse", null);
    const refElem = ref();
    const reactData = reactive({});
    const collapseConfig = reactive({
      id: xID,
      title: props.title,
      name: props.name,
      icon: props.icon,
      preload: props.preload,
      permissionCode: props.permissionCode,
      slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCollapsePane = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $collapsePane: $xeCollapsePane }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeCollapsePane, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      return h("div", {
        ref: refElem
      }, []);
    };
    watch(() => props.title, (val) => {
      collapseConfig.title = val;
    });
    watch(() => props.name, (val) => {
      collapseConfig.name = val;
    });
    watch(() => props.icon, (val) => {
      collapseConfig.icon = val;
    });
    watch(() => props.permissionCode, (val) => {
      collapseConfig.permissionCode = val;
    });
    onMounted(() => {
      const elem = refElem.value;
      if ($xeCollapse && elem) {
        assembleCollapseItem($xeCollapse, elem, collapseConfig);
      }
    });
    onUnmounted(() => {
      if ($xeCollapse) {
        destroyCollapseItem($xeCollapse, collapseConfig);
      }
    });
    $xeCollapsePane.renderVN = renderVN;
    return $xeCollapsePane;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/collapse-pane/index.js
var VxeCollapsePane = Object.assign({}, collapse_pane_default, {
  install(app) {
    app.component(collapse_pane_default.name, collapse_pane_default);
  }
});
dynamicApp.use(VxeCollapsePane);
VxeUI.component(collapse_pane_default);
var CollapsePane = VxeCollapsePane;
var collapse_pane_default2 = VxeCollapsePane;

// node_modules/vxe-pc-ui/es/color-picker/src/color-picker.js
var import_xe_utils33 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/color-picker/src/util.js
var import_xe_utils29 = __toESM(require_xe_utils());
var hexAlphaKeyMaps = {};
var hexAlphaNumMaps = {};
"FF,FC,FA,F7,F5,F2,F0,ED,EB,E8,E6,E3,E0,DE,DB,D9,D6,D4,D1,CF,CC,C9,C7,C4,C2,BF,BD,BA,B8,B5,B3,B0,AD,AB,A8,A6,A3,A1,9E,9C,99,96,94,91,8F,8C,8A,87,85,82,80,7D,7A,78,75,73,70,6E,6B,69,66,63,61,5E,5C,59,57,54,52,4F,4D,4A,47,45,42,40,3D,3B,38,36,33,30,2E,2B,29,26,24,21,1F,1C,1A,17,14,12,0F,0D,0A,08,05,03,00".split(",").forEach((key, i) => {
  const num = (100 - i) / 100;
  hexAlphaKeyMaps[key] = num;
  hexAlphaNumMaps[num] = key;
});
var rgbRE = /^rgb(a?)\((\d{1,3})[,\s]+(\d{1,3})[,\s]+(\d{1,3})([,//\s]+([0-9.]{1,4})(%?))?\)$/;
var hexRE = /^(#?)([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
function parseColor(value) {
  const rest = {
    value: "",
    type: "",
    hex: "",
    hexV: "",
    hexA: "",
    r: 0,
    g: 0,
    b: 0,
    a: 1
  };
  if (value) {
    const hexRest = value.match(hexRE);
    if (hexRest) {
      rest.value = value;
      rest.type = "hex";
      rest.hex = value;
      rest.hexV = hexRest[2];
      rest.hexA = hexRest[3] || "";
      rest.a = (hexRest[3] ? hexAlphaKeyMaps[hexRest[3].toUpperCase()] : 1) || 1;
    }
    const rgbRest = value.match(rgbRE);
    if (rgbRest) {
      rest.value = value;
      rest.type = rgbRest[6] ? "rgba" : "rgb";
      rest.r = parseInt(rgbRest[2]);
      rest.g = parseInt(rgbRest[3]);
      rest.b = parseInt(rgbRest[4]);
      rest.a = rgbRest[7] ? parseInt(rgbRest[6]) / 100 : rgbRest[6] ? parseFloat(rgbRest[6]) : 1;
    }
  }
  return rest;
}
function updateColorAlpha(value, alpha = 1) {
  const colorRest = parseColor(value);
  const { type, hexV, r, g, b } = colorRest;
  if (type === "rgb" || type === "rgba") {
    return toRgb(r, g, b, alpha);
  }
  if (type === "hex") {
    return `#${hexV}${alpha === 1 ? "" : hexAlphaNumMaps[alpha] || ""}`;
  }
  return "";
}
function toRgb(r, g, b, a) {
  if (import_xe_utils29.default.eqNull(a)) {
    return `rgb(${r},${g},${b})`;
  }
  return `rgba(${r},${g},${b},${a})`;
}
function rgbToHex(rgbRest) {
  if (!rgbRest) {
    return "";
  }
  const { r, g, b, a = 1 } = rgbRest;
  const hexR = r.toString(16).padStart(2, "0");
  const hexG = g.toString(16).padStart(2, "0");
  const hexB = b.toString(16).padStart(2, "0");
  const hexA = a === 1 ? "" : hexAlphaNumMaps[a] || "";
  return `#${hexR}${hexG}${hexB}${hexA}`.toUpperCase();
}
function rgbToHsv(rgbRest) {
  if (!rgbRest) {
    return null;
  }
  const { r, g, b } = rgbRest;
  const rAbs = r / 255;
  const gAbs = g / 255;
  const bAbs = b / 255;
  let h2 = 0;
  let s = 0;
  const val = Math.max(rAbs, gAbs, bAbs);
  const num = val - Math.min(rAbs, gAbs, bAbs);
  const handleDiff = (c) => (val - c) / 6 / num + 1 / 2;
  if (num === 0) {
    h2 = s = 0;
  } else {
    s = num / val;
    const rr = handleDiff(rAbs);
    const gg = handleDiff(gAbs);
    const bb = handleDiff(bAbs);
    if (rAbs === val) {
      h2 = bb - gg;
    } else if (gAbs === val) {
      h2 = 1 / 3 + rr - bb;
    } else if (bAbs === val) {
      h2 = 2 / 3 + gg - rr;
    }
    if (h2 < 0) {
      h2 += 1;
    } else if (h2 > 1) {
      h2 -= 1;
    }
  }
  return {
    h: Math.round(h2 * 360),
    s: import_xe_utils29.default.round(s, 2),
    v: import_xe_utils29.default.round(val, 2)
  };
}
function hsvToRgb(h2, s, v) {
  let r = 0;
  let g = 0;
  let b = 0;
  const i = Math.floor(h2 / 60);
  const f = h2 / 60 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  switch (i) {
    case 0:
      r = v;
      g = t;
      b = p;
      break;
    case 1:
      r = q;
      g = v;
      b = p;
      break;
    case 2:
      r = p;
      g = v;
      b = t;
      break;
    case 3:
      r = p;
      g = q;
      b = v;
      break;
    case 4:
      r = t;
      g = p;
      b = v;
      break;
    case 5:
      r = v;
      g = p;
      b = q;
      break;
  }
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}
function hexToHsv(str) {
  const rgbRest = hexToRgb(str);
  if (rgbRest) {
    return rgbToHsv(rgbRest);
  }
  return null;
}
function hexToRgb(str) {
  if (str) {
    const rests = str.match(/^(#?)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})?$/);
    if (rests) {
      return {
        r: parseInt(rests[2], 16),
        g: parseInt(rests[3], 16),
        b: parseInt(rests[4], 16),
        a: (rests[5] ? hexAlphaKeyMaps[rests[5].toUpperCase()] : 1) || 1
      };
    }
  }
  return null;
}

// node_modules/vxe-pc-ui/es/input/src/input.js
var import_xe_utils31 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/number-input/src/util.js
var import_xe_utils30 = __toESM(require_xe_utils());
function handleNumber(val) {
  return import_xe_utils30.default.isString(val) ? val.replace(/[^0-9e.-]/g, "") : val;
}
function toFloatValueFixed(inputValue, digitsValue) {
  if (/^-/.test("" + inputValue)) {
    return import_xe_utils30.default.toFixed(import_xe_utils30.default.ceil(inputValue, digitsValue), digitsValue);
  }
  return import_xe_utils30.default.toFixed(import_xe_utils30.default.floor(inputValue, digitsValue), digitsValue);
}

// node_modules/vxe-pc-ui/es/input/src/input.js
var input_default = defineVxeComponent({
  name: "VxeInput",
  props: {
    modelValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    title: String,
    type: {
      type: String,
      default: "text"
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().input.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: {
      type: String,
      default: null
    },
    maxLength: {
      type: [String, Number],
      default: () => getConfig().input.maxLength
    },
    autoComplete: {
      type: String,
      default: "off"
    },
    autoFocus: {
      type: Boolean,
      default: null
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => getConfig().input.size || getConfig().size
    },
    multiple: Boolean,
    // text
    showWordCount: Boolean,
    countMethod: Function,
    // number、integer、float
    min: {
      type: [String, Number],
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    step: [String, Number],
    trim: {
      type: Boolean,
      default: () => getConfig().input.trim
    },
    exponential: {
      type: Boolean,
      default: () => getConfig().input.exponential
    },
    // number、integer、float、password
    controls: {
      type: Boolean,
      default: () => getConfig().input.controls
    },
    // float
    digits: {
      type: [String, Number],
      default: () => getConfig().input.digits
    },
    // date、week、month、quarter、year
    startDate: {
      type: [String, Number, Date],
      default: () => getConfig().input.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => getConfig().input.endDate
    },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    // 已废弃 startWeek，被 startDay 替换
    startWeek: Number,
    startDay: {
      type: [String, Number],
      default: () => getConfig().input.startDay
    },
    labelFormat: String,
    valueFormat: String,
    editable: {
      type: Boolean,
      default: true
    },
    festivalMethod: {
      type: Function,
      default: () => getConfig().input.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().input.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().input.selectDay
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    // 已废弃
    maxlength: [String, Number],
    // 已废弃
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "wheel",
    "click",
    "focus",
    "blur",
    "clear",
    "lazy-change",
    "search-click",
    "toggle-visible",
    "prev-number",
    "next-number",
    "prefix-click",
    "suffix-click",
    "date-prev",
    "date-today",
    "date-next"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeSelect = inject("$xeSelect", null);
    const $xeTreeSelect = inject("$xeTreeSelect", null);
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils31.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      panelIndex: 0,
      showPwd: false,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: {},
      panelPlacement: "",
      isActivated: false,
      inputValue: props.modelValue,
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    });
    const internalData = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8,
      hpTimeout: void 0,
      dnTimeout: void 0
    };
    const refElem = ref();
    const refInputTarget = ref();
    const refInputPanel = ref();
    const refPanelWrapper = ref();
    const refInputTimeBody = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeInput = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let inputMethods = {};
    const parseDate = (value, format) => {
      const { type } = props;
      if (type === "time") {
        return toStringTimeDate(value);
      }
      return import_xe_utils31.default.toStringDate(value, format);
    };
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().input.transfer;
        if (import_xe_utils31.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeFormReadonly = computed(() => {
      if ($xeForm) {
        return $xeForm.props.readonly;
      }
      return false;
    });
    const computeIsReadonly = computed(() => {
      const { readonly } = props;
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeInpMaxLength = computed(() => {
      const { maxLength, maxlength } = props;
      const maxLen = maxLength || maxlength;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        if (!import_xe_utils31.default.toNumber(maxLen)) {
          return 16;
        }
      }
      return maxLen;
    });
    const computeIsDateTimeType = computed(() => {
      const { type } = props;
      return type === "time" || type === "datetime";
    });
    const computeIsNumType = computed(() => {
      return ["number", "integer", "float"].indexOf(props.type) > -1;
    });
    const computeInputCount = computed(() => {
      return import_xe_utils31.default.getSize(reactData.inputValue);
    });
    const computeIsCountError = computed(() => {
      const inputCount = computeInputCount.value;
      const inpMaxLength = computeInpMaxLength.value;
      return inpMaxLength && inputCount > import_xe_utils31.default.toNumber(inpMaxLength);
    });
    const computeIsDatePickerType = computed(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeIsPawdType = computed(() => {
      return props.type === "password";
    });
    const computeIsSearchType = computed(() => {
      return props.type === "search";
    });
    const computeDigitsValue = computed(() => {
      return import_xe_utils31.default.toInteger(props.digits) || 1;
    });
    const computeStepValue = computed(() => {
      const { type } = props;
      const digitsValue = computeDigitsValue.value;
      const step = props.step;
      if (type === "integer") {
        return import_xe_utils31.default.toInteger(step) || 1;
      } else if (type === "float") {
        return import_xe_utils31.default.toNumber(step) || 1 / Math.pow(10, digitsValue);
      }
      return import_xe_utils31.default.toNumber(step) || 1;
    });
    const computeIsClearable = computed(() => {
      const { type } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      return props.clearable && (isPawdType || isNumType || isDatePickerType || type === "text" || type === "search");
    });
    const computeDateStartTime = computed(() => {
      return props.startDate ? import_xe_utils31.default.toStringDate(props.startDate) : null;
    });
    const computeDateEndTime = computed(() => {
      return props.endDate ? import_xe_utils31.default.toStringDate(props.endDate) : null;
    });
    const computeSupportMultiples = computed(() => {
      return ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeDateListValue = computed(() => {
      const { modelValue, multiple } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue && isDatePickerType) {
        return import_xe_utils31.default.toValueString(modelValue).split(",").map((item) => {
          const date = parseDate(item, dateValueFormat);
          if (import_xe_utils31.default.isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    const computeDateMultipleValue = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map((date) => import_xe_utils31.default.toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map((date) => import_xe_utils31.default.toDateString(date, dateLabelFormat)).join(", ");
    });
    const computeDateValueFormat = computed(() => {
      const { type, valueFormat } = props;
      if (valueFormat) {
        return valueFormat;
      }
      if (type === "time") {
        return "HH:mm:ss";
      }
      if (type === "datetime") {
        return "yyyy-MM-dd HH:mm:ss";
      }
      return "yyyy-MM-dd";
    });
    const computeDateValue = computed(() => {
      const { modelValue } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (modelValue && isDatePickerType) {
        const date = parseDate(modelValue, dateValueFormat);
        if (import_xe_utils31.default.isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = computed(() => {
      const dateStartTime = computeDateStartTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = computed(() => {
      const dateEndTime = computeDateEndTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateTimeLabel = computed(() => {
      const { datetimePanelValue } = reactData;
      const hasTimeSecond = computeHasTimeSecond.value;
      if (datetimePanelValue) {
        return import_xe_utils31.default.toDateString(datetimePanelValue, hasTimeSecond ? "HH:mm:ss" : "HH:mm");
      }
      return "";
    });
    const computeDateHMSTime = computed(() => {
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1e3 : 0;
    });
    const computeDateLabelFormat = computed(() => {
      const { labelFormat } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        return labelFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return "";
    });
    const computeYearList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { yearSize } = internalData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index = -4; index < yearSize + 4; index++) {
          const date = import_xe_utils31.default.getWhatYear(startYearDate, index, "first");
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelObj = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      let y = "";
      let m = "";
      if (isDatePickerType) {
        const { datePanelType, selectMonth } = reactData;
        const yearList = computeYearList.value;
        let year = "";
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === "quarter" || datePanelType === "month") {
          y = getI18n("vxe.datePicker.yearTitle", [year]);
        } else if (datePanelType === "year") {
          y = yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : "";
        } else {
          y = getI18n("vxe.datePicker.yearTitle", [year]);
          m = month ? getI18n(`vxe.input.date.m${month}`) : "-";
        }
      }
      return {
        y,
        m
      };
    });
    const computeFirstDayOfWeek = computed(() => {
      const { startDay, startWeek } = props;
      return import_xe_utils31.default.toNumber(import_xe_utils31.default.isNumber(startDay) || import_xe_utils31.default.isString(startDay) ? startDay : startWeek);
    });
    const computeWeekDatas = computed(() => {
      const weeks = [];
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map((day) => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const dateHeaders = computeDateHeaders.value;
        return [{ label: getI18n("vxe.input.date.weeks.w") }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = computed(() => {
      const yearList = computeYearList.value;
      return import_xe_utils31.default.chunk(yearList, 4);
    });
    const computeQuarterList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { quarterSize } = internalData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = import_xe_utils31.default.getWhatYear(selectMonth, 0, "first");
        const selFullYear = firstYear.getFullYear();
        for (let index = -2; index < quarterSize - 2; index++) {
          const date = import_xe_utils31.default.getWhatQuarter(firstYear, index);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = computed(() => {
      const quarterList = computeQuarterList.value;
      return import_xe_utils31.default.chunk(quarterList, 2);
    });
    const computeMonthList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { monthSize } = internalData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = import_xe_utils31.default.getWhatYear(selectMonth, 0, "first").getFullYear();
        for (let index = -4; index < monthSize - 4; index++) {
          const date = import_xe_utils31.default.getWhatYear(selectMonth, 0, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = computed(() => {
      const monthList = computeMonthList.value;
      return import_xe_utils31.default.chunk(monthList, 4);
    });
    const computeDayList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(import_xe_utils31.default.getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index = 0; index < 42; index++) {
          const date = import_xe_utils31.default.getWhatDay(startDayDate, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = computed(() => {
      const dayList = computeDayList.value;
      return import_xe_utils31.default.chunk(dayList, 7);
    });
    const computeWeekDates = computed(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map((list) => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: import_xe_utils31.default.getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const computeHourList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 24; index++) {
          list.push({
            value: index,
            label: ("" + index).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeMinuteList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 60; index++) {
          list.push({
            value: index,
            label: ("" + index).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeHasTimeMinute = computed(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /mm/.test(dateValueFormat);
    });
    const computeHasTimeSecond = computed(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /ss/.test(dateValueFormat);
    });
    const computeSecondList = computed(() => {
      const minuteList = computeMinuteList.value;
      return minuteList;
    });
    const computeInputReadonly = computed(() => {
      const { type, editable, multiple } = props;
      const isReadonly = computeIsReadonly.value;
      return isReadonly || multiple || !editable || type === "week" || type === "quarter";
    });
    const computeInputType = computed(() => {
      const { type } = props;
      const { showPwd } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      if (isDatePickerType || isNumType || isPawdType && showPwd || type === "number") {
        return "text";
      }
      return type;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      if (import_xe_utils31.default.eqNull(placeholder)) {
        const globalPlaceholder = getConfig().input.placeholder;
        if (globalPlaceholder) {
          return getFuncText(globalPlaceholder);
        }
        return getI18n("vxe.base.pleaseInput");
      }
      return placeholder;
    });
    const computeInpImmediate = computed(() => {
      const { type, immediate } = props;
      return immediate || !(type === "text" || type === "number" || type === "integer" || type === "float");
    });
    const computeNumValue = computed(() => {
      const { type } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        return type === "integer" ? import_xe_utils31.default.toInteger(handleNumber(inputValue)) : import_xe_utils31.default.toNumber(handleNumber(inputValue));
      }
      return 0;
    });
    const computeIsDisabledSubtractNumber = computed(() => {
      const { min } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && isNumType && min !== null) {
        return numValue <= import_xe_utils31.default.toNumber(min);
      }
      return false;
    });
    const computeIsDisabledAddNumber = computed(() => {
      const { max } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && isNumType && max !== null) {
        return numValue >= import_xe_utils31.default.toNumber(max);
      }
      return false;
    });
    const getNumberValue = (val) => {
      const { type, exponential } = props;
      const inpMaxLength = computeInpMaxLength.value;
      const digitsValue = computeDigitsValue.value;
      const restVal = type === "float" ? toFloatValueFixed(val, digitsValue) : import_xe_utils31.default.toValueString(val);
      if (exponential && (val === restVal || import_xe_utils31.default.toValueString(val).toLowerCase() === import_xe_utils31.default.toNumber(restVal).toExponential())) {
        return val;
      }
      return restVal.slice(0, inpMaxLength);
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const triggerEvent = (evnt) => {
      const { inputValue } = reactData;
      inputMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const handleChange = (value, evnt) => {
      if (props.trim) {
        value = `${value || ""}`.trim();
      }
      reactData.inputValue = value;
      emitModel(value);
      inputMethods.dispatchEvent("input", { value }, evnt);
      if (import_xe_utils31.default.toValueString(props.modelValue) !== value) {
        inputMethods.dispatchEvent("change", { value }, evnt);
        if (!$xeSelect && !$xeTreeSelect) {
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
          }
        }
      }
    };
    const emitInputEvent = (value, evnt) => {
      const isDatePickerType = computeIsDatePickerType.value;
      const inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (!isDatePickerType) {
        if (inpImmediate) {
          handleChange(value, evnt);
        } else {
          inputMethods.dispatchEvent("input", { value }, evnt);
        }
      }
    };
    const inputEvent = (evnt) => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const changeEvent = (evnt) => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
      $xeInput.dispatchEvent("lazy-change", { value: reactData.inputValue }, evnt);
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue;
      if (!inpImmediate) {
        handleChange(value, evnt);
      }
      afterCheckValue();
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      inputMethods.dispatchEvent("blur", { value }, evnt);
      if (!$xeSelect && !$xeTreeSelect) {
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const focusEvent = (evnt) => {
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      reactData.isActivated = true;
      if (isNumType) {
        reactData.inputValue = eqEmptyValue(inputValue) ? "" : `${import_xe_utils31.default.toNumber(inputValue)}`;
      } else if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent(evnt);
    };
    const clickPrefixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        $xeInput.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    const hidePanel = () => {
      return new Promise((resolve) => {
        reactData.visiblePanel = false;
        internalData.hpTimeout = setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const { type, autoFocus } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      if (autoFocus || autoFocus === null) {
        if (isNumType || ["text", "search", "password"].indexOf(type) > -1) {
          focus();
        }
      }
      handleChange("", evnt);
      $xeInput.dispatchEvent("clear", { value }, evnt);
      $xeInput.dispatchEvent("lazy-change", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        $xeInput.dispatchEvent("suffix-click", { value: inputValue }, evnt);
      }
    };
    const dateParseValue = (value) => {
      const { type } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = "";
      if (value) {
        dValue = parseDate(value, dateValueFormat);
      }
      if (import_xe_utils31.default.isValidDate(dValue)) {
        dLabel = import_xe_utils31.default.toDateString(dValue, dateLabelFormat, { firstDay: firstDayOfWeek });
        if (dateLabelFormat && type === "week") {
          const weekNum = import_xe_utils31.default.getYearWeek(dValue, firstDayOfWeek);
          const weekDate = import_xe_utils31.default.getWhatWeek(dValue, 0, weekNum === 1 ? (6 + firstDayOfWeek) % 7 : firstDayOfWeek, firstDayOfWeek);
          const weekFullYear = weekDate.getFullYear();
          if (weekFullYear !== dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf("yyyy");
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${weekFullYear}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    const changeValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      const { inputValue } = reactData;
      if (isDatePickerType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    const initValue = () => {
      const { type } = props;
      const { inputValue } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const digitsValue = computeDigitsValue.value;
      if (isDatePickerType) {
        changeValue();
      } else if (type === "float") {
        if (inputValue) {
          const validValue = toFloatValueFixed(inputValue, digitsValue);
          if (inputValue !== validValue) {
            handleChange(validValue, { type: "init" });
          }
        }
      }
    };
    const validMaxNum = (num) => {
      return props.max === null || props.max === "" || import_xe_utils31.default.toNumber(num) <= import_xe_utils31.default.toNumber(props.max);
    };
    const validMinNum = (num) => {
      return props.min === null || props.min === "" || import_xe_utils31.default.toNumber(num) >= import_xe_utils31.default.toNumber(props.min);
    };
    const dateRevert = () => {
      reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    const dateCheckMonth = (date) => {
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const weekNum = import_xe_utils31.default.getYearWeek(date, firstDayOfWeek);
      const weekStartDate = import_xe_utils31.default.getWhatWeek(date, 0, firstDayOfWeek, firstDayOfWeek);
      const month = import_xe_utils31.default.getWhatMonth(weekNum === 1 ? import_xe_utils31.default.getWhatDay(weekStartDate, 6) : date, 0, "first");
      if (!import_xe_utils31.default.isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = (date) => {
      const { modelValue, multiple } = props;
      const { datetimePanelValue } = reactData;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === "week") {
        const sWeek = import_xe_utils31.default.toNumber(props.selectDay);
        date = import_xe_utils31.default.getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        date.setHours(datetimePanelValue.getHours());
        date.setMinutes(datetimePanelValue.getMinutes());
        date.setSeconds(datetimePanelValue.getSeconds());
      }
      const inpVal = import_xe_utils31.default.toDateString(date, dateValueFormat, { firstDay: firstDayOfWeek });
      dateCheckMonth(date);
      if (multiple) {
        const dateMultipleValue = computeDateMultipleValue.value;
        if (isDateTimeType) {
          const dateListValue = [...computeDateListValue.value];
          const datetimeRest = [];
          const eqIndex = import_xe_utils31.default.findIndexOf(dateListValue, (val) => import_xe_utils31.default.isDateSame(date, val, "yyyyMMdd"));
          if (eqIndex === -1) {
            dateListValue.push(date);
          } else {
            dateListValue.splice(eqIndex, 1);
          }
          dateListValue.forEach((item) => {
            if (item) {
              item.setHours(datetimePanelValue.getHours());
              item.setMinutes(datetimePanelValue.getMinutes());
              item.setSeconds(datetimePanelValue.getSeconds());
              datetimeRest.push(item);
            }
          });
          handleChange(datetimeRest.map((date2) => import_xe_utils31.default.toDateString(date2, dateValueFormat)).join(","), { type: "update" });
        } else {
          if (dateMultipleValue.some((val) => import_xe_utils31.default.isEqual(val, inpVal))) {
            handleChange(dateMultipleValue.filter((val) => !import_xe_utils31.default.isEqual(val, inpVal)).join(","), { type: "update" });
          } else {
            handleChange(dateMultipleValue.concat([inpVal]).join(","), { type: "update" });
          }
        }
      } else {
        if (!import_xe_utils31.default.isEqual(modelValue, inpVal)) {
          handleChange(inpVal, { type: "update" });
        }
      }
    };
    const afterCheckValue = () => {
      const { type, min, max, exponential } = props;
      const { inputValue, datetimePanelValue } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (isNumType) {
          if (inputValue) {
            const inpVal = `${handleNumber(inputValue)}`;
            if (inpVal) {
              let inpNumVal = type === "integer" ? import_xe_utils31.default.toInteger(inpVal) : import_xe_utils31.default.toNumber(inpVal);
              if (!validMinNum(inpNumVal)) {
                inpNumVal = min;
              } else if (!validMaxNum(inpNumVal)) {
                inpNumVal = max;
              }
              if (exponential) {
                const inpStringVal = import_xe_utils31.default.toValueString(inputValue).toLowerCase();
                if (inpStringVal === import_xe_utils31.default.toNumber(inpNumVal).toExponential()) {
                  inpNumVal = inpStringVal;
                }
              }
              handleChange(getNumberValue(inpNumVal), { type: "check" });
            } else {
              let inpValue = "";
              if (min || min === 0) {
                inpValue = `${min}`;
              }
              handleChange(inpValue, { type: "check" });
            }
          }
        } else if (isDatePickerType) {
          if (inputValue) {
            let inpDateVal = parseDate(inputValue, dateLabelFormat);
            if (import_xe_utils31.default.isValidDate(inpDateVal)) {
              if (type === "time") {
                inpDateVal = import_xe_utils31.default.toDateString(inpDateVal, dateLabelFormat);
                if (inputValue !== inpDateVal) {
                  handleChange(inpDateVal, { type: "check" });
                }
                reactData.inputValue = inpDateVal;
              } else {
                let isChange = false;
                const firstDayOfWeek = computeFirstDayOfWeek.value;
                if (type === "datetime") {
                  const dateValue = computeDateValue.value;
                  if (inputValue !== import_xe_utils31.default.toDateString(dateValue, dateLabelFormat) || inputValue !== import_xe_utils31.default.toDateString(inpDateVal, dateLabelFormat)) {
                    isChange = true;
                    datetimePanelValue.setHours(inpDateVal.getHours());
                    datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                    datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                  }
                } else {
                  isChange = true;
                }
                reactData.inputValue = import_xe_utils31.default.toDateString(inpDateVal, dateLabelFormat, { firstDay: firstDayOfWeek });
                if (isChange) {
                  dateChange(inpDateVal);
                }
              }
            } else {
              dateRevert();
            }
          } else {
            handleChange("", { type: "check" });
          }
        }
      }
    };
    const passwordToggleEvent = (evnt) => {
      const { showPwd } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!isDisabled && !isReadonly) {
        reactData.showPwd = !showPwd;
      }
      inputMethods.dispatchEvent("toggle-visible", { visible: reactData.showPwd }, evnt);
    };
    const searchEvent = (evnt) => {
      inputMethods.dispatchEvent("search-click", {}, evnt);
    };
    const numberChange = (isPlus, evnt) => {
      const { min, max, type } = props;
      const { inputValue } = reactData;
      const stepValue = computeStepValue.value;
      const numValue = type === "integer" ? import_xe_utils31.default.toInteger(handleNumber(inputValue)) : import_xe_utils31.default.toNumber(handleNumber(inputValue));
      const newValue = isPlus ? import_xe_utils31.default.add(numValue, stepValue) : import_xe_utils31.default.subtract(numValue, stepValue);
      let restNum;
      if (!validMinNum(newValue)) {
        restNum = min;
      } else if (!validMaxNum(newValue)) {
        restNum = max;
      } else {
        restNum = newValue;
      }
      emitInputEvent(getNumberValue(restNum), evnt);
    };
    const numberNextEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      numberStopDown();
      if (!isDisabled && !isReadonly && !isDisabledSubtractNumber) {
        numberChange(false, evnt);
      }
      inputMethods.dispatchEvent("next-number", { value: reactData.inputValue }, evnt);
    };
    const numberDownNextEvent = (evnt) => {
      internalData.dnTimeout = setTimeout(() => {
        numberNextEvent(evnt);
        numberDownNextEvent(evnt);
      }, 60);
    };
    const numberPrevEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      numberStopDown();
      if (!isDisabled && !isReadonly && !isDisabledAddNumber) {
        numberChange(true, evnt);
      }
      inputMethods.dispatchEvent("prev-number", { value: reactData.inputValue }, evnt);
    };
    const numberKeydownEvent = (evnt) => {
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (isUpArrow || isDwArrow) {
        evnt.preventDefault();
        if (isUpArrow) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
      }
    };
    const keydownEvent = (evnt) => {
      const { type, exponential, controls } = props;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        const isControlKey = hasControlKey(evnt);
        const isShiftKey = evnt.shiftKey;
        const isAltKey = evnt.altKey;
        const keyCode = evnt.keyCode;
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        if (!isControlKey && !isShiftKey && !isAltKey) {
          if (globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR) || type === "integer" && keyCode === 110 || (!exponential || keyCode !== 69) && (keyCode >= 65 && keyCode <= 90) || keyCode >= 186 && keyCode <= 188 || keyCode >= 191) {
            evnt.preventDefault();
          }
        }
        if (isEsc) {
          afterCheckValue();
        } else if (isUpArrow || isDwArrow) {
          if (controls) {
            numberKeydownEvent(evnt);
          }
        }
      }
      triggerEvent(evnt);
    };
    const keyupEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const numberStopDown = () => {
      const { dnTimeout } = internalData;
      if (dnTimeout) {
        clearTimeout(dnTimeout);
        internalData.dnTimeout = void 0;
      }
    };
    const numberDownPrevEvent = (evnt) => {
      internalData.dnTimeout = setTimeout(() => {
        numberPrevEvent(evnt);
        numberDownPrevEvent(evnt);
      }, 60);
    };
    const numberMousedownEvent = (evnt) => {
      numberStopDown();
      if (evnt.button === 0) {
        const isPrevNumber = hasClass(evnt.currentTarget, "is--prev");
        if (isPrevNumber) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
        internalData.dnTimeout = setTimeout(() => {
          if (isPrevNumber) {
            numberDownPrevEvent(evnt);
          } else {
            numberDownNextEvent(evnt);
          }
        }, 500);
      }
    };
    const wheelEvent = (evnt) => {
      const isNumType = computeIsNumType.value;
      if (isNumType && props.controls) {
        if (reactData.isActivated) {
          const delta = evnt.deltaY;
          if (delta > 0) {
            numberNextEvent(evnt);
          } else if (delta < 0) {
            numberPrevEvent(evnt);
          }
          evnt.preventDefault();
        }
      }
      triggerEvent(evnt);
    };
    const dateMonthHandle = (date, offsetMonth) => {
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const weekNum = import_xe_utils31.default.getYearWeek(date, firstDayOfWeek);
      const weekStartDate = import_xe_utils31.default.getWhatWeek(date, 0, firstDayOfWeek, firstDayOfWeek);
      const month = import_xe_utils31.default.getWhatMonth(weekNum === 1 ? import_xe_utils31.default.getWhatDay(weekStartDate, 6) : date, offsetMonth, "first");
      reactData.selectMonth = month;
    };
    const dateNowHandle = () => {
      const currentDate = import_xe_utils31.default.getWhatDay(Date.now(), 0, "first");
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleYearTypeEvent = () => {
      reactData.datePanelType = "year";
    };
    const dateToggleMonthTypeEvent = () => {
      let { datePanelType } = reactData;
      if (datePanelType === "month" || datePanelType === "quarter") {
        datePanelType = "year";
      } else {
        datePanelType = "month";
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth, inputValue } = reactData;
      const { yearSize } = internalData;
      const value = inputValue;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        let viewDate;
        if (type === "year") {
          viewDate = import_xe_utils31.default.getWhatYear(selectMonth, -yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            viewDate = import_xe_utils31.default.getWhatYear(selectMonth, -yearSize, "first");
          } else {
            viewDate = import_xe_utils31.default.getWhatYear(selectMonth, -1, "first");
          }
        } else {
          if (datePanelType === "year") {
            viewDate = import_xe_utils31.default.getWhatYear(selectMonth, -yearSize, "first");
          } else if (datePanelType === "month") {
            viewDate = import_xe_utils31.default.getWhatYear(selectMonth, -1, "first");
          } else {
            viewDate = import_xe_utils31.default.getWhatMonth(selectMonth, -1, "first");
          }
        }
        reactData.selectMonth = viewDate;
        inputMethods.dispatchEvent("date-prev", { viewType: datePanelType, viewDate, value, type }, evnt);
      }
    };
    const dateTodayMonthEvent = (evnt) => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
        hidePanel();
      }
      inputMethods.dispatchEvent("date-today", { type: props.type }, evnt);
    };
    const dateNextEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth, inputValue } = reactData;
      const { yearSize } = internalData;
      const value = inputValue;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        let viewDate;
        if (type === "year") {
          viewDate = import_xe_utils31.default.getWhatYear(selectMonth, yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            viewDate = import_xe_utils31.default.getWhatYear(selectMonth, yearSize, "first");
          } else {
            viewDate = import_xe_utils31.default.getWhatYear(selectMonth, 1, "first");
          }
        } else {
          if (datePanelType === "year") {
            viewDate = import_xe_utils31.default.getWhatYear(selectMonth, yearSize, "first");
          } else if (datePanelType === "month") {
            viewDate = import_xe_utils31.default.getWhatYear(selectMonth, 1, "first");
          } else {
            viewDate = import_xe_utils31.default.getWhatMonth(selectMonth, 1, "first");
          }
        }
        reactData.selectMonth = viewDate;
        inputMethods.dispatchEvent("date-next", { viewType: datePanelType, viewDate, value, type }, evnt);
      }
    };
    const isDateDisabled = (item) => {
      const { disabledMethod } = props;
      const { datePanelType } = reactData;
      const dateStartTime = computeDateStartTime.value;
      const dateEndTime = computeDateEndTime.value;
      const { date } = item;
      if (dateStartTime && dateStartTime.getTime() > date.getTime()) {
        return true;
      }
      if (dateEndTime && dateEndTime.getTime() < date.getTime()) {
        return true;
      }
      if (disabledMethod) {
        return disabledMethod({ type: datePanelType, viewType: datePanelType, date, $input: $xeInput });
      }
      return false;
    };
    const dateSelectItem = (date) => {
      const { type, multiple } = props;
      const { datePanelType } = reactData;
      if (type === "month") {
        if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type === "year") {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type === "quarter") {
        if (datePanelType === "year") {
          reactData.datePanelType = "quarter";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === "month") {
          reactData.datePanelType = type === "week" ? type : "day";
          dateCheckMonth(date);
        } else if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (type === "datetime") {
          } else {
            if (!multiple) {
              hidePanel();
            }
          }
        }
      }
    };
    const dateSelectEvent = (item) => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = (offsetDay) => {
      if (!isDateDisabled({ date: offsetDay })) {
        const dayList = computeDayList.value;
        if (!dayList.some((item) => import_xe_utils31.default.isDateSame(item.date, offsetDay, "yyyyMMdd"))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = (offsetYear) => {
      if (!isDateDisabled({ date: offsetYear })) {
        const yearList = computeYearList.value;
        if (!yearList.some((item) => import_xe_utils31.default.isDateSame(item.date, offsetYear, "yyyy"))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = (offsetQuarter) => {
      if (!isDateDisabled({ date: offsetQuarter })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some((item) => import_xe_utils31.default.isDateSame(item.date, offsetQuarter, "yyyyq"))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = (offsetMonth) => {
      if (!isDateDisabled({ date: offsetMonth })) {
        const monthList = computeMonthList.value;
        if (!monthList.some((item) => import_xe_utils31.default.isDateSame(item.date, offsetMonth, "yyyyMM"))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = (item) => {
      if (!isDateDisabled(item)) {
        const { datePanelType } = reactData;
        if (datePanelType === "month") {
          dateMoveMonth(item.date);
        } else if (datePanelType === "quarter") {
          dateMoveQuarter(item.date);
        } else if (datePanelType === "year") {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const updateTimePos = (liElem) => {
      if (liElem) {
        const height = liElem.offsetHeight;
        const ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height * 4;
      }
    };
    const dateTimeChangeEvent = (evnt) => {
      reactData.datetimePanelValue = new Date(reactData.datetimePanelValue.getTime());
      updateTimePos(evnt.currentTarget);
    };
    const dateHourEvent = (evnt, item) => {
      reactData.datetimePanelValue.setHours(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateConfirmEvent = () => {
      const { multiple } = props;
      const { datetimePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        const dateValueFormat = computeDateValueFormat.value;
        if (multiple) {
          const dateMultipleValue = computeDateMultipleValue.value;
          if (isDateTimeType) {
            const dateListValue = [...computeDateListValue.value];
            const datetimeRest = [];
            dateListValue.forEach((item) => {
              if (item) {
                item.setHours(datetimePanelValue.getHours());
                item.setMinutes(datetimePanelValue.getMinutes());
                item.setSeconds(datetimePanelValue.getSeconds());
                datetimeRest.push(item);
              }
            });
            handleChange(datetimeRest.map((date) => import_xe_utils31.default.toDateString(date, dateValueFormat)).join(","), { type: "update" });
          } else {
            handleChange(dateMultipleValue.join(","), { type: "update" });
          }
        } else {
          dateChange(dateValue || reactData.currentDate);
        }
      }
      hidePanel();
    };
    const dateMinuteEvent = (evnt, item) => {
      reactData.datetimePanelValue.setMinutes(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateSecondEvent = (evnt, item) => {
      reactData.datetimePanelValue.setSeconds(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateOffsetEvent = (evnt) => {
      const { isActivated, datePanelValue, datePanelType } = reactData;
      if (isActivated) {
        evnt.preventDefault();
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        if (datePanelType === "year") {
          let offsetYear = import_xe_utils31.default.getWhatYear(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetYear = import_xe_utils31.default.getWhatYear(offsetYear, -1);
          } else if (isUpArrow) {
            offsetYear = import_xe_utils31.default.getWhatYear(offsetYear, -4);
          } else if (isRightArrow) {
            offsetYear = import_xe_utils31.default.getWhatYear(offsetYear, 1);
          } else if (isDwArrow) {
            offsetYear = import_xe_utils31.default.getWhatYear(offsetYear, 4);
          }
          dateMoveYear(offsetYear);
        } else if (datePanelType === "quarter") {
          let offsetQuarter = import_xe_utils31.default.getWhatQuarter(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetQuarter = import_xe_utils31.default.getWhatQuarter(offsetQuarter, -1);
          } else if (isUpArrow) {
            offsetQuarter = import_xe_utils31.default.getWhatQuarter(offsetQuarter, -2);
          } else if (isRightArrow) {
            offsetQuarter = import_xe_utils31.default.getWhatQuarter(offsetQuarter, 1);
          } else if (isDwArrow) {
            offsetQuarter = import_xe_utils31.default.getWhatQuarter(offsetQuarter, 2);
          }
          dateMoveQuarter(offsetQuarter);
        } else if (datePanelType === "month") {
          let offsetMonth = import_xe_utils31.default.getWhatMonth(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetMonth = import_xe_utils31.default.getWhatMonth(offsetMonth, -1);
          } else if (isUpArrow) {
            offsetMonth = import_xe_utils31.default.getWhatMonth(offsetMonth, -4);
          } else if (isRightArrow) {
            offsetMonth = import_xe_utils31.default.getWhatMonth(offsetMonth, 1);
          } else if (isDwArrow) {
            offsetMonth = import_xe_utils31.default.getWhatMonth(offsetMonth, 4);
          }
          dateMoveMonth(offsetMonth);
        } else {
          let offsetDay = datePanelValue || import_xe_utils31.default.getWhatDay(Date.now(), 0, "first");
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          if (isLeftArrow) {
            offsetDay = import_xe_utils31.default.getWhatDay(offsetDay, -1);
          } else if (isUpArrow) {
            offsetDay = import_xe_utils31.default.getWhatWeek(offsetDay, -1, firstDayOfWeek);
          } else if (isRightArrow) {
            offsetDay = import_xe_utils31.default.getWhatDay(offsetDay, 1);
          } else if (isDwArrow) {
            offsetDay = import_xe_utils31.default.getWhatWeek(offsetDay, 1, firstDayOfWeek);
          }
          dateMoveDay(offsetDay);
        }
      }
    };
    const datePgOffsetEvent = (evnt) => {
      const { isActivated } = reactData;
      if (isActivated) {
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        evnt.preventDefault();
        if (isPgUp) {
          datePrevEvent(evnt);
        } else {
          dateNextEvent(evnt);
        }
      }
    };
    const dateOpenPanel = () => {
      const { type } = props;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValue = computeDateValue.value;
      if (["year", "quarter", "month", "week"].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = "day";
      }
      reactData.currentDate = import_xe_utils31.default.getWhatDay(Date.now(), 0, "first");
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
      if (isDateTimeType) {
        reactData.datetimePanelValue = reactData.datePanelValue || import_xe_utils31.default.getWhatDay(Date.now(), 0, "first");
        nextTick(() => {
          const timeBodyElem = refInputTimeBody.value;
          import_xe_utils31.default.arrayEach(timeBodyElem.querySelectorAll("li.is--selected"), (elem) => {
            updateTimePos(elem);
          });
        });
      }
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const targetElem = refInputTarget.value;
        const panelElem = refInputPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (targetElem && panelElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(targetElem);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              panelStyle.top = `${targetHeight}px`;
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.top = "";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showPanel = () => {
      const { visiblePanel } = reactData;
      const { hpTimeout } = internalData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = void 0;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (isDatePickerType) {
          dateOpenPanel();
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return nextTick();
    };
    const datePickerOpenEvent = (evnt) => {
      const isReadonly = computeIsReadonly.value;
      if (!isReadonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel, isActivated } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const el = refElem.value;
      const panelWrapperElem = refPanelWrapper.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          if (isDatePickerType) {
            if (visiblePanel) {
              hidePanel();
              afterCheckValue();
            }
          } else {
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        const isPgDn = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_DOWN);
        const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        } else if (operArrow) {
          if (isDatePickerType) {
            if (isActivated) {
              if (visiblePanel) {
                dateOffsetEvent(evnt);
              } else if (isUpArrow || isDwArrow) {
                datePickerOpenEvent(evnt);
              }
            }
          }
        } else if (isEnter) {
          if (isDatePickerType) {
            if (visiblePanel) {
              if (reactData.datePanelValue) {
                dateSelectItem(reactData.datePanelValue);
              } else {
                hidePanel();
              }
            } else if (isActivated) {
              datePickerOpenEvent(evnt);
            }
          }
        } else if (isPgUp || isPgDn) {
          if (isDatePickerType) {
            if (isActivated) {
              datePgOffsetEvent(evnt);
            }
          }
        }
        if (isTab || isEsc) {
          if (visiblePanel) {
            hidePanel();
          }
        } else if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelWrapperElem = refPanelWrapper.value;
          if (getEventTargetNode(evnt, panelWrapperElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { isActivated, visiblePanel } = reactData;
      if (visiblePanel) {
        hidePanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const inputElem = refInputTarget.value;
        afterCheckValue();
        if (inputElem) {
          inputElem.blur();
        }
      }
    };
    const renderDateLabel = (item, label) => {
      const { festivalMethod } = props;
      if (festivalMethod) {
        const { datePanelType } = reactData;
        const festivalRest = festivalMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $input: $xeInput });
        const festivalItem = festivalRest ? import_xe_utils31.default.isString(festivalRest) ? { label: festivalRest } : festivalRest : {};
        const extraItem = festivalItem.extra ? import_xe_utils31.default.isString(festivalItem.extra) ? { label: festivalItem.extra } : festivalItem.extra : null;
        const labels = [
          h("span", {
            class: ["vxe-input--date-label", {
              "is-notice": festivalItem.notice
            }]
          }, extraItem && extraItem.label ? [
            h("span", `${label || ""}`),
            h("span", {
              class: ["vxe-input--date-label--extra", extraItem.important ? "is-important" : "", extraItem.className],
              style: extraItem.style
            }, import_xe_utils31.default.toValueString(extraItem.label))
          ] : [`${label || ""}`])
        ];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          const festivalLabels = import_xe_utils31.default.toValueString(festivalLabel).split(",");
          labels.push(h("span", {
            class: ["vxe-input--date-festival", festivalItem.important ? "is-important" : "", festivalItem.className],
            style: festivalItem.style
          }, [
            festivalLabels.length > 1 ? h("span", {
              class: ["vxe-input--date-festival--overlap", `overlap--${festivalLabels.length}`]
            }, festivalLabels.map((label2) => h("span", label2.substring(0, 3)))) : h("span", {
              class: "vxe-input--date-festival--label"
            }, festivalLabels[0].substring(0, 3))
          ]));
        }
        return labels;
      }
      return [`${label || ""}`];
    };
    const renderDateDayTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", dateHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", dayDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils31.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils31.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils31.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateWeekTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", weekHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", weekDates.map((rows) => {
            const isSelected = multiple ? rows.some((item) => dateListValue.some((val) => import_xe_utils31.default.isDateSame(val, item.date, matchFormat))) : rows.some((item) => import_xe_utils31.default.isDateSame(dateValue, item.date, matchFormat));
            const isHover = rows.some((item) => import_xe_utils31.default.isDateSame(datePanelValue, item.date, matchFormat));
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--hover": isHover
                },
                // event
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateMonthTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMM";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", monthDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils31.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils31.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils31.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateQuarterTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyq";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", quarterDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils31.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils31.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils31.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateYearTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyy";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", yearDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils31.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils31.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils31.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.year));
            }));
          }))
        ])
      ];
    };
    const renderDateTable = () => {
      const { datePanelType } = reactData;
      switch (datePanelType) {
        case "week":
          return renderDateWeekTable();
        case "month":
          return renderDateMonthTable();
        case "quarter":
          return renderDateQuarterTable();
        case "year":
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const { multiple } = props;
      const { datePanelType } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelObj = computeSelectDatePanelObj.value;
      return [
        h("div", {
          class: "vxe-input--date-picker-header"
        }, [
          h("div", {
            class: "vxe-input--date-picker-type-wrapper"
          }, [
            datePanelType === "year" ? h("span", {
              class: "vxe-input--date-picker-label"
            }, selectDatePanelObj.y) : h("span", {
              class: "vxe-input--date-picker-btns"
            }, [
              h("span", {
                class: "vxe-input--date-picker-btn",
                onClick: dateToggleYearTypeEvent
              }, selectDatePanelObj.y),
              selectDatePanelObj.m ? h("span", {
                class: "vxe-input--date-picker-btn",
                onClick: dateToggleMonthTypeEvent
              }, selectDatePanelObj.m) : renderEmptyElement($xeInput)
            ])
          ]),
          h("div", {
            class: "vxe-input--date-picker-btn-wrapper"
          }, [
            h("span", {
              class: ["vxe-input--date-picker-btn vxe-input--date-picker-prev-btn", {
                "is--disabled": isDisabledPrevDateBtn
              }],
              onClick: datePrevEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-left"
              })
            ]),
            h("span", {
              class: "vxe-input--date-picker-btn vxe-input--date-picker-current-btn",
              onClick: dateTodayMonthEvent
            }, [
              h("i", {
                class: "vxe-icon-dot"
              })
            ]),
            h("span", {
              class: ["vxe-input--date-picker-btn vxe-input--date-picker-next-btn", {
                "is--disabled": isDisabledNextDateBtn
              }],
              onClick: dateNextEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-right"
              })
            ]),
            multiple && computeSupportMultiples.value ? h("span", {
              class: "vxe-input--date-picker-btn vxe-input--date-picker-confirm-btn"
            }, [
              h("button", {
                class: "vxe-input--date-picker-confirm",
                type: "button",
                onClick: dateConfirmEvent
              }, getI18n("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        h("div", {
          class: "vxe-input--date-picker-body"
        }, renderDateTable())
      ];
    };
    const renderTimePanel = () => {
      const { datetimePanelValue } = reactData;
      const dateTimeLabel = computeDateTimeLabel.value;
      const hourList = computeHourList.value;
      const hasTimeMinute = computeHasTimeMinute.value;
      const minuteList = computeMinuteList.value;
      const hasTimeSecond = computeHasTimeSecond.value;
      const secondList = computeSecondList.value;
      return [
        h("div", {
          class: "vxe-input--time-picker-header"
        }, [
          hasTimeMinute ? h("span", {
            class: "vxe-input--time-picker-title"
          }, dateTimeLabel) : createCommentVNode(),
          h("div", {
            class: "vxe-input--time-picker-btn"
          }, [
            h("button", {
              class: "vxe-input--time-picker-confirm",
              type: "button",
              onClick: dateConfirmEvent
            }, getI18n("vxe.button.confirm"))
          ])
        ]),
        h("div", {
          ref: refInputTimeBody,
          class: "vxe-input--time-picker-body"
        }, [
          h("ul", {
            class: "vxe-input--time-picker-hour-list"
          }, hourList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getHours() === item.value
              },
              onClick: (evnt) => dateHourEvent(evnt, item)
            }, item.label);
          })),
          hasTimeMinute ? h("ul", {
            class: "vxe-input--time-picker-minute-list"
          }, minuteList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getMinutes() === item.value
              },
              onClick: (evnt) => dateMinuteEvent(evnt, item)
            }, item.label);
          })) : createCommentVNode(),
          hasTimeMinute && hasTimeSecond ? h("ul", {
            class: "vxe-input--time-picker-second-list"
          }, secondList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getSeconds() === item.value
              },
              onClick: (evnt) => dateSecondEvent(evnt, item)
            }, item.label);
          })) : createCommentVNode()
        ])
      ];
    };
    const renderPanel = () => {
      const { type } = props;
      const { initialized, isAniVisible, visiblePanel, panelPlacement, panelStyle } = reactData;
      const vSize = computeSize.value;
      const btnTransfer = computeBtnTransfer.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const renders = [];
      if (isDatePickerType) {
        if (type === "datetime") {
          renders.push(h("div", {
            key: type,
            ref: refPanelWrapper,
            class: "vxe-input--panel-layout-wrapper"
          }, [
            h("div", {
              class: "vxe-input--panel-left-wrapper"
            }, renderDatePanel()),
            h("div", {
              class: "vxe-input--panel-right-wrapper"
            }, renderTimePanel())
          ]));
        } else if (type === "time") {
          renders.push(h("div", {
            key: type,
            ref: refPanelWrapper,
            class: "vxe-input--panel-wrapper"
          }, renderTimePanel()));
        } else {
          renders.push(h("div", {
            key: type || "default",
            ref: refPanelWrapper,
            class: "vxe-input--panel-wrapper"
          }, renderDatePanel()));
        }
        return h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refInputPanel,
            class: ["vxe-table--ignore-clear vxe-input--panel", `type--${type}`, {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }],
            placement: panelPlacement,
            style: panelStyle
          }, visiblePanel || isAniVisible ? renders : [])
        ]);
      }
      return createCommentVNode();
    };
    const renderNumberIcon = () => {
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      return h("div", {
        class: "vxe-input--control-icon"
      }, [
        h("div", {
          class: "vxe-input--number-icon"
        }, [
          h("div", {
            class: ["vxe-input--number-btn is--prev", {
              "is--disabled": isDisabledAddNumber
            }],
            onMousedown: numberMousedownEvent,
            onMouseup: numberStopDown,
            onMouseleave: numberStopDown
          }, [
            h("i", {
              class: getIcon().INPUT_PLUS_NUM
            })
          ]),
          h("div", {
            class: ["vxe-input--number-btn is--next", {
              "is--disabled": isDisabledSubtractNumber
            }],
            onMousedown: numberMousedownEvent,
            onMouseup: numberStopDown,
            onMouseleave: numberStopDown
          }, [
            h("i", {
              class: getIcon().INPUT_MINUS_NUM
            })
          ])
        ])
      ]);
    };
    const renderDatePickerIcon = () => {
      return h("div", {
        class: "vxe-input--control-icon",
        onClick: datePickerOpenEvent
      }, [
        h("i", {
          class: ["vxe-input--date-picker-icon", getIcon().DATE_PICKER_DATE]
        })
      ]);
    };
    const renderSearchIcon = () => {
      return h("div", {
        class: "vxe-input--control-icon",
        onClick: searchEvent
      }, [
        h("i", {
          class: ["vxe-input--search-icon", getIcon().INPUT_SEARCH]
        })
      ]);
    };
    const renderPasswordIcon = () => {
      const { showPwd } = reactData;
      return h("div", {
        class: "vxe-input--control-icon",
        onClick: passwordToggleEvent
      }, [
        h("i", {
          class: ["vxe-input--password-icon", showPwd ? getIcon().PASSWORD_INPUT_SHOW_PWD : getIcon().PASSWORD_INPUT_HIDE_PWD]
        })
      ]);
    };
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "vxe-input--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "vxe-input--prefix-icon"
        }, prefixSlot ? getSlotVNs2(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : null;
    };
    const renderSuffixIcon2 = () => {
      const { suffixIcon } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      const isSearchType = computeIsSearchType.value;
      const isClearable = computeIsClearable.value;
      const isExtraBtn = isPawdType || isNumType || isDatePickerType || isSearchType;
      return isClearable || suffixSlot || suffixIcon || isExtraBtn ? h("div", {
        class: ["vxe-input--suffix", {
          "is--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils31.default.eqNull(inputValue))
        }]
      }, [
        isClearable ? h("div", {
          class: "vxe-input--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : createCommentVNode(),
        isExtraBtn ? renderExtraSuffixIcon() : createCommentVNode(),
        suffixSlot || suffixIcon ? h("div", {
          class: "vxe-input--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs2(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : createCommentVNode()
      ]) : null;
    };
    const renderExtraSuffixIcon = () => {
      const { controls } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      const isSearchType = computeIsSearchType.value;
      if (isPawdType) {
        return renderPasswordIcon();
      }
      if (isNumType) {
        if (controls) {
          return renderNumberIcon();
        }
      }
      if (isDatePickerType) {
        return renderDatePickerIcon();
      }
      if (isSearchType) {
        return renderSearchIcon();
      }
      return createCommentVNode();
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $input: $xeInput }, params));
    };
    inputMethods = {
      dispatchEvent,
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeInput, inputMethods);
    const renderVN = () => {
      const { className, controls, type, title, align, showWordCount, countMethod, name, autoComplete, autocomplete } = props;
      const { inputValue, visiblePanel, isActivated } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-input--readonly", `type--${type}`, className]
        }, inputValue);
      }
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      const inputReadonly = computeInputReadonly.value;
      const inpMaxLength = computeInpMaxLength.value;
      const inputType = computeInputType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const isWordCount = showWordCount && ["text", "search"].includes(type);
      const prefix = renderPrefixIcon2();
      const suffix = renderSuffixIcon2();
      return h("div", {
        ref: refElem,
        class: ["vxe-input", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          "is--controls": controls,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--visible": visiblePanel,
          "is--count": isWordCount,
          "is--disabled": isDisabled,
          "is--active": isActivated,
          "show--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils31.default.eqNull(inputValue))
        }],
        spellcheck: false
      }, [
        prefix || createCommentVNode(),
        h("div", {
          class: "vxe-input--wrapper",
          title: title || null
        }, [
          h("input", {
            ref: refInputTarget,
            class: "vxe-input--inner",
            value: inputValue,
            name,
            type: inputType,
            placeholder: inpPlaceholder,
            maxlength: inpMaxLength,
            readonly: inputReadonly,
            disabled: isDisabled,
            autocomplete: autoComplete || autocomplete,
            onKeydown: keydownEvent,
            onKeyup: keyupEvent,
            onClick: clickEvent,
            onInput: inputEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        suffix || createCommentVNode(),
        // 下拉面板
        renderPanel(),
        // 字数统计
        isWordCount ? h("span", {
          class: ["vxe-input--count", {
            "is--error": isCountError
          }]
        }, countMethod ? `${countMethod({ value: inputValue })}` : `${inputCount}${inpMaxLength ? `/${inpMaxLength}` : ""}`) : createCommentVNode()
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
      changeValue();
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        inputValue: props.modelValue,
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    watch(computeDateLabelFormat, () => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    onMounted(() => {
      const { type } = props;
      if (["date", "time", "datetime", "week", "month", "quarter", "year"].includes(type)) {
        warnLog("vxe.error.useNew", [`<vxe-input type="${type}" ... />`, `<vxe-date-picker type="${type}" ... />`]);
      } else if (["number", "integer", "float"].includes(type)) {
        warnLog("vxe.error.useNew", [`<vxe-input type="${type}" ... />`, `<vxe-number-input type="${type}" ... />`]);
      } else if (["password"].includes(type)) {
        warnLog("vxe.error.useNew", [`<vxe-input type="${type}" ... />`, "<vxe-password-input ... />"]);
      }
      const inputElem = refInputTarget.value;
      if (inputElem) {
        inputElem.addEventListener("wheel", wheelEvent, { passive: false });
      }
      globalEvents.on($xeInput, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeInput, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeInput, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeInput, "blur", handleGlobalBlurEvent);
    });
    onBeforeUnmount(() => {
      numberStopDown();
      afterCheckValue();
      const inputElem = refInputTarget.value;
      if (inputElem) {
        inputElem.removeEventListener("wheel", wheelEvent);
      }
      globalEvents.off($xeInput, "mousewheel");
      globalEvents.off($xeInput, "mousedown");
      globalEvents.off($xeInput, "keydown");
      globalEvents.off($xeInput, "blur");
    });
    initValue();
    $xeInput.renderVN = renderVN;
    return $xeInput;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/number-input/src/number-input.js
var import_xe_utils32 = __toESM(require_xe_utils());
var number_input_default = defineVxeComponent({
  name: "VxeNumberInput",
  props: {
    modelValue: [String, Number],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: "number"
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().numberInput.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: {
      type: [String, Number],
      default: () => getConfig().numberInput.maxLength
    },
    autoComplete: {
      type: String,
      default: "off"
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => getConfig().numberInput.size || getConfig().size
    },
    // number、integer、float
    min: {
      type: [String, Number],
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    step: [String, Number],
    exponential: {
      type: Boolean,
      default: () => getConfig().numberInput.exponential
    },
    showCurrency: {
      type: Boolean,
      default: () => getConfig().numberInput.showCurrency
    },
    currencySymbol: {
      type: String,
      default: () => getConfig().numberInput.currencySymbol
    },
    controlConfig: Object,
    // float
    digits: {
      type: [String, Number],
      default: null
    },
    autoFill: {
      type: Boolean,
      default: () => getConfig().numberInput.autoFill
    },
    editable: {
      type: Boolean,
      default: true
    },
    plusIcon: String,
    minusIcon: String,
    prefixIcon: String,
    suffixIcon: String,
    // 已废弃
    controls: {
      type: Boolean,
      default: null
    },
    // 已废弃
    maxlength: [String, Number],
    // 已废弃
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "wheel",
    "click",
    "focus",
    "blur",
    "clear",
    "lazy-change",
    "plus-number",
    "minus-number",
    "prefix-click",
    "suffix-click",
    // 已废弃
    "prev-number",
    "next-number"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils32.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      isFocus: false,
      isActivated: false,
      inputValue: props.modelValue
    });
    const internalData = {
      // dnTimeout: undefined,
      // ainTimeout: undefined,
      // isMouseDown: undefined,
      // isUM: undefined
    };
    const refElem = ref();
    const refInputTarget = ref();
    const refInputPanel = ref();
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeDigitsValue = computed(() => {
      const { type, digits } = props;
      let defDigits = digits;
      if (defDigits === null) {
        defDigits = getConfig().numberInput.digits;
        if (defDigits === null) {
          if (type === "amount") {
            defDigits = 2;
          }
        }
      }
      return import_xe_utils32.default.toInteger(defDigits) || 1;
    });
    const computeControlOpts = computed(() => {
      return Object.assign({}, getConfig().numberInput.controlConfig, props.controlConfig);
    });
    const computeDecimalsType = computed(() => {
      const { type } = props;
      return type === "float" || type === "amount";
    });
    const computeStepValue = computed(() => {
      const { type } = props;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      const step = props.step;
      if (type === "integer") {
        return import_xe_utils32.default.toInteger(step) || 1;
      } else if (decimalsType) {
        return import_xe_utils32.default.toNumber(step) || 1 / Math.pow(10, digitsValue);
      }
      return import_xe_utils32.default.toNumber(step) || 1;
    });
    const computeIsClearable = computed(() => {
      return props.clearable;
    });
    const computeInputReadonly = computed(() => {
      const { editable } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || !editable;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().numberInput.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseInput");
    });
    const computeInpMaxLength = computed(() => {
      const { maxLength, maxlength } = props;
      return import_xe_utils32.default.toNumber(maxLength || maxlength) || 16;
    });
    const computeInpImmediate = computed(() => {
      const { immediate } = props;
      return immediate;
    });
    const computeNumValue = computed(() => {
      const { type } = props;
      const { inputValue } = reactData;
      return type === "integer" ? import_xe_utils32.default.toInteger(handleNumber(inputValue)) : import_xe_utils32.default.toNumber(handleNumber(inputValue));
    });
    const computeNumLabel = computed(() => {
      const { type, showCurrency, currencySymbol, autoFill } = props;
      const { inputValue } = reactData;
      const digitsValue = computeDigitsValue.value;
      if (type === "amount") {
        const num = import_xe_utils32.default.toNumber(inputValue);
        let amountLabel = import_xe_utils32.default.commafy(num, { digits: digitsValue });
        if (!autoFill) {
          const [iStr, dStr] = amountLabel.split(".");
          if (dStr) {
            const dRest = dStr.replace(/0+$/, "");
            amountLabel = dRest ? [iStr, ".", dRest].join("") : iStr;
          }
        }
        if (showCurrency) {
          return `${currencySymbol || getI18n("vxe.numberInput.currencySymbol") || ""}${amountLabel}`;
        }
        return amountLabel;
      }
      return import_xe_utils32.default.toString(inputValue);
    });
    const computeIsDisabledSubtractNumber = computed(() => {
      const { min } = props;
      const { inputValue } = reactData;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && min !== null) {
        return numValue <= import_xe_utils32.default.toNumber(min);
      }
      return false;
    });
    const computeIsDisabledAddNumber = computed(() => {
      const { max } = props;
      const { inputValue } = reactData;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && max !== null) {
        return numValue >= import_xe_utils32.default.toNumber(max);
      }
      return false;
    });
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const computeMaps = {
      computeControlOpts
    };
    const $xeNumberInput = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    let numberInputMethods = {};
    const handleNumberString = (val) => {
      if (import_xe_utils32.default.eqNull(val)) {
        return "";
      }
      return `${val}`;
    };
    const getNumberValue = (val) => {
      const { exponential, autoFill } = props;
      const inpMaxLength = computeInpMaxLength.value;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      let restVal = "";
      if (decimalsType) {
        restVal = toFloatValueFixed(val, digitsValue);
        if (!autoFill) {
          restVal = handleNumberString(import_xe_utils32.default.toNumber(restVal));
        }
      } else {
        restVal = handleNumberString(val);
      }
      if (exponential && (val === restVal || handleNumberString(val).toLowerCase() === import_xe_utils32.default.toNumber(restVal).toExponential())) {
        return val;
      }
      return restVal.slice(0, inpMaxLength);
    };
    const triggerEvent = (evnt) => {
      const { inputValue } = reactData;
      numberInputMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const handleChange = (val, inputValue, evnt) => {
      const value = eqEmptyValue(val) ? null : Number(val);
      const isChange = value !== props.modelValue;
      if (isChange) {
        internalData.isUM = true;
        emit("update:modelValue", value);
      }
      if (reactData.inputValue !== inputValue) {
        nextTick(() => {
          reactData.inputValue = inputValue || "";
        });
      }
      numberInputMethods.dispatchEvent("input", { value }, evnt);
      if (isChange) {
        numberInputMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const emitInputEvent = (inputValue, evnt) => {
      const inpImmediate = computeInpImmediate.value;
      const value = eqEmptyValue(inputValue) ? null : import_xe_utils32.default.toNumber(inputValue);
      reactData.inputValue = inputValue;
      if (inpImmediate) {
        handleChange(value, inputValue, evnt);
      } else {
        numberInputMethods.dispatchEvent("input", { value }, evnt);
      }
    };
    const inputEvent = (evnt) => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const changeEvent = (evnt) => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
      $xeNumberInput.dispatchEvent("lazy-change", { value: reactData.inputValue }, evnt);
    };
    const focusEvent = (evnt) => {
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        const { inputValue } = reactData;
        reactData.inputValue = eqEmptyValue(inputValue) ? "" : `${import_xe_utils32.default.toNumber(inputValue)}`;
        reactData.isFocus = true;
        reactData.isActivated = true;
        triggerEvent(evnt);
      }
    };
    const clickPrefixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        numberInputMethods.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    const clearValueEvent = (evnt, value) => {
      focus();
      handleChange(null, "", evnt);
      numberInputMethods.dispatchEvent("clear", { value }, evnt);
      $xeNumberInput.dispatchEvent("lazy-change", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        numberInputMethods.dispatchEvent("suffix-click", { value: inputValue }, evnt);
      }
    };
    const updateModel = (val) => {
      const { autoFill } = props;
      const { inputValue } = reactData;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      if (eqEmptyValue(val)) {
        reactData.inputValue = "";
      } else {
        let textValue = `${val}`;
        if (decimalsType) {
          textValue = toFloatValueFixed(val, digitsValue);
          if (!autoFill) {
            textValue = `${import_xe_utils32.default.toNumber(textValue)}`;
          }
        }
        if (textValue !== inputValue) {
          reactData.inputValue = textValue;
        }
      }
    };
    const initValue = () => {
      const { autoFill } = props;
      const { inputValue } = reactData;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      if (decimalsType) {
        if (inputValue) {
          let textValue = "";
          let validValue = null;
          if (inputValue) {
            textValue = toFloatValueFixed(inputValue, digitsValue);
            validValue = import_xe_utils32.default.toNumber(textValue);
            if (!autoFill) {
              textValue = `${validValue}`;
            }
          }
          if (inputValue !== validValue) {
            handleChange(validValue, textValue, { type: "init" });
          } else {
            reactData.inputValue = textValue;
          }
        }
      }
    };
    const validMaxNum = (num) => {
      return props.max === null || props.max === "" || import_xe_utils32.default.toNumber(num) <= import_xe_utils32.default.toNumber(props.max);
    };
    const validMinNum = (num) => {
      return props.min === null || props.min === "" || import_xe_utils32.default.toNumber(num) >= import_xe_utils32.default.toNumber(props.min);
    };
    const afterCheckValue = () => {
      const { type, min, max, exponential } = props;
      const { inputValue } = reactData;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (eqEmptyValue(inputValue)) {
          let inpNumVal = null;
          let inpValue = inputValue;
          if (min || min === 0) {
            inpNumVal = import_xe_utils32.default.toNumber(min);
            inpValue = `${inpNumVal}`;
          }
          handleChange(inpNumVal, `${inpValue || ""}`, { type: "check" });
          return;
        }
        if (inputValue || (min || max)) {
          let inpNumVal = type === "integer" ? import_xe_utils32.default.toInteger(handleNumber(inputValue)) : import_xe_utils32.default.toNumber(handleNumber(inputValue));
          if (!validMinNum(inpNumVal)) {
            inpNumVal = min;
          } else if (!validMaxNum(inpNumVal)) {
            inpNumVal = max;
          }
          if (exponential) {
            const inpStringVal = handleNumberString(inputValue).toLowerCase();
            if (inpStringVal === import_xe_utils32.default.toNumber(inpNumVal).toExponential()) {
              inpNumVal = inpStringVal;
            }
          }
          const inpValue = getNumberValue(inpNumVal);
          handleChange(eqEmptyValue(inpValue) ? null : Number(inpValue), inpValue, { type: "check" });
        }
      }
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue ? Number(inputValue) : null;
      if (!inpImmediate) {
        handleChange(value, handleNumberString(inputValue), evnt);
      }
      afterCheckValue();
      reactData.isFocus = false;
      reactData.isActivated = false;
      numberInputMethods.dispatchEvent("blur", { value }, evnt);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const numberChange = (isPlus, evnt) => {
      const { min, max, type } = props;
      const { inputValue } = reactData;
      const stepValue = computeStepValue.value;
      const numValue = type === "integer" ? import_xe_utils32.default.toInteger(handleNumber(inputValue)) : import_xe_utils32.default.toNumber(handleNumber(inputValue));
      const newValue = isPlus ? import_xe_utils32.default.add(numValue, stepValue) : import_xe_utils32.default.subtract(numValue, stepValue);
      let restNum;
      if (!validMinNum(newValue)) {
        restNum = min;
      } else if (!validMaxNum(newValue)) {
        restNum = max;
      } else {
        restNum = newValue;
      }
      emitInputEvent(getNumberValue(restNum), evnt);
    };
    const numberPlusEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      if (!isDisabled && !formReadonly && !isDisabledAddNumber) {
        numberChange(true, evnt);
      }
      reactData.isActivated = true;
      numberInputMethods.dispatchEvent("plus-number", { value: reactData.inputValue }, evnt);
      $xeNumberInput.dispatchEvent("lazy-change", { value: reactData.inputValue }, evnt);
      numberInputMethods.dispatchEvent("next-number", { value: reactData.inputValue }, evnt);
    };
    const numberMinusEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      if (!isDisabled && !formReadonly && !isDisabledSubtractNumber) {
        numberChange(false, evnt);
      }
      reactData.isActivated = true;
      numberInputMethods.dispatchEvent("minus-number", { value: reactData.inputValue }, evnt);
      $xeNumberInput.dispatchEvent("lazy-change", { value: reactData.inputValue }, evnt);
      numberInputMethods.dispatchEvent("prev-number", { value: reactData.inputValue }, evnt);
    };
    const numberKeydownEvent = (evnt) => {
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (isUpArrow || isDwArrow) {
        evnt.preventDefault();
        if (isUpArrow) {
          numberPlusEvent(evnt);
        } else {
          numberMinusEvent(evnt);
        }
      }
    };
    const keydownEvent = (evnt) => {
      const { type, exponential, controls } = props;
      const controlOpts = computeControlOpts.value;
      const { isArrow } = controlOpts;
      const inputReadonly = computeInputReadonly.value;
      const isControlKey = hasControlKey(evnt);
      const isShiftKey = evnt.shiftKey;
      const isAltKey = evnt.altKey;
      const keyCode = evnt.keyCode;
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (!isControlKey && !isShiftKey && !isAltKey) {
        if (globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR) || type === "integer" && keyCode === 110 || (!exponential || keyCode !== 69) && (keyCode >= 65 && keyCode <= 90) || keyCode >= 186 && keyCode <= 188 || keyCode >= 191) {
          evnt.preventDefault();
        }
      }
      if (isEsc) {
        afterCheckValue();
      } else if (isUpArrow || isDwArrow) {
        if (isEnableConf(controlOpts) && (controls === false ? controls : isArrow) && !inputReadonly) {
          numberKeydownEvent(evnt);
        }
      }
      triggerEvent(evnt);
    };
    const keyupEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const stopDown = () => {
      const { dnTimeout } = internalData;
      if (dnTimeout) {
        clearTimeout(dnTimeout);
        internalData.dnTimeout = void 0;
      }
    };
    const stopAutoIncrement = () => {
      const { ainTimeout } = internalData;
      if (ainTimeout) {
        clearTimeout(ainTimeout);
        internalData.ainTimeout = void 0;
      }
    };
    const numberDownMinusEvent = (evnt) => {
      numberStopAll();
      internalData.ainTimeout = setTimeout(() => {
        numberMinusEvent(evnt);
        numberDownMinusEvent(evnt);
      }, 60);
    };
    const numberDownPlusEvent = (evnt) => {
      numberStopAll();
      internalData.ainTimeout = setTimeout(() => {
        numberPlusEvent(evnt);
        numberDownPlusEvent(evnt);
      }, 60);
    };
    const numberStopAll = () => {
      stopDown();
      stopAutoIncrement();
    };
    const numberClickEvent = (evnt) => {
      if (internalData.isMouseDown) {
        internalData.isMouseDown = false;
      } else {
        numberStopAll();
        const isAddNumber = hasClass(evnt.currentTarget, "is--plus");
        if (isAddNumber) {
          numberPlusEvent(evnt);
        } else {
          numberMinusEvent(evnt);
        }
      }
    };
    const numberMousedownEvent = (evnt) => {
      numberStopAll();
      internalData.isMouseDown = true;
      if (evnt.button === 0) {
        const isAddNumber = hasClass(evnt.currentTarget, "is--plus");
        if (isAddNumber) {
          numberPlusEvent(evnt);
        } else {
          numberMinusEvent(evnt);
        }
        internalData.dnTimeout = setTimeout(() => {
          if (isAddNumber) {
            numberDownPlusEvent(evnt);
          } else {
            numberDownMinusEvent(evnt);
          }
        }, 500);
      }
    };
    const wheelEvent = (evnt) => {
      const { controls } = props;
      const controlOpts = computeControlOpts.value;
      const { isWheel } = controlOpts;
      const inputReadonly = computeInputReadonly.value;
      if (isEnableConf(controlOpts) && (controls === false ? controls : isWheel) && !inputReadonly) {
        if (reactData.isActivated) {
          evnt.stopPropagation();
          evnt.preventDefault();
          const delta = evnt.deltaY;
          if (delta > 0) {
            numberMinusEvent(evnt);
          } else if (delta < 0) {
            numberPlusEvent(evnt);
          }
        }
      }
      triggerEvent(evnt);
    };
    const clickEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { isActivated } = reactData;
      const el = refElem.value;
      const panelElem = refInputPanel.value;
      const isDisabled = computeIsDisabled.value;
      const inputReadonly = computeInputReadonly.value;
      const inpImmediate = computeInpImmediate.value;
      if (!isDisabled && !inputReadonly && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (!reactData.isActivated) {
          if (!inpImmediate) {
            const { inputValue } = reactData;
            const value = inputValue ? Number(inputValue) : null;
            handleChange(value, handleNumberString(inputValue), evnt);
          }
          afterCheckValue();
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const isDisabled = computeIsDisabled.value;
      const inputReadonly = computeInputReadonly.value;
      if (!isDisabled && !inputReadonly) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        }
        if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { isActivated } = reactData;
      if (isActivated) {
        afterCheckValue();
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $numberInput: $xeNumberInput }, params));
    };
    numberInputMethods = {
      dispatchEvent,
      focus() {
        const inputReadonly = computeInputReadonly.value;
        if (!inputReadonly) {
          const inputElem = refInputTarget.value;
          reactData.isActivated = true;
          inputElem.focus();
        }
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xeNumberInput, numberInputMethods);
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "vxe-number-input--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "vxe-number-input--prefix-icon"
        }, prefixSlot ? getSlotVNs2(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : renderEmptyElement($xeNumberInput);
    };
    const renderSuffixIcon2 = () => {
      const { suffixIcon } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isClearable = computeIsClearable.value;
      return h("div", {
        class: ["vxe-number-input--suffix", {
          "is--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils32.default.eqNull(inputValue))
        }]
      }, [
        isClearable ? h("div", {
          class: "vxe-number-input--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : renderEmptyElement($xeNumberInput),
        suffixSlot || suffixIcon ? h("div", {
          class: "vxe-number-input--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs2(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : renderEmptyElement($xeNumberInput)
      ]);
    };
    const renderInput = () => {
      const { type, name, autocomplete, autoComplete } = props;
      const { inputValue, isFocus } = reactData;
      const isDisabled = computeIsDisabled.value;
      const numLabel = computeNumLabel.value;
      const inputReadonly = computeInputReadonly.value;
      const inpMaxLength = computeInpMaxLength.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      return h("div", {
        key: "ni",
        class: "vxe-number-input--input-wrapper"
      }, [
        renderPrefixIcon2(),
        h("div", {
          class: "vxe-number-input--input-inner"
        }, [
          h("input", {
            ref: refInputTarget,
            class: "vxe-number-input--input",
            value: !isFocus && type === "amount" ? numLabel : inputValue,
            name,
            type: "text",
            placeholder: inpPlaceholder,
            maxlength: inpMaxLength,
            readonly: inputReadonly,
            disabled: isDisabled,
            autocomplete: autoComplete || autocomplete,
            onKeydown: keydownEvent,
            onKeyup: keyupEvent,
            onClick: clickEvent,
            onInput: inputEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        renderSuffixIcon2()
      ]);
    };
    const renderMinusBtn = () => {
      const { minusIcon } = props;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      return h("button", {
        key: "prev",
        class: ["vxe-number-input--minus-btn is--minus", {
          "is--disabled": isDisabledSubtractNumber
        }],
        type: "button",
        onClick: numberClickEvent,
        onMousedown: numberMousedownEvent,
        onMouseup: numberStopAll,
        onMouseleave: numberStopAll
      }, [
        h("i", {
          class: minusIcon || getIcon().NUMBER_INPUT_MINUS_NUM
        })
      ]);
    };
    const renderPlusBtn = () => {
      const { plusIcon } = props;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      return h("button", {
        key: "next",
        class: ["vxe-number-input--plus-btn is--plus", {
          "is--disabled": isDisabledAddNumber
        }],
        type: "button",
        onClick: numberClickEvent,
        onMousedown: numberMousedownEvent,
        onMouseup: numberStopAll,
        onMouseleave: numberStopAll
      }, [
        h("i", {
          class: plusIcon || getIcon().NUMBER_INPUT_PLUS_NUM
        })
      ]);
    };
    const renderSideControl = () => {
      return h("div", {
        key: "cplr",
        class: "vxe-number-input--side-control"
      }, [
        renderPlusBtn(),
        renderMinusBtn()
      ]);
    };
    const renderVN = () => {
      const { className, controls, type, align, prefixIcon, suffixIcon } = props;
      const { inputValue, isActivated } = reactData;
      const vSize = computeSize.value;
      const controlOpts = computeControlOpts.value;
      const { layout, showButton } = controlOpts;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const numLabel = computeNumLabel.value;
      const prefixSlot = slots.prefix;
      const suffixSlot = slots.suffix;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-number-input--readonly", `type--${type}`, className]
        }, numLabel);
      }
      const inputReadonly = computeInputReadonly.value;
      const isClearable = computeIsClearable.value;
      const isControls = isEnableConf(controlOpts) && (controls === false ? controls : showButton);
      return h("div", {
        ref: refElem,
        class: ["vxe-number-input", `type--${type}`, `ctl--${layout === "right" || layout === "left" ? layout : "default"}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          "is--controls": isControls && !inputReadonly,
          "is--prefix": !!prefixSlot || prefixIcon,
          "is--suffix": !!suffixSlot || suffixIcon,
          "is--disabled": isDisabled,
          "is--active": isActivated,
          "show--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils32.default.eqNull(inputValue))
        }],
        spellcheck: false
      }, isControls ? layout === "right" ? [
        renderInput(),
        renderSideControl()
      ] : layout === "left" ? [
        renderSideControl(),
        renderInput()
      ] : [
        renderMinusBtn(),
        renderInput(),
        renderPlusBtn()
      ] : [
        renderInput()
      ]);
    };
    $xeNumberInput.renderVN = renderVN;
    watch(() => props.modelValue, (val) => {
      if (!internalData.isUM) {
        updateModel(val);
      }
      internalData.isUM = false;
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        inputValue: props.modelValue
      });
      initValue();
    });
    onMounted(() => {
      const targetElem = refInputTarget.value;
      if (targetElem) {
        targetElem.addEventListener("wheel", wheelEvent, { passive: false });
      }
      globalEvents.on($xeNumberInput, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeNumberInput, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeNumberInput, "blur", handleGlobalBlurEvent);
    });
    onBeforeUnmount(() => {
      reactData.isFocus = false;
      numberStopAll();
      afterCheckValue();
      const targetElem = refInputTarget.value;
      if (targetElem) {
        targetElem.removeEventListener("wheel", wheelEvent);
      }
      globalEvents.off($xeNumberInput, "mousedown");
      globalEvents.off($xeNumberInput, "keydown");
      globalEvents.off($xeNumberInput, "blur");
    });
    initValue();
    return $xeNumberInput;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/color-picker/src/color-picker.js
var color_picker_default = defineVxeComponent({
  name: "VxeColorPicker",
  props: {
    modelValue: String,
    placeholder: String,
    clearable: {
      type: Boolean,
      default: () => getConfig().colorPicker.clearable
    },
    type: {
      type: String,
      default: () => getConfig().colorPicker.type
    },
    size: {
      type: String,
      default: () => getConfig().colorPicker.size || getConfig().size
    },
    className: [String, Function],
    popupClassName: [String, Function],
    colors: {
      type: Array,
      default: () => import_xe_utils33.default.clone(getConfig().colorPicker.colors, true) || []
    },
    showAlpha: {
      type: Boolean,
      default: () => getConfig().colorPicker.showAlpha
    },
    showEyeDropper: {
      type: Boolean,
      default: () => getConfig().colorPicker.showEyeDropper
    },
    showColorExtractor: {
      type: Boolean,
      default: () => getConfig().colorPicker.showColorExtractor
    },
    showQuick: {
      type: Boolean,
      default: () => getConfig().colorPicker.showQuick
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    clickToCopy: {
      type: Boolean,
      default: () => getConfig().colorPicker.clickToCopy
    },
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const WinEyeDropper = typeof window !== "undefined" ? window.EyeDropper : null;
    const xID = import_xe_utils33.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refInputTarget = ref();
    const refOptionPanel = ref();
    const refHueSliderElem = ref();
    const refHueSliderBtnElem = ref();
    const refAlphaSliderElem = ref();
    const refAlphaSliderBtnElem = ref();
    const refColorPanelElem = ref();
    const refColorActiveElem = ref();
    const reactData = reactive({
      initialized: false,
      selectTyle: "hex",
      selectColor: `${props.modelValue || ""}`,
      showTypePopup: false,
      panelColor: "",
      hexValue: "",
      rValue: 0,
      gValue: 0,
      bValue: 0,
      aValue: 0,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const typeList = [
      { label: "HEX", value: "hex" },
      { label: "RGB", value: "rgb" }
    ];
    const internalData = {
      // hpTimeout: undefined
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().colorPicker.transfer;
        if (import_xe_utils33.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeColorList = computed(() => {
      const { colors } = props;
      if (colors) {
        return colors.map((item) => {
          if (import_xe_utils33.default.isString(item)) {
            return {
              label: item,
              value: item
            };
          }
          return {
            label: import_xe_utils33.default.eqNull(item.label) ? item.value : item.label,
            value: item.value
          };
        });
      }
      return [];
    });
    const computeIsRgb = computed(() => {
      const { selectTyle } = reactData;
      return selectTyle === "rgb";
    });
    const computeSelectTypeItem = computed(() => {
      const { selectTyle } = reactData;
      return typeList.find((item) => item.value === selectTyle);
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeColorPicker = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const updateMode = () => {
      const { modelValue } = props;
      reactData.selectColor = import_xe_utils33.default.toValueString(modelValue);
      updateModelColor();
    };
    const updateType = () => {
      const { type } = props;
      let selectTyle = "hex";
      if (type === "rgb" || type === "rgba") {
        selectTyle = "rgb";
      }
      reactData.selectTyle = selectTyle;
      updateMode();
    };
    const updateModelColor = () => {
      const { selectColor, isAniVisible } = reactData;
      const isRgb = computeIsRgb.value;
      const hueSliderEl = refHueSliderElem.value;
      const alphaSliderEl = refAlphaSliderElem.value;
      const colorRest = parseColor(selectColor);
      reactData.hexValue = colorRest.hex;
      reactData.rValue = colorRest.r;
      reactData.gValue = colorRest.g;
      reactData.bValue = colorRest.b;
      reactData.aValue = colorRest.a;
      if (colorRest.value) {
        if (isRgb) {
          if (colorRest.type === "hex") {
            const rgbRest = hexToRgb(colorRest.hex);
            if (rgbRest) {
              reactData.rValue = rgbRest.r;
              reactData.gValue = rgbRest.g;
              reactData.bValue = rgbRest.b;
              reactData.aValue = rgbRest.a;
            }
          }
        } else {
          if (colorRest.type !== "hex") {
            reactData.hexValue = rgbToHex(colorRest);
          }
        }
      }
      if (isAniVisible) {
        const hsvRest = colorRest.type === "hex" ? hexToHsv(colorRest.hex) : rgbToHsv(colorRest);
        const colorPanelEl = refColorPanelElem.value;
        if (hsvRest) {
          if (colorPanelEl) {
            const offsetTop = colorPanelEl.clientHeight * (1 - hsvRest.v);
            const offsetLeft = colorPanelEl.clientWidth * hsvRest.s;
            handlePanelColor(offsetLeft, offsetTop);
          }
          if (hueSliderEl) {
            handleHueColor(import_xe_utils33.default.ceil((1 - hsvRest.h / 360) * hueSliderEl.clientWidth));
          }
        }
        if (alphaSliderEl) {
          handleAlphaColor(alphaSliderEl.clientWidth * colorRest.a);
        }
      }
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const { placement } = props;
      const { panelIndex } = reactData;
      const targetElem = refElem.value;
      const panelElem = refOptionPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return nextTick().then(handleStyle);
    };
    const showOptionPanel = () => {
      const { hpTimeout } = internalData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = void 0;
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          updateModelColor();
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, value) => {
      reactData.selectColor = value;
      if (value !== props.modelValue) {
        emitModel(value);
        dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      dispatchEvent("clear", { value: selectValue }, evnt);
    };
    const focusEvent = () => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
      }
    };
    const blurEvent = () => {
      reactData.isActivated = false;
    };
    const clearEvent = (evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const confirmEvent = (evnt) => {
      const { selectColor } = reactData;
      changeEvent(evnt, selectColor);
      hideOptionPanel();
    };
    const togglePanelEvent = (evnt) => {
      evnt.preventDefault();
      if (reactData.visiblePanel) {
        hideOptionPanel();
      } else {
        showOptionPanel();
      }
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      dispatchEvent("click", {}, evnt);
    };
    const handlePanelClickEvent = () => {
      reactData.showTypePopup = false;
    };
    const toggleTypeVisibleEvent = (evnt) => {
      evnt.stopPropagation();
      reactData.showTypePopup = !reactData.showTypePopup;
    };
    const handleChangeType = (type) => {
      const { selectTyle } = reactData;
      if (type !== selectTyle) {
        reactData.selectTyle = type;
        updateModelColor();
      }
      reactData.showTypePopup = false;
    };
    const handleHueColor = (offsetLeft) => {
      const hueSliderEl = refHueSliderElem.value;
      const hueSliderBtnEl = refHueSliderBtnElem.value;
      if (hueSliderEl && hueSliderBtnEl) {
        if (offsetLeft < 0) {
          offsetLeft = 0;
        }
        const barWidth = import_xe_utils33.default.toInteger(hueSliderEl.clientWidth);
        const itemNum = 255;
        const countNum = itemNum * 6;
        const offsetX = import_xe_utils33.default.ceil(countNum / barWidth * offsetLeft);
        const offsetNum = offsetX % itemNum;
        let rNum = 0;
        let gNum = 0;
        let bNum = 0;
        switch (Math.ceil(offsetX / itemNum)) {
          case 1:
            rNum = itemNum;
            bNum = offsetNum;
            break;
          case 2:
            rNum = itemNum - offsetNum;
            bNum = itemNum;
            break;
          case 3:
            gNum = offsetNum;
            bNum = itemNum;
            break;
          case 4:
            gNum = itemNum;
            bNum = itemNum - offsetNum;
            break;
          case 5:
            rNum = offsetNum;
            gNum = itemNum;
            break;
          case 6:
            rNum = itemNum;
            gNum = itemNum - offsetNum;
            break;
        }
        reactData.panelColor = toRgb(rNum, gNum, bNum);
        hueSliderBtnEl.style.left = toCssUnit(offsetLeft);
      }
    };
    const handleHueBarEvent = (evnt) => {
      const hueSliderEl = refHueSliderElem.value;
      const hueSliderBtnEl = refHueSliderBtnElem.value;
      if (hueSliderEl && hueSliderBtnEl) {
        const hueSliderRect = hueSliderEl.getBoundingClientRect();
        const barWidth = import_xe_utils33.default.toInteger(hueSliderEl.clientWidth);
        const offsetLeft = import_xe_utils33.default.ceil(Math.min(barWidth - 1, Math.max(1, evnt.clientX - hueSliderRect.x)));
        handleHueColor(offsetLeft);
      }
    };
    const handleHueSliderMousedownEvent = (evnt) => {
      evnt.preventDefault();
      document.onmousemove = (evnt2) => {
        evnt2.preventDefault();
        handleHueBarEvent(evnt2);
      };
      document.onmouseup = (evnt2) => {
        document.onmousemove = null;
        document.onmouseup = null;
        handleHueBarEvent(evnt2);
      };
    };
    const handleAlphaColor = (offsetLeft) => {
      const { selectColor } = reactData;
      const alphaSliderEl = refAlphaSliderElem.value;
      const alphaSliderBtnEl = refAlphaSliderBtnElem.value;
      if (alphaSliderEl && alphaSliderBtnEl) {
        const alphaSliderRect = alphaSliderEl.getBoundingClientRect();
        const barWidth = alphaSliderRect.width;
        if (offsetLeft < 0) {
          offsetLeft = 0;
        }
        if (offsetLeft > barWidth) {
          offsetLeft = barWidth;
        }
        const alpha = import_xe_utils33.default.ceil(100 / barWidth * offsetLeft / 100, 2);
        reactData.aValue = alpha;
        alphaSliderBtnEl.style.left = toCssUnit(offsetLeft);
        reactData.selectColor = updateColorAlpha(selectColor, alpha);
      }
    };
    const handleAlphaBarEvent = (evnt) => {
      const alphaSliderEl = refAlphaSliderElem.value;
      const alphaSliderBtnEl = refAlphaSliderBtnElem.value;
      if (alphaSliderEl && alphaSliderBtnEl) {
        const alphaSliderRect = alphaSliderEl.getBoundingClientRect();
        const barWidth = alphaSliderRect.width;
        const offsetLeft = Math.min(barWidth, Math.max(0, evnt.clientX - alphaSliderRect.x));
        handleAlphaColor(offsetLeft);
        updateModelColor();
      }
    };
    const handleAlphaSliderMousedownEvent = (evnt) => {
      evnt.preventDefault();
      document.onmousemove = (evnt2) => {
        evnt2.preventDefault();
        handleAlphaBarEvent(evnt2);
      };
      document.onmouseup = (evnt2) => {
        document.onmousemove = null;
        document.onmouseup = null;
        handleAlphaBarEvent(evnt2);
      };
    };
    const handleInputRgbEvent = () => {
      const { rValue, gValue, bValue, aValue } = reactData;
      reactData.selectColor = toRgb(rValue, gValue, bValue, aValue);
      updateModelColor();
    };
    const handleInputAlphaEvent = () => {
      const { aValue } = reactData;
      const alphaSliderEl = refAlphaSliderElem.value;
      const alphaSliderBtnEl = refAlphaSliderBtnElem.value;
      if (alphaSliderEl && alphaSliderBtnEl) {
        const alphaSliderRect = alphaSliderEl.getBoundingClientRect();
        const barWidth = alphaSliderRect.width;
        const offsetLeft = barWidth * aValue;
        handleAlphaColor(offsetLeft);
      }
    };
    const handleQuickEvent = (evnt, item) => {
      const value = item.value;
      reactData.selectColor = value;
      updateModelColor();
    };
    const handlePanelColor = (offsetLeft, offsetTop) => {
      const colorActiveEl = refColorActiveElem.value;
      if (colorActiveEl) {
        colorActiveEl.style.top = toCssUnit(offsetTop);
        colorActiveEl.style.left = toCssUnit(offsetLeft);
      }
    };
    const handleEyeDropperEvent = () => {
      if (WinEyeDropper) {
        try {
          const eyeDropper = new WinEyeDropper();
          eyeDropper.open().then((rest) => {
            if (rest && rest.sRGBHex) {
              reactData.selectColor = rest.sRGBHex;
              updateModelColor();
            }
          }).catch(() => {
          });
        } catch (e) {
        }
      }
    };
    const handleSelectColorByXY = (clientX, clientY) => {
      const { showAlpha } = props;
      const { panelColor, aValue } = reactData;
      const colorPanelEl = refColorPanelElem.value;
      const colorActiveEl = refColorActiveElem.value;
      if (colorPanelEl && colorActiveEl) {
        const { clientWidth, clientHeight } = colorPanelEl;
        const colorPanelRect = colorPanelEl.getBoundingClientRect();
        const offsetTop = Math.min(clientHeight, Math.max(0, clientY - colorPanelRect.y));
        const offsetLeft = Math.min(clientWidth, Math.max(0, clientX - colorPanelRect.x));
        const colorRest = parseColor(panelColor);
        if (colorRest) {
          const hsvRest = colorRest.type === "hex" ? hexToHsv(colorRest.hex) : rgbToHsv(colorRest);
          if (hsvRest) {
            const ragRest = hsvToRgb(hsvRest.h, offsetLeft / clientWidth, 1 - offsetTop / clientHeight);
            reactData.selectColor = toRgb(ragRest.r, ragRest.g, ragRest.b, showAlpha ? aValue : null);
            updateModelColor();
          }
        }
        handlePanelColor(offsetLeft, offsetTop);
      }
    };
    const handleSelectColorMousedownEvent = (evnt) => {
      evnt.stopPropagation();
      evnt.preventDefault();
      handleSelectColorByXY(evnt.clientX, evnt.clientY);
      document.onmousemove = (evnt2) => {
        handleSelectColorByXY(evnt2.clientX, evnt2.clientY);
      };
      document.onmouseup = () => {
        document.onmousemove = null;
        document.onmouseup = null;
      };
    };
    const handleCopyColorEvent = () => {
      const { selectColor } = reactData;
      if (selectColor) {
        if (VxeUI.clipboard.copy(selectColor)) {
          if (VxeUI.modal) {
            VxeUI.modal.message({
              content: getI18n("vxe.colorPicker.copySuccess", [selectColor]),
              status: "success"
            });
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { visiblePanel, isActivated } = reactData;
      if (visiblePanel) {
        hideOptionPanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const targetElem = refInputTarget.value;
        if (targetElem) {
          targetElem.blur();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const { visiblePanel } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $colorPicker: $xeColorPicker }, params));
    };
    const colorPickerMethods = {
      dispatchEvent
    };
    const colorPickerPrivateMethods = {};
    Object.assign($xeColorPicker, colorPickerMethods, colorPickerPrivateMethods);
    const renderColorWrapper = () => {
      const { showColorExtractor } = props;
      const { panelColor } = reactData;
      if (showColorExtractor) {
        return h("div", {
          ref: refColorPanelElem,
          class: "vxe-color-picker--color-wrapper",
          onMousedown: handleSelectColorMousedownEvent
        }, [
          h("div", {
            class: "vxe-color-picker--color-bg",
            style: {
              backgroundColor: panelColor
            }
          }),
          h("div", {
            class: "vxe-color-picker--white-bg"
          }),
          h("div", {
            class: "vxe-color-picker--black-bg"
          }),
          h("div", {
            ref: refColorActiveElem,
            class: "vxe-color-picker--color-active"
          })
        ]);
      }
      return renderEmptyElement($xeColorPicker);
    };
    const renderColorBar = () => {
      const { showAlpha, clickToCopy, showEyeDropper } = props;
      const { selectTyle, showTypePopup, hexValue, rValue, gValue, bValue, aValue, selectColor, panelColor } = reactData;
      const isRgb = computeIsRgb.value;
      const selectTypeItem = computeSelectTypeItem.value;
      return h("div", {
        class: "vxe-color-picker--bar-wrapper"
      }, [
        h("div", {
          class: "vxe-color-picker--slider-wrapper"
        }, [
          showEyeDropper && WinEyeDropper ? h("div", {
            class: "vxe-color-picker--color-dropper"
          }, [
            h("span", {
              class: "vxe-color-picker--color-dropper-btn",
              onClick: handleEyeDropperEvent
            }, [
              h("i", {
                class: getIcon().COLOR_PICKER_EYE_DROPPER
              })
            ])
          ]) : renderEmptyElement($xeColorPicker),
          h("div", {
            class: "vxe-color-picker--slider-preview"
          }, [
            h("div", {
              class: "vxe-color-picker--preview-btn"
            }, [
              h("div", {
                class: "vxe-color-picker--preview-color",
                style: {
                  backgroundColor: selectColor
                }
              }, clickToCopy ? [
                h("span", {
                  class: "vxe-color-picker--preview-copy-btn",
                  onClick: handleCopyColorEvent
                }, [
                  h("i", {
                    class: getIcon().COLOR_PICKER_COLOR_COPY
                  })
                ])
              ] : [])
            ])
          ]),
          h("div", {
            class: "vxe-color-picker--slider-handle"
          }, [
            h("div", {
              ref: refHueSliderElem,
              class: "vxe-color-picker--bar-hue-slider",
              onClick: handleHueBarEvent
            }, [
              h("div", {
                ref: refHueSliderBtnElem,
                class: "vxe-color-picker--bar-hue-btn",
                onMousedown: handleHueSliderMousedownEvent
              })
            ]),
            showAlpha ? h("div", {
              ref: refAlphaSliderElem,
              class: "vxe-color-picker--bar-alpha-slider",
              onClick: handleAlphaBarEvent
            }, [
              h("div", {
                class: "vxe-color-picker--bar-alpha-bg",
                style: {
                  background: `linear-gradient(to right, rgba(0, 0, 0, 0), ${panelColor})`
                }
              }),
              h("div", {
                ref: refAlphaSliderBtnElem,
                class: "vxe-color-picker--bar-alpha-btn",
                onMousedown: handleAlphaSliderMousedownEvent
              })
            ]) : renderEmptyElement($xeColorPicker)
          ])
        ]),
        h("div", {
          class: "vxe-color-picker--custom-wrapper"
        }, [
          h("div", {
            class: "vxe-color-picker--type-switch"
          }, [
            h("div", {
              class: "vxe-color-picker--type-label",
              onClick: toggleTypeVisibleEvent
            }, [
              h("span", `${selectTypeItem ? selectTypeItem.label : selectTyle}`),
              h("span", {
                class: "vxe-color-picker--type-icon"
              }, [
                h("i", {
                  class: showTypePopup ? getIcon().COLOR_PICKER_TPTY_OPEN : getIcon().COLOR_PICKER_TPTY_CLOSE
                })
              ])
            ]),
            h("div", {
              class: ["vxe-color-picker--type-popup", {
                "is--visible": showTypePopup
              }]
            }, typeList.map((item) => {
              return h("div", {
                class: "vxe-color-picker--type-item",
                onClick(evnt) {
                  evnt.stopPropagation();
                  handleChangeType(item.value);
                }
              }, item.label);
            }))
          ]),
          h("div", {
            class: `vxe-color-picker--${selectTyle}-wrapper`
          }, isRgb ? [
            h("div", {
              class: "vxe-color-picker--input-wrapper"
            }, [
              h(number_input_default, {
                type: "integer",
                size: "mini",
                align: "center",
                min: 0,
                max: 255,
                maxLength: 3,
                placeholder: "",
                modelValue: rValue,
                controlConfig: {
                  showButton: false
                },
                "onUpdate:modelValue"(val) {
                  reactData.rValue = val;
                },
                onChange: handleInputRgbEvent
              }),
              h(number_input_default, {
                type: "integer",
                size: "mini",
                align: "center",
                min: 0,
                max: 255,
                maxLength: 3,
                placeholder: "",
                modelValue: gValue,
                controlConfig: {
                  showButton: false
                },
                "onUpdate:modelValue"(val) {
                  reactData.gValue = val;
                },
                onChange: handleInputRgbEvent
              }),
              h(number_input_default, {
                type: "integer",
                size: "mini",
                align: "center",
                min: 0,
                max: 255,
                maxLength: 3,
                placeholder: "",
                modelValue: bValue,
                controlConfig: {
                  showButton: false
                },
                "onUpdate:modelValue"(val) {
                  reactData.bValue = val;
                },
                onChange: handleInputRgbEvent
              }),
              h(number_input_default, {
                type: "number",
                size: "mini",
                align: "center",
                min: 0,
                max: 1,
                step: 0.01,
                maxLength: 4,
                placeholder: "",
                modelValue: aValue,
                controlConfig: {
                  showButton: false
                },
                "onUpdate:modelValue"(val) {
                  reactData.aValue = val;
                },
                onChange: handleInputAlphaEvent
              })
            ]),
            h("div", {
              class: "vxe-color-picker--input-title"
            }, [
              h("span", "R"),
              h("span", "G"),
              h("span", "B"),
              h("span", "A")
            ])
          ] : [
            h("div", {
              class: "vxe-color-picker--input-wrapper"
            }, [
              h(input_default, {
                type: "text",
                size: "mini",
                align: "center",
                maxLength: 9,
                placeholder: "",
                modelValue: hexValue,
                "onUpdate:modelValue"(val) {
                  reactData.hexValue = val;
                },
                onChange() {
                  const colorRest = parseColor(reactData.hexValue);
                  if (colorRest) {
                    if (colorRest.value) {
                      reactData.selectColor = colorRest.value;
                      updateModelColor();
                    }
                  }
                }
              })
            ]),
            h("div", {
              class: "vxe-color-picker--input-title"
            }, getI18n("vxe.colorPicker.hex"))
          ])
        ])
      ]);
    };
    const renderQuickWrapper = () => {
      const { showQuick } = props;
      const colorList = computeColorList.value;
      if (showQuick && colorList.length) {
        return h("div", {
          class: "vxe-color-picker--quick-wrapper"
        }, colorList.map((item, i) => {
          return h("div", {
            key: i,
            class: "vxe-color-picker--quick-item",
            title: item.label || "",
            style: {
              backgroundColor: item.value
            },
            onClick(evnt) {
              handleQuickEvent(evnt, item);
            }
          });
        }));
      }
      return renderEmptyElement($xeColorPicker);
    };
    const renderVN = () => {
      const { className, popupClassName, clearable, modelValue } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-color-picker--readonly", className]
        }, [
          h("div", {
            class: "vxe-color-picker--readonly-color",
            style: {
              backgroundColor: modelValue
            }
          })
        ]);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-color-picker", className ? import_xe_utils33.default.isFunction(className) ? className({ $colorPicker: $xeColorPicker }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--selected": !!modelValue,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--active": isActivated
        }]
      }, [
        h("input", {
          ref: refInputTarget,
          class: "vxe-color-picker--input",
          onFocus: focusEvent,
          onBlur: blurEvent
        }),
        h("div", {
          class: "vxe-color-picker--inner",
          onClick: clickEvent
        }, [
          h("div", {
            class: "vxe-color-picker--inner-color",
            style: {
              backgroundColor: modelValue
            }
          })
        ]),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-color-picker--panel", popupClassName ? import_xe_utils33.default.isFunction(popupClassName) ? popupClassName({ $colorPicker: $xeColorPicker }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, [
            initialized && (visiblePanel || isAniVisible) ? h("div", {
              class: "vxe-color-picker--panel-wrapper",
              onClick: handlePanelClickEvent
            }, [
              renderColorWrapper(),
              renderColorBar(),
              renderQuickWrapper(),
              h("div", {
                class: "vxe-color-picker--footer-wrapper"
              }, [
                clearable ? h(button_default, {
                  content: getI18n("vxe.colorPicker.clear"),
                  size: "mini",
                  onClick: clearEvent
                }) : renderEmptyElement($xeColorPicker),
                h(button_default, {
                  content: getI18n("vxe.colorPicker.confirm"),
                  size: "mini",
                  status: "primary",
                  onClick: confirmEvent
                })
              ])
            ]) : renderEmptyElement($xeColorPicker)
          ])
        ])
      ]);
    };
    watch(() => props.modelValue, () => {
      updateMode();
    });
    watch(() => props.type, () => {
      updateType();
    });
    onMounted(() => {
      globalEvents.on($xeColorPicker, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeColorPicker, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeColorPicker, "blur", handleGlobalBlurEvent);
      globalEvents.on($xeColorPicker, "resize", handleGlobalResizeEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeColorPicker, "mousewheel");
      globalEvents.off($xeColorPicker, "mousedown");
      globalEvents.off($xeColorPicker, "blur");
      globalEvents.off($xeColorPicker, "resize");
    });
    updateType();
    provide("$xeColorPicker", $xeColorPicker);
    $xeColorPicker.renderVN = renderVN;
    return $xeColorPicker;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/color-picker/index.js
var VxeColorPicker = Object.assign({}, color_picker_default, {
  install(app) {
    app.component(color_picker_default.name, color_picker_default);
  }
});
dynamicApp.use(VxeColorPicker);
VxeUI.component(color_picker_default);
var ColorPicker = VxeColorPicker;
var color_picker_default2 = VxeColorPicker;

// node_modules/vxe-pc-ui/es/text/src/text.js
var import_xe_utils34 = __toESM(require_xe_utils());
var text_default = defineVxeComponent({
  name: "VxeText",
  props: {
    status: String,
    title: [String, Number],
    icon: String,
    prefixIcon: String,
    suffixIcon: String,
    loading: Boolean,
    content: [String, Number],
    clickToCopy: {
      type: Boolean,
      default: () => getConfig().text.clickToCopy
    },
    copyConfig: Object,
    size: {
      type: String,
      default: () => getConfig().text.size || getConfig().size
    }
  },
  emits: [
    "click",
    "dblclick",
    "prefix-click",
    "suffix-click",
    "copy-success",
    "copy-error"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils34.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refContentElem = ref();
    const reactData = reactive({});
    const computeCopyOpts = computed(() => {
      return Object.assign({}, getConfig().text.copyConfig, props.copyConfig);
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const handleCopy = (evnt) => {
      const { content } = props;
      const copyOpts = computeCopyOpts.value;
      const { showMessage } = copyOpts;
      const contentEl = refContentElem.value;
      const copyVal = (contentEl ? contentEl.textContent : "") || content;
      if (copyVal) {
        if (VxeUI.clipboard.copy(copyVal)) {
          if (showMessage && VxeUI.modal) {
            VxeUI.modal.message({
              content: getI18n("vxe.text.copySuccess"),
              status: "success"
            });
          }
          dispatchEvent("copy-success", {}, evnt);
        } else {
          if (showMessage && VxeUI.modal) {
            VxeUI.modal.message({
              content: getI18n("vxe.text.copyError"),
              status: "error"
            });
          }
          dispatchEvent("copy-error", {}, evnt);
        }
      }
    };
    const clickIconEvent = (evnt) => {
      const { clickToCopy } = props;
      const copyOpts = computeCopyOpts.value;
      if (clickToCopy && copyOpts.trigger !== "dblclick") {
        handleCopy(evnt);
      }
    };
    const dblclickIconEvent = (evnt) => {
      const { clickToCopy } = props;
      const copyOpts = computeCopyOpts.value;
      if (clickToCopy && copyOpts.trigger === "dblclick") {
        handleCopy(evnt);
      }
    };
    const $xeText = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $text: $xeText }, params));
    };
    const textMethods = {
      dispatchEvent
    };
    const clickEvent = (evnt) => {
      const { loading: loading2 } = props;
      if (!loading2) {
        dispatchEvent("click", {}, evnt);
      }
    };
    const dblclickEvent = (evnt) => {
      const { loading: loading2 } = props;
      if (!loading2) {
        dispatchEvent("dblclick", {}, evnt);
      }
    };
    const prefixEvent = (evnt) => {
      const { loading: loading2 } = props;
      if (!loading2) {
        dispatchEvent("prefix-click", {}, evnt);
      }
    };
    const suffixEvent = (evnt) => {
      const { loading: loading2 } = props;
      if (!loading2) {
        dispatchEvent("suffix-click", {}, evnt);
      }
    };
    const textPrivateMethods = {};
    Object.assign($xeText, textMethods, textPrivateMethods);
    const renderCopyIcon = () => {
      const copyOpts = computeCopyOpts.value;
      const { icon, status } = copyOpts;
      return h("span", {
        key: "ci",
        class: ["vxe-text--copy-icon", {
          [`theme--${status}`]: status
        }],
        onClick: clickIconEvent,
        onDblclick: dblclickIconEvent
      }, [
        h("i", {
          class: icon || getIcon().TEXT_COPY
        })
      ]);
    };
    const renderContent = () => {
      const { loading: loading2, icon, prefixIcon, suffixIcon, clickToCopy, content } = props;
      const copyOpts = computeCopyOpts.value;
      const defaultSlot = slots.default;
      const prefixIconSlot = slots.prefixIcon || slots["prefix-icon"] || slots.icon;
      const suffixIconSlot = slots.suffixIcon || slots["suffix-icon"];
      const copyToRight = copyOpts.layout === "right";
      const contVNs = [];
      if (loading2) {
        contVNs.push(h("span", {
          key: "lg",
          class: "vxe-text--loading"
        }, [
          h("i", {
            class: getIcon().TEXT_LOADING
          })
        ]));
      } else if (clickToCopy && !copyToRight) {
        contVNs.push(renderCopyIcon());
      }
      if (prefixIcon || icon) {
        contVNs.push(h("span", {
          key: "si",
          class: "vxe-text--prefix-icon",
          onClick: prefixEvent
        }, prefixIconSlot ? prefixIconSlot({}) : [
          h("i", {
            class: prefixIcon || icon
          })
        ]));
      }
      contVNs.push(h("span", {
        key: "ct",
        ref: refContentElem,
        class: "vxe-text--content",
        onClick: clickEvent,
        onDblclick: dblclickEvent
      }, defaultSlot ? defaultSlot({}) : import_xe_utils34.default.toValueString(content)));
      if (suffixIcon) {
        contVNs.push(h("span", {
          key: "si",
          class: "vxe-text--suffix-icon",
          onClick: suffixEvent
        }, suffixIconSlot ? suffixIconSlot({}) : [
          h("i", {
            class: suffixIcon
          })
        ]));
      }
      if (clickToCopy && copyToRight && !loading2) {
        contVNs.push(renderCopyIcon());
      }
      return contVNs;
    };
    const renderVN = () => {
      const { loading: loading2, status, title, clickToCopy } = props;
      const vSize = computeSize.value;
      return h("span", {
        ref: refElem,
        title,
        class: ["vxe-text", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--copy": clickToCopy,
          "is--loading": loading2
        }]
      }, renderContent());
    };
    $xeText.renderVN = renderVN;
    return $xeText;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/countdown/src/countdown.js
var import_xe_utils35 = __toESM(require_xe_utils());
var countdown_default = defineVxeComponent({
  name: "VxeCountdown",
  props: {
    modelValue: [Number, String],
    format: String,
    prefixConfig: Object,
    suffixConfig: Object,
    size: {
      type: String,
      default: () => getConfig().countdown.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "start",
    "end"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils35.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      currNum: 0,
      secondNum: 0
    });
    const internalData = {
      dnTimeout: void 0
    };
    const refMaps = {
      refElem
    };
    const computeTimeFormats = computed(() => {
      const { secondNum } = reactData;
      if (secondNum >= 316224e5) {
        return ["yyyy", "MM", "dd", "HH", "mm", "ss"];
      }
      if (secondNum >= 26784e5) {
        return ["MM", "dd", "HH", "mm", "ss"];
      }
      if (secondNum >= 864e5) {
        return ["dd", "HH", "mm", "ss"];
      }
      if (secondNum >= 36e5) {
        return ["HH", "mm", "ss"];
      }
      if (secondNum >= 6e4) {
        return ["mm", "ss"];
      }
      return ["ss"];
    });
    const computeDiffConf = computed(() => {
      const { currNum } = reactData;
      const diffRest = import_xe_utils35.default.getDateDiff(Date.now(), Date.now() + currNum);
      return Object.assign(diffRest, { done: !(import_xe_utils35.default.isBoolean(diffRest.status) ? diffRest.status : diffRest.done) });
    });
    const computeFormatLabel = computed(() => {
      const { format } = props;
      const diffConf = computeDiffConf.value;
      let rest = "";
      if (format) {
        rest = `${format}`;
        import_xe_utils35.default.each(diffConf, (val, key) => {
          rest = rest.replace(new RegExp(key, "g"), import_xe_utils35.default.padStart(val, key.length, "0"));
        });
        return rest;
      }
      return rest;
    });
    const computePrefixOpts = computed(() => {
      return Object.assign({}, props.prefixConfig, getConfig().countdown.prefixConfig);
    });
    const computeSuffixOpts = computed(() => {
      return Object.assign({}, props.suffixConfig, getConfig().countdown.suffixConfig);
    });
    const computeMaps = {
      computeSize
    };
    const $xeCountdown = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $carousel: $xeCountdown }, params));
    };
    const updateCount = () => {
      const secondNum = import_xe_utils35.default.toNumber(props.modelValue || 0);
      reactData.secondNum = secondNum;
      reactData.currNum = secondNum;
    };
    const handleTime = () => {
      const { currNum } = reactData;
      if (currNum > 1e3) {
        reactData.currNum -= 1e3;
        internalData.dnTimeout = setTimeout(() => {
          handleTime();
        }, 1e3);
      } else {
        reactData.currNum = 0;
        handleStop();
      }
    };
    const countdownMethods = {
      dispatchEvent
    };
    const handleStart = () => {
      dispatchEvent("start", {}, null);
      handleTime();
    };
    const handleStop = () => {
      const { dnTimeout } = internalData;
      if (dnTimeout) {
        clearTimeout(dnTimeout);
        internalData.dnTimeout = void 0;
        dispatchEvent("end", {}, null);
      }
    };
    const countdownPrivateMethods = {};
    Object.assign($xeCountdown, countdownMethods, countdownPrivateMethods);
    const renderDefaultContentVNs = () => {
      const { format } = props;
      const timeFormats = computeTimeFormats.value;
      const diffConf = computeDiffConf.value;
      const formatLabel = computeFormatLabel.value;
      if (format) {
        return [
          h("div", {
            key: "format",
            class: "vxe-countdown--content-format"
          }, formatLabel)
        ];
      }
      return timeFormats.map((key, index) => {
        return h("div", {
          key: index,
          class: "vxe-countdown--content-item"
        }, [
          h("div", {
            class: "vxe-countdown--content-num"
          }, `${diffConf[key] || 0}`),
          h("div", {
            class: "vxe-countdown--content-unit"
          }, getI18n(`vxe.countdown.formats.${key}`))
        ]);
      });
    };
    const renderVN = () => {
      const { prefixConfig, suffixConfig } = props;
      const { currNum } = reactData;
      const vSize = computeSize.value;
      const diffConf = computeDiffConf.value;
      const prefixOpts = computePrefixOpts.value;
      const suffixOpts = computeSuffixOpts.value;
      const prefixSlot = slots.prefix;
      const suffixSlot = slots.suffix;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-countdown", diffConf.done ? "is--progress" : "is-end", {
          [`size--${vSize}`]: vSize
        }]
      }, [
        prefixSlot || prefixConfig ? h("div", {
          class: "vxe-countdown--prefix"
        }, prefixSlot ? getSlotVNs2(prefixSlot({ currentValue: currNum, diffConf })) : [
          h(text_default, {
            content: prefixOpts.content,
            icon: prefixOpts.icon,
            status: prefixOpts.status
          })
        ]) : renderEmptyElement($xeCountdown),
        h("div", {
          class: "vxe-countdown--content"
        }, defaultSlot ? getSlotVNs2(defaultSlot({ currentValue: currNum, diffConf })) : renderDefaultContentVNs()),
        suffixSlot || suffixConfig ? h("div", {
          class: "vxe-countdown--suffix"
        }, suffixSlot ? getSlotVNs2(suffixSlot({ currentValue: currNum, diffConf })) : [
          h(text_default, {
            content: suffixOpts.content,
            icon: suffixOpts.icon,
            status: suffixOpts.status
          })
        ]) : renderEmptyElement($xeCountdown)
      ]);
    };
    watch(() => props.modelValue, () => {
      updateCount();
      handleStop();
      handleStart();
    });
    onUnmounted(() => {
      handleStop();
    });
    onMounted(() => {
      handleStart();
    });
    updateCount();
    $xeCountdown.renderVN = renderVN;
    return $xeCountdown;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/countdown/index.js
var VxeCountdown = Object.assign({}, countdown_default, {
  install(app) {
    app.component(countdown_default.name, countdown_default);
  }
});
dynamicApp.use(VxeCountdown);
VxeUI.component(countdown_default);
var Countdown = VxeCountdown;
var countdown_default2 = VxeCountdown;

// node_modules/vxe-pc-ui/es/date-panel/src/date-panel.js
var import_xe_utils36 = __toESM(require_xe_utils());
var date_panel_default = defineVxeComponent({
  name: "VxeDatePanel",
  props: {
    modelValue: [String, Number, Date],
    type: {
      type: String,
      default: "date"
    },
    className: String,
    size: {
      type: String,
      default: () => getConfig().datePanel.size || getConfig().size
    },
    multiple: Boolean,
    limitCount: {
      type: [String, Number],
      default: () => getConfig().datePanel.limitCount
    },
    // date、week、month、quarter、year
    startDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePanel.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePanel.endDate
    },
    defaultDate: [String, Number, Date],
    defaultTime: [String, Number, Date],
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    startDay: {
      type: [String, Number],
      default: () => getConfig().datePanel.startDay
    },
    labelFormat: String,
    valueFormat: String,
    timeFormat: String,
    festivalMethod: {
      type: Function,
      default: () => getConfig().datePanel.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().datePanel.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().datePanel.selectDay
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "click",
    "clear",
    "date-prev",
    "date-today",
    "date-next",
    "confirm"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils36.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false,
      inputValue: "",
      inputLabel: "",
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    });
    const internalData = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8,
      hpTimeout: void 0
    };
    const refElem = ref();
    const refPanelWrapper = ref();
    const refInputTimeBody = ref();
    const refMaps = {
      refElem
    };
    const $xeDatePanel = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeIsDateTimeType = computed(() => {
      const { type } = props;
      return type === "time" || type === "datetime";
    });
    const computeIsDatePanelType = computed(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeDateStartTime = computed(() => {
      return props.startDate ? import_xe_utils36.default.toStringDate(props.startDate) : null;
    });
    const computeDateEndTime = computed(() => {
      return props.endDate ? import_xe_utils36.default.toStringDate(props.endDate) : null;
    });
    const computeDateListValue = computed(() => {
      const { modelValue, multiple } = props;
      const isDatePanelType = computeIsDatePanelType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue && isDatePanelType) {
        return import_xe_utils36.default.toValueString(modelValue).split(",").map((item) => {
          const date = parseDate(item, dateValueFormat);
          if (import_xe_utils36.default.isValidDate(date)) {
            return date;
          }
          return date;
        });
      }
      return [];
    });
    const computeDateMultipleValue = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map((date) => import_xe_utils36.default.toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map((date) => import_xe_utils36.default.toDateString(date, dateLabelFormat)).join(", ");
    });
    const computeLimitMaxCount = computed(() => {
      return props.multiple ? import_xe_utils36.default.toNumber(props.limitCount) : 0;
    });
    const computeOverCount = computed(() => {
      const { multiple } = props;
      const limitMaxCount = computeLimitMaxCount.value;
      const dateMultipleValue = computeDateMultipleValue.value;
      if (multiple && limitMaxCount) {
        return dateMultipleValue.length >= limitMaxCount;
      }
      return false;
    });
    const computeDateValueFormat = computed(() => {
      const { type, valueFormat } = props;
      return handleValueFormat(type, valueFormat);
    });
    const computeDateValue = computed(() => {
      const { modelValue } = props;
      const isDatePanelType = computeIsDatePanelType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (modelValue && isDatePanelType) {
        const date = parseDate(modelValue, dateValueFormat);
        if (import_xe_utils36.default.isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = computed(() => {
      const dateStartTime = computeDateStartTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = computed(() => {
      const dateEndTime = computeDateEndTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateEndTime) {
        return import_xe_utils36.default.getWhatMonth(selectMonth, 0, "last") >= dateEndTime;
      }
      return false;
    });
    const computeDateTimeLabel = computed(() => {
      const { datetimePanelValue } = reactData;
      const hasTimeSecond = computeHasTimeSecond.value;
      const hasTimeMinute = computeHasTimeMinute.value;
      if (datetimePanelValue) {
        return import_xe_utils36.default.toDateString(datetimePanelValue, hasTimeMinute && hasTimeSecond ? "HH:mm:ss" : hasTimeMinute ? "HH:mm" : "HH");
      }
      return "";
    });
    const computeDateHMSTime = computed(() => {
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1e3 : 0;
    });
    const computeDateLabelFormat = computed(() => {
      const { labelFormat } = props;
      const isDatePanelType = computeIsDatePanelType.value;
      if (isDatePanelType) {
        return labelFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return "";
    });
    const computeYearList = computed(() => {
      const { yearSize } = internalData;
      const { selectMonth, currentDate } = reactData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index = -4; index < yearSize + 4; index++) {
          const date = import_xe_utils36.default.getWhatYear(startYearDate, index, "first");
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelObj = computed(() => {
      const isDatePanelType = computeIsDatePanelType.value;
      let y = "";
      let m = "";
      if (isDatePanelType) {
        const { datePanelType, selectMonth } = reactData;
        const yearList = computeYearList.value;
        let year = "";
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === "quarter" || datePanelType === "month") {
          y = getI18n("vxe.datePicker.yearTitle", [year]);
        } else if (datePanelType === "year") {
          y = yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : "";
        } else {
          y = getI18n("vxe.datePicker.yearTitle", [year]);
          m = month ? getI18n(`vxe.input.date.m${month}`) : "-";
        }
      }
      return {
        y,
        m
      };
    });
    const computeFirstDayOfWeek = computed(() => {
      const { startDay } = props;
      return import_xe_utils36.default.toNumber(startDay);
    });
    const computeWeekDatas = computed(() => {
      const weeks = [];
      const isDatePanelType = computeIsDatePanelType.value;
      if (isDatePanelType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = computed(() => {
      const isDatePanelType = computeIsDatePanelType.value;
      if (isDatePanelType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map((day) => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = computed(() => {
      const isDatePanelType = computeIsDatePanelType.value;
      if (isDatePanelType) {
        const dateHeaders = computeDateHeaders.value;
        return [{ label: getI18n("vxe.input.date.weeks.w") }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = computed(() => {
      const yearList = computeYearList.value;
      return import_xe_utils36.default.chunk(yearList, 4);
    });
    const computeQuarterList = computed(() => {
      const { quarterSize } = internalData;
      const { selectMonth, currentDate } = reactData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = import_xe_utils36.default.getWhatYear(selectMonth, 0, "first");
        const selFullYear = firstYear.getFullYear();
        for (let index = -2; index < quarterSize - 2; index++) {
          const date = import_xe_utils36.default.getWhatQuarter(firstYear, index);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = computed(() => {
      const quarterList = computeQuarterList.value;
      return import_xe_utils36.default.chunk(quarterList, 2);
    });
    const computeMonthList = computed(() => {
      const { monthSize } = internalData;
      const { selectMonth, currentDate } = reactData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = import_xe_utils36.default.getWhatYear(selectMonth, 0, "first").getFullYear();
        for (let index = -4; index < monthSize - 4; index++) {
          const date = import_xe_utils36.default.getWhatYear(selectMonth, 0, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = computed(() => {
      const monthList = computeMonthList.value;
      return import_xe_utils36.default.chunk(monthList, 4);
    });
    const computeDayList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(import_xe_utils36.default.getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index = 0; index < 42; index++) {
          const date = import_xe_utils36.default.getWhatDay(startDayDate, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = computed(() => {
      const dayList = computeDayList.value;
      return import_xe_utils36.default.chunk(dayList, 7);
    });
    const computeWeekDates = computed(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map((list) => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: import_xe_utils36.default.getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const computeHourList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 24; index++) {
          list.push({
            value: index,
            label: ("" + index).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeMinuteList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 60; index++) {
          list.push({
            value: index,
            label: ("" + index).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeHasTimeMinute = computed(() => {
      const { timeFormat } = props;
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(timeFormat || dateValueFormat) || /mm/.test(timeFormat || dateValueFormat);
    });
    const computeHasTimeSecond = computed(() => {
      const { timeFormat } = props;
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(timeFormat || dateValueFormat) || /ss/.test(timeFormat || dateValueFormat);
    });
    const computeSecondList = computed(() => {
      const minuteList = computeMinuteList.value;
      return minuteList;
    });
    const updateModelValue = (modelValue) => {
      const { type } = props;
      const dateValueFormat = computeDateValueFormat.value;
      const inpDate = parseDateValue(modelValue, type, { valueFormat: dateValueFormat });
      reactData.inputValue = inpDate;
      reactData.inputLabel = inpDate;
      dateOpenPanel();
    };
    const parseDate = (value, format) => {
      const { type, multiple } = props;
      if (type === "time") {
        return toStringTimeDate(value);
      }
      if (import_xe_utils36.default.isArray(value)) {
        return import_xe_utils36.default.toStringDate(value[0], format);
      }
      if (import_xe_utils36.default.isString(value)) {
        return import_xe_utils36.default.toStringDate(multiple ? import_xe_utils36.default.last(value.split(",")) : value, format);
      }
      return import_xe_utils36.default.toStringDate(value, format);
    };
    const dateRevert = () => {
      reactData.inputLabel = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    const afterCheckValue = (inpVal) => {
      const { type } = props;
      const { inputLabel, datetimePanelValue } = reactData;
      const dateLabelFormat = computeDateLabelFormat.value;
      if (inpVal) {
        let inpDateVal = parseDate(inpVal, dateLabelFormat);
        if (import_xe_utils36.default.isValidDate(inpDateVal)) {
          if (type === "time") {
            inpDateVal = import_xe_utils36.default.toDateString(inpDateVal, dateLabelFormat);
            if (inputLabel !== inpDateVal) {
              handleChange(inpDateVal, { type: "check" });
            }
            reactData.inputLabel = inpDateVal;
          } else {
            let isChange = false;
            const firstDayOfWeek = computeFirstDayOfWeek.value;
            if (type === "datetime") {
              const dateValue = computeDateValue.value;
              if (inpVal !== import_xe_utils36.default.toDateString(dateValue, dateLabelFormat) || inpVal !== import_xe_utils36.default.toDateString(inpDateVal, dateLabelFormat)) {
                isChange = true;
                if (datetimePanelValue) {
                  datetimePanelValue.setHours(inpDateVal.getHours());
                  datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                  datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                }
              }
            } else {
              isChange = true;
            }
            reactData.inputLabel = import_xe_utils36.default.toDateString(inpDateVal, dateLabelFormat, { firstDay: firstDayOfWeek });
            if (isChange) {
              dateChange(inpDateVal);
            }
          }
        } else {
          dateRevert();
        }
      } else {
        handleChange("", { type: "check" });
      }
    };
    const emitModel = (value) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
    };
    const handleChange = (value, evnt) => {
      const { type, modelValue, valueFormat } = props;
      const dateValueFormat = computeDateValueFormat.value;
      reactData.inputLabel = value;
      if (hasTimestampValueType(valueFormat)) {
        const dateVal = parseDateValue(value, type, { valueFormat: dateValueFormat });
        const timeNum = dateVal ? dateVal.getTime() : null;
        emitModel(timeNum);
        if (modelValue !== timeNum) {
          dispatchEvent("change", { value: timeNum }, evnt);
        }
      } else if (hasDateValueType(valueFormat)) {
        const dateVal = parseDateValue(value, type, { valueFormat: dateValueFormat });
        emitModel(dateVal);
        if (modelValue && dateVal ? import_xe_utils36.default.toStringDate(modelValue).getTime() !== dateVal.getTime() : modelValue !== dateVal) {
          dispatchEvent("change", { value: dateVal }, evnt);
        }
      } else {
        emitModel(value);
        if (import_xe_utils36.default.toValueString(modelValue) !== value) {
          dispatchEvent("change", { value }, evnt);
        }
      }
    };
    const hidePanel = () => {
      return new Promise((resolve) => {
        reactData.visiblePanel = false;
        internalData.hpTimeout = setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const dateParseValue = (val) => {
      const { type } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const dateObj = parseDateObj(val, type, {
        valueFormat: dateValueFormat,
        labelFormat: dateLabelFormat,
        firstDay: firstDayOfWeek
      });
      reactData.datePanelValue = dateObj.value;
      reactData.datePanelLabel = dateObj.label;
    };
    const changeValue = () => {
      const isDatePanelType = computeIsDatePanelType.value;
      const { inputLabel } = reactData;
      if (isDatePanelType) {
        dateParseValue(inputLabel);
        reactData.inputLabel = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    const initValue = () => {
      const { modelValue } = props;
      const isDatePanelType = computeIsDatePanelType.value;
      updateModelValue(modelValue);
      if (isDatePanelType) {
        changeValue();
      }
    };
    const dateCheckMonth = (date) => {
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const weekNum = import_xe_utils36.default.getYearWeek(date, firstDayOfWeek);
      const weekStartDate = import_xe_utils36.default.getWhatWeek(date, 0, firstDayOfWeek, firstDayOfWeek);
      const month = import_xe_utils36.default.getWhatMonth(weekNum === 1 ? import_xe_utils36.default.getWhatDay(weekStartDate, 6) : date, 0, "first");
      if (!import_xe_utils36.default.isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = (date, isReload) => {
      const { modelValue, multiple } = props;
      const { datetimePanelValue } = reactData;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === "week") {
        const sWeek = import_xe_utils36.default.toNumber(props.selectDay);
        date = import_xe_utils36.default.getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        if (datetimePanelValue) {
          date.setHours(datetimePanelValue.getHours());
          date.setMinutes(datetimePanelValue.getMinutes());
          date.setSeconds(datetimePanelValue.getSeconds());
        }
      }
      const inpVal = import_xe_utils36.default.toDateString(date, dateValueFormat, { firstDay: firstDayOfWeek });
      dateCheckMonth(date);
      if (multiple) {
        const overCount = computeOverCount.value;
        if (isDateTimeType) {
          const dateListValue = isReload ? [] : [...computeDateListValue.value];
          const datetimeRest = [];
          const eqIndex = import_xe_utils36.default.findIndexOf(dateListValue, (val) => import_xe_utils36.default.isDateSame(date, val, "yyyyMMdd"));
          if (eqIndex === -1) {
            if (overCount) {
              return;
            }
            dateListValue.push(date);
          } else {
            dateListValue.splice(eqIndex, 1);
          }
          dateListValue.forEach((item) => {
            if (item) {
              if (datetimePanelValue) {
                item.setHours(datetimePanelValue.getHours());
                item.setMinutes(datetimePanelValue.getMinutes());
                item.setSeconds(datetimePanelValue.getSeconds());
              }
              datetimeRest.push(item);
            }
          });
          handleChange(datetimeRest.map((date2) => import_xe_utils36.default.toDateString(date2, dateValueFormat)).join(","), { type: "update" });
        } else {
          const dateMultipleValue = isReload ? [] : computeDateMultipleValue.value;
          if (dateMultipleValue.some((val) => import_xe_utils36.default.isEqual(val, inpVal))) {
            handleChange(dateMultipleValue.filter((val) => !import_xe_utils36.default.isEqual(val, inpVal)).join(","), { type: "update" });
          } else {
            if (overCount) {
              return;
            }
            handleChange(dateMultipleValue.concat([inpVal]).join(","), { type: "update" });
          }
        }
      } else {
        if (!import_xe_utils36.default.isEqual(modelValue, inpVal)) {
          handleChange(inpVal, { type: "update" });
        }
      }
    };
    const dateMonthHandle = (date, offsetMonth) => {
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const weekNum = import_xe_utils36.default.getYearWeek(date, firstDayOfWeek);
      const weekStartDate = import_xe_utils36.default.getWhatWeek(date, 0, firstDayOfWeek, firstDayOfWeek);
      const month = import_xe_utils36.default.getWhatMonth(weekNum === 1 ? import_xe_utils36.default.getWhatDay(weekStartDate, 6) : date, offsetMonth, "first");
      reactData.selectMonth = month;
    };
    const dateNowHandle = () => {
      const { type } = props;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let currentDate = /* @__PURE__ */ new Date();
      switch (type) {
        case "week":
          currentDate = import_xe_utils36.default.getWhatWeek(currentDate, 0, firstDayOfWeek);
          break;
        case "datetime":
          currentDate = /* @__PURE__ */ new Date();
          reactData.datetimePanelValue = /* @__PURE__ */ new Date();
          break;
        default:
          currentDate = import_xe_utils36.default.getWhatDay(Date.now(), 0, "first");
          break;
      }
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleYearTypeEvent = () => {
      reactData.datePanelType = "year";
    };
    const dateToggleMonthTypeEvent = () => {
      let { datePanelType } = reactData;
      if (datePanelType === "month" || datePanelType === "quarter") {
        datePanelType = "year";
      } else {
        datePanelType = "month";
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth, inputLabel } = reactData;
      const { yearSize } = internalData;
      const value = inputLabel;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        let viewDate;
        if (type === "year") {
          viewDate = import_xe_utils36.default.getWhatYear(selectMonth, -yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            viewDate = import_xe_utils36.default.getWhatYear(selectMonth, -yearSize, "first");
          } else {
            viewDate = import_xe_utils36.default.getWhatYear(selectMonth, -1, "first");
          }
        } else {
          if (datePanelType === "year") {
            viewDate = import_xe_utils36.default.getWhatYear(selectMonth, -yearSize, "first");
          } else if (datePanelType === "month") {
            viewDate = import_xe_utils36.default.getWhatYear(selectMonth, -1, "first");
          } else {
            viewDate = import_xe_utils36.default.getWhatMonth(selectMonth, -1, "first");
          }
        }
        reactData.selectMonth = viewDate;
        dispatchEvent("date-prev", { viewType: datePanelType, viewDate, value, type }, evnt);
      }
    };
    const dateTodayMonthEvent = (evnt) => {
      dateNowHandle();
      dateChange(reactData.currentDate, true);
      if (!props.multiple) {
        hidePanel();
      }
      dispatchEvent("date-today", { type: props.type }, evnt);
    };
    const dateNextEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth, inputLabel } = reactData;
      const { yearSize } = internalData;
      const value = inputLabel;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        let viewDate;
        if (type === "year") {
          viewDate = import_xe_utils36.default.getWhatYear(selectMonth, yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            viewDate = import_xe_utils36.default.getWhatYear(selectMonth, yearSize, "first");
          } else {
            viewDate = import_xe_utils36.default.getWhatYear(selectMonth, 1, "first");
          }
        } else {
          if (datePanelType === "year") {
            viewDate = import_xe_utils36.default.getWhatYear(selectMonth, yearSize, "first");
          } else if (datePanelType === "month") {
            viewDate = import_xe_utils36.default.getWhatYear(selectMonth, 1, "first");
          } else {
            viewDate = import_xe_utils36.default.getWhatMonth(selectMonth, 1, "first");
          }
        }
        reactData.selectMonth = viewDate;
        dispatchEvent("date-next", { viewType: datePanelType, value, type }, evnt);
      }
    };
    const isRangeDisabled = (item) => {
      const dateStartTime = computeDateStartTime.value;
      const dateEndTime = computeDateEndTime.value;
      const { date } = item;
      if (dateStartTime && dateStartTime.getTime() > date.getTime()) {
        return true;
      }
      if (dateEndTime && dateEndTime.getTime() < date.getTime()) {
        return true;
      }
      return false;
    };
    const isDateDisabled = (item) => {
      const { disabledMethod } = props;
      const { datePanelType } = reactData;
      const { date } = item;
      if (disabledMethod) {
        return disabledMethod({ type: datePanelType, viewType: datePanelType, date, $datePanel: $xeDatePanel });
      }
      return false;
    };
    const hasAllDisabled = (item) => {
      return isRangeDisabled(item) || isDateDisabled(item);
    };
    const dateSelectItem = (date) => {
      const { type, multiple } = props;
      const { datePanelType } = reactData;
      if (type === "month") {
        if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type === "year") {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type === "quarter") {
        if (datePanelType === "year") {
          reactData.datePanelType = "quarter";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === "month") {
          reactData.datePanelType = type === "week" ? type : "day";
          dateCheckMonth(date);
        } else if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (type === "datetime") {
          } else {
            if (!multiple) {
              hidePanel();
            }
          }
        }
      }
    };
    const dateSelectEvent = (item) => {
      if (!hasAllDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = (offsetDay) => {
      if (!hasAllDisabled({ date: offsetDay })) {
        const dayList = computeDayList.value;
        if (!dayList.some((item) => import_xe_utils36.default.isDateSame(item.date, offsetDay, "yyyyMMdd"))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = (offsetYear) => {
      if (!hasAllDisabled({ date: offsetYear })) {
        const yearList = computeYearList.value;
        if (!yearList.some((item) => import_xe_utils36.default.isDateSame(item.date, offsetYear, "yyyy"))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = (offsetQuarter) => {
      if (!hasAllDisabled({ date: offsetQuarter })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some((item) => import_xe_utils36.default.isDateSame(item.date, offsetQuarter, "yyyyq"))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = (offsetMonth) => {
      if (!hasAllDisabled({ date: offsetMonth })) {
        const monthList = computeMonthList.value;
        if (!monthList.some((item) => import_xe_utils36.default.isDateSame(item.date, offsetMonth, "yyyyMM"))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = (item) => {
      if (!hasAllDisabled(item)) {
        const { datePanelType } = reactData;
        if (datePanelType === "month") {
          dateMoveMonth(item.date);
        } else if (datePanelType === "quarter") {
          dateMoveQuarter(item.date);
        } else if (datePanelType === "year") {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const dateMouseleaveEvent = () => {
      reactData.datePanelValue = null;
    };
    const updateTimePos = (liElem) => {
      if (liElem) {
        const height = liElem.offsetHeight;
        const ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height * 4;
      }
    };
    const dateTimeChangeEvent = (evnt) => {
      const { datetimePanelValue } = reactData;
      reactData.datetimePanelValue = datetimePanelValue ? new Date(datetimePanelValue.getTime()) : /* @__PURE__ */ new Date();
      updateTimePos(evnt.currentTarget);
    };
    const dateHourEvent = (evnt, item) => {
      const { datetimePanelValue } = reactData;
      if (datetimePanelValue) {
        datetimePanelValue.setHours(item.value);
      }
      dateTimeChangeEvent(evnt);
    };
    const dateConfirmEvent = (evnt) => {
      const { multiple } = props;
      const { datetimePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        const dateValueFormat = computeDateValueFormat.value;
        if (multiple) {
          const dateMultipleValue = computeDateMultipleValue.value;
          if (isDateTimeType) {
            const dateListValue = [...computeDateListValue.value];
            const datetimeRest = [];
            dateListValue.forEach((item) => {
              if (item) {
                if (datetimePanelValue) {
                  item.setHours(datetimePanelValue.getHours());
                  item.setMinutes(datetimePanelValue.getMinutes());
                  item.setSeconds(datetimePanelValue.getSeconds());
                }
                datetimeRest.push(item);
              }
            });
            handleChange(datetimeRest.map((date) => import_xe_utils36.default.toDateString(date, dateValueFormat)).join(","), { type: "update" });
          } else {
            handleChange(dateMultipleValue.join(","), { type: "update" });
          }
        } else {
          dateChange(dateValue || reactData.currentDate);
        }
      }
      hidePanel();
      dispatchEvent("confirm", {}, evnt);
    };
    const dateMinuteEvent = (evnt, item) => {
      const { datetimePanelValue } = reactData;
      if (datetimePanelValue) {
        datetimePanelValue.setMinutes(item.value);
      }
      dateTimeChangeEvent(evnt);
    };
    const dateSecondEvent = (evnt, item) => {
      const { datetimePanelValue } = reactData;
      if (datetimePanelValue) {
        datetimePanelValue.setSeconds(item.value);
      }
      dateTimeChangeEvent(evnt);
    };
    const dateOpenPanel = () => {
      const { type, defaultDate, defaultTime } = props;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValue = computeDateValue.value;
      if (["year", "quarter", "month", "week"].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = "day";
      }
      reactData.currentDate = import_xe_utils36.default.getWhatDay(Date.now(), 0, "first");
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        if (defaultDate) {
          const defDate = parseDate(defaultDate, "yyyy-MM-dd");
          if (import_xe_utils36.default.isValidDate(defDate)) {
            dateMonthHandle(defDate, 0);
          } else {
            dateNowHandle();
          }
        } else {
          dateNowHandle();
        }
      }
      if (isDateTimeType) {
        let dtPanelValue = reactData.datePanelValue;
        if (!dtPanelValue) {
          dtPanelValue = import_xe_utils36.default.getWhatDay(Date.now(), 0, "first");
          if (defaultTime) {
            const defTime = toStringTimeDate(defaultTime);
            if (import_xe_utils36.default.isValidDate(defTime)) {
              dtPanelValue.setHours(defTime.getHours());
              dtPanelValue.setMinutes(defTime.getMinutes());
              dtPanelValue.setSeconds(defTime.getSeconds());
            }
          }
        }
        reactData.datetimePanelValue = dtPanelValue;
        nextTick(() => {
          const timeBodyElem = refInputTimeBody.value;
          import_xe_utils36.default.arrayEach(timeBodyElem.querySelectorAll("li.is--selected"), (elem) => {
            updateTimePos(elem);
          });
        });
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $datePanel: $xeDatePanel }, params));
    };
    const datePanelMethods = {
      dispatchEvent,
      getModelValue() {
        return reactData.inputValue;
      },
      setPanelDate(date) {
        if (date) {
          dateCheckMonth(date);
        }
      },
      getPanelDate() {
        return reactData.selectMonth;
      },
      checkValue(value) {
        afterCheckValue(value);
      },
      confirmByEvent(evnt) {
        dateConfirmEvent(evnt);
      }
    };
    Object.assign($xeDatePanel, datePanelMethods);
    const renderDateLabel = (item, label) => {
      const { festivalMethod } = props;
      const labelVNs = [];
      if (festivalMethod) {
        const { datePanelType } = reactData;
        const festivalRest = festivalMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $datePanel: $xeDatePanel });
        const festivalItem = festivalRest ? import_xe_utils36.default.isString(festivalRest) ? { label: festivalRest } : festivalRest : {};
        const extraItem = festivalItem.extra ? import_xe_utils36.default.isString(festivalItem.extra) ? { label: festivalItem.extra } : festivalItem.extra : null;
        labelVNs.push(h("div", {
          class: ["vxe-date-panel--label", {
            "is-notice": festivalItem.notice
          }]
        }, extraItem && extraItem.label ? [
          h("div", `${label}`),
          h("div", {
            class: ["vxe-date-panel--label--extra", extraItem.important ? "is-important" : "", extraItem.className],
            style: extraItem.style
          }, import_xe_utils36.default.toValueString(extraItem.label))
        ] : `${label}`));
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          const festivalLabels = import_xe_utils36.default.toValueString(festivalLabel).split(",");
          labelVNs.push(h("div", {
            class: ["vxe-date-panel--festival", festivalItem.important ? "is-important" : "", festivalItem.className],
            style: festivalItem.style
          }, [
            festivalLabels.length > 1 ? h("div", {
              class: ["vxe-date-panel--festival--overlap", `overlap--${festivalLabels.length}`]
            }, festivalLabels.map((label2) => h("div", label2.substring(0, 3)))) : h("div", {
              class: "vxe-date-panel--festival--label"
            }, festivalLabels[0].substring(0, 3))
          ]));
        }
      }
      return labelVNs;
    };
    const renderDateDayTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("div", {
          class: ["vxe-date-panel--view-wrapper", `type--${datePanelType}`]
        }, [
          h("div", {
            class: "vxe-date-panel--view-header"
          }, [
            h("div", {
              class: "vxe-date-panel--view-row"
            }, dateHeaders.map((item) => {
              return h("div", {
                class: "vxe-date-panel--view-item",
                style: {
                  width: `${100 / dateHeaders.length}%`
                }
              }, [
                h("div", {
                  class: "vxe-date-panel--view-item-inner"
                }, [
                  h("div", {
                    class: "vxe-date-panel--view-item-label"
                  }, item.label)
                ])
              ]);
            }))
          ]),
          h("div", {
            class: "vxe-date-panel--view-body"
          }, dayDatas.map((rows) => {
            return h("div", {
              class: "vxe-date-panel--view-row",
              style: {
                height: `${100 / dayDatas.length}%`
              }
            }, rows.map((item) => {
              const isSelected = multiple ? dateListValue.some((val) => import_xe_utils36.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils36.default.isDateSame(dateValue, item.date, matchFormat);
              return h("div", {
                class: ["vxe-date-panel--view-item", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--range-disabled": isRangeDisabled(item),
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--over": overCount && !isSelected,
                  "is--hover": !overCount && import_xe_utils36.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                style: {
                  width: `${100 / rows.length}%`
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item),
                onMouseleave: dateMouseleaveEvent
              }, [
                h("div", {
                  class: "vxe-date-panel--view-item-inner"
                }, renderDateLabel(item, item.label))
              ]);
            }));
          }))
        ])
      ];
    };
    const renderDateWeekTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("div", {
          class: ["vxe-date-panel--view-wrapper", `type--${datePanelType}`]
        }, [
          h("div", {
            class: "vxe-date-panel--view-header"
          }, [
            h("div", {
              class: "vxe-date-panel--view-row"
            }, weekHeaders.map((item, rIndex) => {
              return h("div", {
                class: "vxe-date-panel--view-item",
                style: {
                  width: `${rIndex ? 13 : 9}%`
                }
              }, [
                h("div", {
                  class: "vxe-date-panel--view-item-inner"
                }, [
                  h("div", {
                    class: "vxe-date-panel--view-item-label"
                  }, item.label)
                ])
              ]);
            }))
          ]),
          h("div", {
            class: "vxe-date-panel--view-body"
          }, weekDates.map((rows) => {
            const isSelected = multiple ? rows.some((item) => dateListValue.some((val) => import_xe_utils36.default.isDateSame(val, item.date, matchFormat))) : rows.some((item) => import_xe_utils36.default.isDateSame(dateValue, item.date, matchFormat));
            const isHover = rows.some((item) => import_xe_utils36.default.isDateSame(datePanelValue, item.date, matchFormat));
            const isNowWeek = rows.some((item) => item.isNow);
            return h("div", {
              class: "vxe-date-panel--view-row",
              style: {
                height: `${100 / weekDates.length}%`
              }
            }, rows.map((item, rIndex) => {
              return h("div", {
                class: ["vxe-date-panel--view-item", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": rIndex ? item.isNow : isNowWeek,
                  "is--next": item.isNext,
                  "is--range-disabled": isRangeDisabled(item),
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--over": overCount && !isSelected,
                  "is--hover": !overCount && isHover
                }],
                style: {
                  width: `${rIndex ? 13 : 9}%`
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item),
                onMouseleave: dateMouseleaveEvent
              }, [
                h("div", {
                  class: "vxe-date-panel--view-item-inner"
                }, renderDateLabel(item, item.label))
              ]);
            }));
          }))
        ])
      ];
    };
    const renderDateMonthTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = "yyyyMM";
      return [
        h("div", {
          class: ["vxe-date-panel--view-wrapper", `type--${datePanelType}`]
        }, [
          h("div", {
            class: "vxe-date-panel--view-body"
          }, monthDatas.map((rows) => {
            return h("div", {
              class: "vxe-date-panel--view-row",
              style: {
                height: `${100 / monthDatas.length}%`
              }
            }, rows.map((item) => {
              const isSelected = multiple ? dateListValue.some((val) => import_xe_utils36.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils36.default.isDateSame(dateValue, item.date, matchFormat);
              return h("div", {
                class: ["vxe-date-panel--view-item", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--range-disabled": isRangeDisabled(item),
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--over": overCount && !isSelected,
                  "is--hover": !overCount && import_xe_utils36.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                style: {
                  width: `${100 / rows.length}%`
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item),
                onMouseleave: dateMouseleaveEvent
              }, [
                h("div", {
                  class: "vxe-date-panel--view-item-inner"
                }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)))
              ]);
            }));
          }))
        ])
      ];
    };
    const renderDateQuarterTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = "yyyyq";
      return [
        h("div", {
          class: ["vxe-date-panel--view-wrapper", `type--${datePanelType}`]
        }, [
          h("div", {
            class: "vxe-date-panel--view-body"
          }, quarterDatas.map((rows) => {
            return h("div", {
              class: "vxe-date-panel--view-row",
              style: {
                height: `${100 / quarterDatas.length}%`
              }
            }, rows.map((item) => {
              const isSelected = multiple ? dateListValue.some((val) => import_xe_utils36.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils36.default.isDateSame(dateValue, item.date, matchFormat);
              return h("div", {
                class: ["vxe-date-panel--view-item", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--range-disabled": isRangeDisabled(item),
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--over": overCount && !isSelected,
                  "is--hover": !overCount && import_xe_utils36.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                style: {
                  width: `${100 / rows.length}%`
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item),
                onMouseleave: dateMouseleaveEvent
              }, [
                h("div", {
                  class: "vxe-date-panel--view-item-inner"
                }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)))
              ]);
            }));
          }))
        ])
      ];
    };
    const renderDateYearTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = "yyyy";
      return [
        h("div", {
          class: ["vxe-date-panel--view-wrapper", `type--${datePanelType}`]
        }, [
          h("div", {
            class: "vxe-date-panel--view-body"
          }, yearDatas.map((rows) => {
            return h("div", {
              class: "vxe-date-panel--view-row",
              style: {
                height: `${100 / yearDatas.length}%`
              }
            }, rows.map((item) => {
              const isSelected = multiple ? dateListValue.some((val) => import_xe_utils36.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils36.default.isDateSame(dateValue, item.date, matchFormat);
              return h("div", {
                class: ["vxe-date-panel--view-item", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--range-disabled": isRangeDisabled(item),
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--over": overCount && !isSelected,
                  "is--hover": !overCount && import_xe_utils36.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                style: {
                  width: `${100 / rows.length}%`
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item),
                onMouseleave: dateMouseleaveEvent
              }, [
                h("div", {
                  class: "vxe-date-panel--view-item-inner"
                }, renderDateLabel(item, item.year))
              ]);
            }));
          }))
        ])
      ];
    };
    const renderDateTable = () => {
      const { datePanelType } = reactData;
      switch (datePanelType) {
        case "week":
          return renderDateWeekTable();
        case "month":
          return renderDateMonthTable();
        case "quarter":
          return renderDateQuarterTable();
        case "year":
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const { datePanelType } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelObj = computeSelectDatePanelObj.value;
      return [
        h("div", {
          class: "vxe-date-panel--picker-header"
        }, [
          h("div", {
            class: "vxe-date-panel--picker-type-wrapper"
          }, [
            datePanelType === "year" ? h("span", {
              class: "vxe-date-panel--picker-label"
            }, selectDatePanelObj.y) : h("span", {
              class: "vxe-date-panel--picker-btns"
            }, [
              h("span", {
                class: "vxe-date-panel--picker-btn",
                onClick: dateToggleYearTypeEvent
              }, selectDatePanelObj.y),
              selectDatePanelObj.m ? h("span", {
                class: "vxe-date-panel--picker-btn",
                onClick: dateToggleMonthTypeEvent
              }, selectDatePanelObj.m) : renderEmptyElement($xeDatePanel)
            ])
          ]),
          h("div", {
            class: "vxe-date-panel--picker-btn-wrapper"
          }, [
            h("span", {
              class: ["vxe-date-panel--picker-btn vxe-date-panel--picker-prev-btn", {
                "is--disabled": isDisabledPrevDateBtn
              }],
              onClick: datePrevEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-left"
              })
            ]),
            h("span", {
              class: "vxe-date-panel--picker-btn vxe-date-panel--picker-current-btn",
              onClick: dateTodayMonthEvent
            }, [
              h("i", {
                class: "vxe-icon-dot"
              })
            ]),
            h("span", {
              class: ["vxe-date-panel--picker-btn vxe-date-panel--picker-next-btn", {
                "is--disabled": isDisabledNextDateBtn
              }],
              onClick: dateNextEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-right"
              })
            ])
          ])
        ]),
        h("div", {
          class: "vxe-date-panel--picker-body"
        }, renderDateTable())
      ];
    };
    const renderTimePanel = () => {
      const { type } = props;
      const { datetimePanelValue } = reactData;
      const dateTimeLabel = computeDateTimeLabel.value;
      const hourList = computeHourList.value;
      const hasTimeMinute = computeHasTimeMinute.value;
      const minuteList = computeMinuteList.value;
      const hasTimeSecond = computeHasTimeSecond.value;
      const secondList = computeSecondList.value;
      return [
        type === "time" ? renderEmptyElement($xeDatePanel) : h("div", {
          class: "vxe-date-panel--time-header"
        }, [
          h("div", {
            class: "vxe-date-panel--time-title"
          }, dateTimeLabel)
        ]),
        h("div", {
          ref: refInputTimeBody,
          class: "vxe-date-panel--time-body"
        }, [
          h("ul", {
            class: "vxe-date-panel--time-hour-list"
          }, hourList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getHours() === item.value
              },
              onClick: (evnt) => dateHourEvent(evnt, item)
            }, item.label);
          })),
          hasTimeMinute ? h("ul", {
            class: "vxe-date-panel--time-minute-list"
          }, minuteList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getMinutes() === item.value
              },
              onClick: (evnt) => dateMinuteEvent(evnt, item)
            }, item.label);
          })) : renderEmptyElement($xeDatePanel),
          hasTimeMinute && hasTimeSecond ? h("ul", {
            class: "vxe-date-panel--time-second-list"
          }, secondList.map((item, index) => {
            return h("li", {
              key: index,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getSeconds() === item.value
              },
              onClick: (evnt) => dateSecondEvent(evnt, item)
            }, item.label);
          })) : renderEmptyElement($xeDatePanel)
        ])
      ];
    };
    const renderPickerPanel = () => {
      const { type } = props;
      if (type === "datetime") {
        return h("div", {
          key: type,
          ref: refPanelWrapper,
          class: "vxe-date-panel--time-layout-wrapper"
        }, [
          h("div", {
            class: "vxe-date-panel--time-left-wrapper"
          }, renderDatePanel()),
          h("div", {
            class: "vxe-date-panel--time-right-wrapper"
          }, renderTimePanel())
        ]);
      } else if (type === "time") {
        return h("div", {
          key: type,
          ref: refPanelWrapper,
          class: "vxe-date-panel--wrapper"
        }, renderTimePanel());
      }
      return h("div", {
        key: type || "default",
        ref: refPanelWrapper,
        class: "vxe-date-panel--wrapper"
      }, renderDatePanel());
    };
    const renderVN = () => {
      const { type } = props;
      const vSize = computeSize.value;
      return h("div", {
        class: ["vxe-date-panel", `type--${type}`, {
          [`size--${vSize}`]: vSize
        }]
      }, [
        renderPickerPanel()
      ]);
    };
    watch(() => props.modelValue, (val) => {
      updateModelValue(val);
      changeValue();
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        inputLabel: "",
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    watch(computeDateLabelFormat, () => {
      const isDatePanelType = computeIsDatePanelType.value;
      if (isDatePanelType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputLabel = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    initValue();
    dateOpenPanel();
    $xeDatePanel.renderVN = renderVN;
    return $xeDatePanel;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/date-panel/index.js
var VxeDatePanel = Object.assign({}, date_panel_default, {
  install(app) {
    app.component(date_panel_default.name, date_panel_default);
  }
});
dynamicApp.use(VxeDatePanel);
VxeUI.component(date_panel_default);
var DatePanel = VxeDatePanel;
var date_panel_default2 = VxeDatePanel;

// node_modules/vxe-pc-ui/es/date-picker/src/date-picker.js
var import_xe_utils37 = __toESM(require_xe_utils());
var date_picker_default = defineVxeComponent({
  name: "VxeDatePicker",
  props: {
    modelValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: "date"
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().datePicker.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    autoComplete: {
      type: String,
      default: "off"
    },
    form: String,
    className: String,
    zIndex: Number,
    size: {
      type: String,
      default: () => getConfig().datePicker.size || getConfig().size
    },
    multiple: Boolean,
    limitCount: {
      type: [String, Number],
      default: () => getConfig().datePicker.limitCount
    },
    // date、week、month、quarter、year
    startDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePicker.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePicker.endDate
    },
    defaultDate: [String, Number, Date],
    defaultTime: [String, Number, Date],
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    startDay: {
      type: [String, Number],
      default: () => getConfig().datePicker.startDay
    },
    labelFormat: String,
    valueFormat: String,
    timeFormat: String,
    editable: {
      type: Boolean,
      default: true
    },
    festivalMethod: {
      type: Function,
      default: () => getConfig().datePicker.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().datePicker.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().datePicker.selectDay
    },
    showClearButton: {
      type: Boolean,
      default: () => getConfig().datePicker.showClearButton
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().datePicker.showConfirmButton
    },
    autoClose: {
      type: Boolean,
      default: () => getConfig().datePicker.autoClose
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    shortcutConfig: Object,
    // 已废弃 startWeek，被 startDay 替换
    startWeek: Number
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "click",
    "focus",
    "blur",
    "clear",
    "confirm",
    "prefix-click",
    "suffix-click",
    "date-prev",
    "date-today",
    "date-next",
    "shortcut-click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils37.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      panelIndex: 0,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: {},
      panelPlacement: "",
      isActivated: false,
      inputValue: "",
      inputLabel: ""
    });
    const internalData = {
      hpTimeout: void 0
    };
    const refElem = ref();
    const refInputTarget = ref();
    const refInputPanel = ref();
    const refPanelWrapper = ref();
    const refDatePanel = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeDatePicker = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().datePicker.transfer;
        if (import_xe_utils37.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsDateTimeType = computed(() => {
      const { type } = props;
      return type === "time" || type === "datetime";
    });
    const computeIsDatePickerType = computed(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeIsClearable = computed(() => {
      return props.clearable;
    });
    const computeInputReadonly = computed(() => {
      const { type, editable, multiple } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || multiple || !editable || type === "week" || type === "quarter";
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().datePicker.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseSelect");
    });
    const computeInpImmediate = computed(() => {
      const { immediate } = props;
      return immediate;
    });
    const computeShortcutOpts = computed(() => {
      return Object.assign({}, getConfig().datePicker.shortcutConfig, props.shortcutConfig);
    });
    const computeShortcutList = computed(() => {
      const shortcutOpts = computeShortcutOpts.value;
      const { options } = shortcutOpts;
      if (options) {
        return options.map((option, index) => {
          return Object.assign({
            name: `${option.name || option.code || index}`
          }, option);
        });
      }
      return [];
    });
    const computeDateLabelFormat = computed(() => {
      const { labelFormat } = props;
      return labelFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
    });
    const computeDateValueFormat = computed(() => {
      const { type, valueFormat } = props;
      return handleValueFormat(type, valueFormat);
    });
    const computeFirstDayOfWeek = computed(() => {
      const { startDay } = props;
      return import_xe_utils37.default.toNumber(startDay);
    });
    const computePanelLabel = computed(() => {
      const { type, multiple } = props;
      const { inputValue } = reactData;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const vals = inputValue ? multiple ? inputValue.split(",") : [inputValue] : [];
      return vals.map((val) => {
        const dateObj = parseDateObj(val, type, {
          valueFormat: dateValueFormat,
          labelFormat: dateLabelFormat,
          firstDay: firstDayOfWeek
        });
        return dateObj.label;
      }).join(", ");
    });
    const updateModelValue = () => {
      const { modelValue } = props;
      let val = "";
      if (modelValue) {
        if (import_xe_utils37.default.isNumber(modelValue) && /^[0-9]{11,15}$/.test(`${modelValue}`)) {
          val = new Date(modelValue);
        } else {
          val = modelValue;
        }
      }
      reactData.inputValue = val;
    };
    const triggerEvent = (evnt) => {
      const { inputValue } = reactData;
      dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const handleChange = (value, evnt) => {
      const { type, modelValue, valueFormat } = props;
      const dateValueFormat = computeDateValueFormat.value;
      reactData.inputValue = value;
      if (hasTimestampValueType(valueFormat)) {
        const dateVal = parseDateValue(value, type, { valueFormat: dateValueFormat });
        const timeNum = dateVal ? dateVal.getTime() : null;
        emit("update:modelValue", timeNum);
        if (modelValue !== timeNum) {
          dispatchEvent("change", { value: timeNum }, evnt);
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, timeNum);
          }
        }
      } else if (hasDateValueType(valueFormat)) {
        const dateVal = parseDateValue(value, type, { valueFormat: dateValueFormat });
        emit("update:modelValue", dateVal);
        if (modelValue && dateVal ? import_xe_utils37.default.toStringDate(modelValue).getTime() !== dateVal.getTime() : modelValue !== dateVal) {
          dispatchEvent("change", { value: dateVal }, evnt);
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, dateVal);
          }
        }
      } else {
        emit("update:modelValue", value);
        if (import_xe_utils37.default.toValueString(modelValue) !== value) {
          dispatchEvent("change", { value }, evnt);
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
          }
        }
      }
    };
    const inputEvent = (evnt) => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      reactData.inputLabel = value;
      dispatchEvent("input", { value }, evnt);
    };
    const changeEvent = (evnt) => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent(evnt);
    };
    const clickPrefixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    const hidePanel = () => {
      return new Promise((resolve) => {
        reactData.visiblePanel = false;
        internalData.hpTimeout = setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      handleChange("", evnt);
      dispatchEvent("clear", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        dispatchEvent("suffix-click", { value: inputValue }, evnt);
      }
    };
    const blurEvent = (evnt) => {
      const $datePanel = refDatePanel.value;
      const { inputValue } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue;
      if (!inpImmediate) {
        handleChange(value, evnt);
      }
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
        if ($datePanel) {
          $datePanel.checkValue(reactData.inputLabel);
        }
      }
      dispatchEvent("blur", { value }, evnt);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const keydownEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const keyupEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const confirmEvent = (evnt) => {
      const $datePanel = refDatePanel.value;
      if ($datePanel) {
        $datePanel.confirmByEvent(evnt);
      }
      hidePanel();
    };
    const panelChangeEvent = (params) => {
      const { multiple, autoClose } = props;
      const { value, $event } = params;
      const isDateTimeType = computeIsDateTimeType.value;
      handleChange(value, $event);
      if (!multiple && !isDateTimeType) {
        if (autoClose) {
          hidePanel();
        }
      }
    };
    const panelConfirmEvent = (params) => {
      dispatchEvent("confirm", params, params.$event);
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const $datePanel = refDatePanel.value;
      const { visiblePanel, isActivated } = reactData;
      const el = refElem.value;
      const panelWrapperElem = refPanelWrapper.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          if (visiblePanel) {
            hidePanel();
            if ($datePanel) {
              $datePanel.checkValue(reactData.inputLabel);
            }
          }
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hidePanel();
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelWrapperElem = refPanelWrapper.value;
          if (getEventTargetNode(evnt, panelWrapperElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const $datePanel = refDatePanel.value;
      const { isActivated, visiblePanel } = reactData;
      if (visiblePanel) {
        hidePanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        if ($datePanel) {
          $datePanel.checkValue(reactData.inputLabel);
        }
        const targetElem = refInputTarget.value;
        if (targetElem) {
          targetElem.blur();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const { visiblePanel } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    const updateZindex = () => {
      const { zIndex } = props;
      if (zIndex) {
        reactData.panelIndex = zIndex;
      } else if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const { placement } = props;
      const { panelIndex } = reactData;
      const targetElem = refInputTarget.value;
      const panelElem = refInputPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return nextTick().then(handleStyle);
    };
    const showPanel = () => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        if (internalData.hpTimeout) {
          clearTimeout(internalData.hpTimeout);
          internalData.hpTimeout = void 0;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return nextTick();
    };
    const datePickerOpenEvent = (evnt) => {
      const formReadonly = computeFormReadonly.value;
      if (!formReadonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const handleShortcutEvent = ({ option, $event }) => {
      const { type } = props;
      const { inputValue } = reactData;
      const shortcutOpts = computeShortcutOpts.value;
      const { autoClose } = shortcutOpts;
      const { code, clickMethod } = option;
      let value = inputValue;
      const shortcutParams = {
        $datePicker: $xeDatePicker,
        option,
        value,
        code
      };
      if (!clickMethod && code) {
        const gCommandOpts = commands.get(code);
        const dpCommandMethod = gCommandOpts ? gCommandOpts.datePickerCommandMethod : null;
        if (dpCommandMethod) {
          dpCommandMethod(shortcutParams);
        } else {
          const dateValueFormat = computeDateValueFormat.value;
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          switch (code) {
            case "now":
            case "prev":
            case "next":
            case "minus":
            case "plus": {
              const restObj = getDateByCode(code, value, type, {
                valueFormat: dateValueFormat,
                firstDay: firstDayOfWeek
              });
              value = restObj.value;
              shortcutParams.value = value;
              handleChange(value, $event);
              break;
            }
            default:
              errLog("vxe.error.notCommands", [`[date-picker] ${code}`]);
              break;
          }
        }
      } else {
        const optClickMethod = clickMethod || shortcutOpts.clickMethod;
        if (optClickMethod) {
          optClickMethod(shortcutParams);
        }
      }
      if (autoClose) {
        hidePanel();
      }
      dispatchEvent("shortcut-click", shortcutParams, $event);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $datePicker: $xeDatePicker }, params));
    };
    const datePickerMethods = {
      dispatchEvent,
      setModelValue(value) {
        reactData.inputValue = value;
        emit("update:modelValue", value);
      },
      setModelValueByEvent(evnt, value) {
        handleChange(value || "", evnt);
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeDatePicker, datePickerMethods);
    const renderShortcutBtn = (pos, isVertical) => {
      const shortcutOpts = computeShortcutOpts.value;
      const { position, align, mode } = shortcutOpts;
      const shortcutList = computeShortcutList.value;
      if (isEnableConf(shortcutOpts) && shortcutList.length && (position || "left") === pos) {
        return h("div", {
          class: `vxe-date-picker--layout-${pos}-wrapper`
        }, [
          h(button_group_default, {
            options: shortcutList,
            mode,
            align,
            vertical: isVertical,
            onClick: handleShortcutEvent
          })
        ]);
      }
      return renderEmptyElement($xeDatePicker);
    };
    const renderPanel = () => {
      const { type, multiple, showClearButton, showConfirmButton } = props;
      const { initialized, isAniVisible, visiblePanel, panelPlacement, panelStyle, inputValue } = reactData;
      const vSize = computeSize.value;
      const btnTransfer = computeBtnTransfer.value;
      const shortcutOpts = computeShortcutOpts.value;
      const isClearable = computeIsClearable.value;
      const isDateTimeType = computeIsDateTimeType.value;
      const shortcutList = computeShortcutList.value;
      const { position } = shortcutOpts;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const leftSlot = slots.left;
      const rightSlot = slots.right;
      const hasShortcutBtn = shortcutList.length > 0;
      const showConfirmBtn = showConfirmButton === null ? isDateTimeType || multiple : showConfirmButton;
      const showClearBtn = showClearButton === null ? isClearable && showConfirmBtn && type !== "time" : showClearButton;
      return h(Teleport, {
        to: "body",
        disabled: btnTransfer ? !initialized : true
      }, [
        h("div", {
          ref: refInputPanel,
          class: ["vxe-table--ignore-clear vxe-date-picker--panel", `type--${type}`, {
            [`size--${vSize}`]: vSize,
            "is--transfer": btnTransfer,
            "ani--leave": isAniVisible,
            "ani--enter": visiblePanel,
            "show--top": !!(topSlot || headerSlot || hasShortcutBtn && (position === "top" || position === "header")),
            "show--bottom": !!(bottomSlot || footerSlot || hasShortcutBtn && (position === "bottom" || position === "footer")),
            "show--left": !!(leftSlot || hasShortcutBtn && position === "left"),
            "show--right": !!(rightSlot || hasShortcutBtn && position === "right")
          }],
          placement: panelPlacement,
          style: panelStyle
        }, initialized && (visiblePanel || isAniVisible) ? [
          h("div", {
            ref: refPanelWrapper,
            class: ["vxe-date-picker--layout-all-wrapper", `type--${type}`, {
              [`size--${vSize}`]: vSize
            }]
          }, [
            topSlot ? h("div", {
              class: "vxe-date-picker--layout-top-wrapper"
            }, topSlot({})) : renderShortcutBtn("top"),
            h("div", {
              class: "vxe-date-picker--layout-body-layout-wrapper"
            }, [
              leftSlot ? h("div", {
                class: "vxe-date-picker--layout-left-wrapper"
              }, leftSlot({})) : renderShortcutBtn("left", true),
              h("div", {
                class: "vxe-date-picker--layout-body-content-wrapper"
              }, [
                headerSlot ? h("div", {
                  class: "vxe-date-picker--layout-header-wrapper"
                }, headerSlot({})) : renderShortcutBtn("header"),
                h("div", {
                  class: "vxe-date-picker--layout-body-wrapper"
                }, [
                  h(date_panel_default, {
                    ref: refDatePanel,
                    modelValue: reactData.inputValue,
                    type: props.type,
                    className: props.className,
                    multiple: props.multiple,
                    limitCount: props.limitCount,
                    startDate: props.startDate,
                    endDate: props.endDate,
                    defaultDate: props.defaultDate,
                    defaultTime: props.defaultTime,
                    minDate: props.minDate,
                    maxDate: props.maxDate,
                    startDay: props.startDay,
                    labelFormat: props.labelFormat,
                    valueFormat: props.valueFormat,
                    timeFormat: props.timeFormat,
                    festivalMethod: props.festivalMethod,
                    disabledMethod: props.disabledMethod,
                    selectDay: props.selectDay,
                    onChange: panelChangeEvent,
                    onConfirm: panelConfirmEvent
                  })
                ]),
                h("div", {
                  class: "vxe-date-picker--layout-footer-wrapper"
                }, [
                  h("div", {
                    class: "vxe-date-picker--layout-footer-custom"
                  }, footerSlot ? footerSlot({}) : [renderShortcutBtn("footer")]),
                  showClearBtn || showConfirmBtn ? h("div", {
                    class: "vxe-date-picker--layout-footer-btns"
                  }, [
                    showClearBtn ? h(button_default, {
                      size: "mini",
                      disabled: inputValue === "" || import_xe_utils37.default.eqNull(inputValue),
                      content: getI18n("vxe.button.clear"),
                      onClick: clearValueEvent
                    }) : renderEmptyElement($xeDatePicker),
                    showConfirmBtn ? h(button_default, {
                      size: "mini",
                      status: "primary",
                      content: getI18n("vxe.button.confirm"),
                      onClick: confirmEvent
                    }) : renderEmptyElement($xeDatePicker)
                  ]) : renderEmptyElement($xeDatePicker)
                ])
              ]),
              rightSlot ? h("div", {
                class: "vxe-date-picker--layout-right-wrapper"
              }, rightSlot({})) : renderShortcutBtn("right", true)
            ]),
            bottomSlot ? h("div", {
              class: "vxe-date-picker--layout-bottom-wrapper"
            }, bottomSlot({})) : renderShortcutBtn("bottom")
          ])
        ] : [])
      ]);
    };
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "vxe-date-picker--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "vxe-date-picker--prefix-icon"
        }, prefixSlot ? getSlotVNs2(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : null;
    };
    const renderSuffixIcon2 = () => {
      const { suffixIcon } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isClearable = computeIsClearable.value;
      return h("div", {
        class: ["vxe-date-picker--suffix", {
          "is--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils37.default.eqNull(inputValue))
        }]
      }, [
        isClearable ? h("div", {
          class: "vxe-date-picker--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : renderEmptyElement($xeDatePicker),
        renderExtraSuffixIcon(),
        suffixSlot || suffixIcon ? h("div", {
          class: "vxe-date-picker--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs2(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : renderEmptyElement($xeDatePicker)
      ]);
    };
    const renderExtraSuffixIcon = () => {
      return h("div", {
        class: "vxe-date-picker--control-icon",
        onClick: datePickerOpenEvent
      }, [
        h("i", {
          class: ["vxe-date-picker--date-picker-icon", getIcon().DATE_PICKER_DATE]
        })
      ]);
    };
    const renderVN = () => {
      const { className, type, name, autoComplete } = props;
      const { inputValue, inputLabel, visiblePanel, isActivated } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const panelLabel = computePanelLabel.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-date-picker--readonly", `type--${type}`, className]
        }, panelLabel);
      }
      const inputReadonly = computeInputReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon2();
      const suffix = renderSuffixIcon2();
      return h("div", {
        ref: refElem,
        class: ["vxe-date-picker", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--active": isActivated,
          "show--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils37.default.eqNull(inputValue))
        }],
        spellcheck: false
      }, [
        prefix || renderEmptyElement($xeDatePicker),
        h("div", {
          class: "vxe-date-picker--wrapper"
        }, [
          h("input", {
            ref: refInputTarget,
            class: "vxe-date-picker--inner",
            value: inputLabel,
            name,
            type: "text",
            placeholder: inpPlaceholder,
            readonly: inputReadonly,
            disabled: isDisabled,
            autocomplete: autoComplete,
            onKeydown: keydownEvent,
            onKeyup: keyupEvent,
            onClick: clickEvent,
            onInput: inputEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        suffix || renderEmptyElement($xeDatePicker),
        // 下拉面板
        renderPanel()
      ]);
    };
    watch(computePanelLabel, (val) => {
      reactData.inputLabel = val;
    });
    watch(() => props.modelValue, () => {
      updateModelValue();
    });
    nextTick(() => {
      globalEvents.on($xeDatePicker, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeDatePicker, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeDatePicker, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeDatePicker, "blur", handleGlobalBlurEvent);
      globalEvents.on($xeDatePicker, "resize", handleGlobalResizeEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeDatePicker, "mousewheel");
      globalEvents.off($xeDatePicker, "mousedown");
      globalEvents.off($xeDatePicker, "blur");
      globalEvents.off($xeDatePicker, "resize");
    });
    updateModelValue();
    provide("$xeDatePicker", $xeDatePicker);
    $xeDatePicker.renderVN = renderVN;
    return $xeDatePicker;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/date-picker/index.js
var VxeDatePicker = Object.assign({}, date_picker_default, {
  install(app) {
    app.component(date_picker_default.name, date_picker_default);
  }
});
dynamicApp.use(VxeDatePicker);
VxeUI.component(date_picker_default);
var DatePicker = VxeDatePicker;
var date_picker_default2 = VxeDatePicker;

// node_modules/vxe-pc-ui/es/date-range-picker/src/date-range-picker.js
var import_xe_utils38 = __toESM(require_xe_utils());
var date_range_picker_default = defineVxeComponent({
  name: "VxeDateRangePicker",
  props: {
    modelValue: [String, Number, Date, Array],
    startValue: [String, Number, Date],
    endValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: "date"
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().dateRangePicker.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    autoComplete: {
      type: String,
      default: "off"
    },
    form: String,
    className: String,
    zIndex: Number,
    size: {
      type: String,
      default: () => getConfig().dateRangePicker.size || getConfig().size
    },
    // startDate: {
    //   type: [String, Number, Date] as PropType<VxeDateRangePickerPropTypes.StartDate>,
    //   default: () => getConfig().dateRangePicker.startDate
    // },
    // endDate: {
    //   type: [String, Number, Date] as PropType<VxeDateRangePickerPropTypes.EndDate>,
    //   default: () => getConfig().dateRangePicker.endDate
    // },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    defaultDate: [String, Number, Date, Array],
    defaultTime: [String, Number, Date, Array],
    startDay: {
      type: [String, Number],
      default: () => getConfig().dateRangePicker.startDay
    },
    labelFormat: String,
    valueFormat: String,
    timeFormat: String,
    valueType: String,
    editable: {
      type: Boolean,
      default: true
    },
    festivalMethod: {
      type: Function,
      default: () => getConfig().dateRangePicker.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().dateRangePicker.disabledMethod
    },
    separator: {
      type: [String, Number],
      default: () => getConfig().dateRangePicker.separator
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().dateRangePicker.selectDay
    },
    showClearButton: {
      type: Boolean,
      default: () => getConfig().dateRangePicker.showClearButton
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().dateRangePicker.showConfirmButton
    },
    autoClose: {
      type: Boolean,
      default: () => getConfig().dateRangePicker.autoClose
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    shortcutConfig: Object
  },
  emits: [
    "update:modelValue",
    "update:startValue",
    "update:endValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "click",
    "focus",
    "blur",
    "clear",
    "confirm",
    "prefix-click",
    "suffix-click",
    "date-prev",
    "date-today",
    "date-next",
    "shortcut-click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils38.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      panelIndex: 0,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: {},
      panelPlacement: "",
      isActivated: false,
      startValue: "",
      endValue: ""
    });
    const internalData = {
      // selectStatus: false
      // hpTimeout: undefined
    };
    const refElem = ref();
    const refInputTarget = ref();
    const refInputPanel = ref();
    const refPanelWrapper = ref();
    const refStartDatePanel = ref();
    const refEndDatePanel = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeDateRangePicker = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let dateRangePickerMethods = {};
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().dateRangePicker.transfer;
        if (import_xe_utils38.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeDefaultDates = computed(() => {
      const { defaultDate } = props;
      if (defaultDate) {
        if (import_xe_utils38.default.isArray(defaultDate)) {
          return defaultDate;
        }
        if (`${defaultDate}`.indexOf(",") > -1) {
          return `${defaultDate}`.split(",");
        }
        return [defaultDate, defaultDate];
      }
      return [];
    });
    const computeDefaultTimes = computed(() => {
      const { defaultTime } = props;
      if (defaultTime) {
        if (import_xe_utils38.default.isArray(defaultTime)) {
          return defaultTime;
        }
        if (`${defaultTime}`.indexOf(",") > -1) {
          return `${defaultTime}`.split(",");
        }
        return [defaultTime, defaultTime];
      }
      return [];
    });
    const computeMVal = computed(() => {
      const { startValue, endValue } = props;
      return `${startValue || ""}${endValue || ""}`;
    });
    const computeIsDateTimeType = computed(() => {
      const { type } = props;
      return type === "time" || type === "datetime";
    });
    const computeIsDatePickerType = computed(() => {
      return ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeIsClearable = computed(() => {
      return props.clearable;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().dateRangePicker.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n("vxe.dateRangePicker.pleaseRange");
    });
    const computeInpImmediate = computed(() => {
      const { immediate } = props;
      return immediate;
    });
    const computeShortcutOpts = computed(() => {
      return Object.assign({}, getConfig().dateRangePicker.shortcutConfig, props.shortcutConfig);
    });
    const computeShortcutList = computed(() => {
      const shortcutOpts = computeShortcutOpts.value;
      const { options } = shortcutOpts;
      if (options) {
        return options.map((option, index) => {
          return Object.assign({
            name: `${option.name || option.code || index}`
          }, option);
        });
      }
      return [];
    });
    const computeDateLabelFormat = computed(() => {
      const { labelFormat } = props;
      return labelFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
    });
    const computeDateValueFormat = computed(() => {
      const { type, valueFormat } = props;
      return handleValueFormat(type, valueFormat);
    });
    const computeFirstDayOfWeek = computed(() => {
      const { startDay } = props;
      return import_xe_utils38.default.toNumber(startDay);
    });
    const computePanelLabelObj = computed(() => {
      const { startValue, endValue } = reactData;
      const vals = startValue || endValue ? [startValue || "", endValue || ""] : [];
      return formatRangeLabel(vals);
    });
    const computeInputLabel = computed(() => {
      const panelLabelObj = computePanelLabelObj.value;
      return panelLabelObj.label;
    });
    const formatRangeLabel = (vals) => {
      const { type, separator } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const startRest = vals[0] ? parseDateObj(vals[0], type, {
        valueFormat: dateValueFormat,
        labelFormat: dateLabelFormat,
        firstDay: firstDayOfWeek
      }) : null;
      const endRest = vals[1] ? parseDateObj(vals[1], type, {
        valueFormat: dateValueFormat,
        labelFormat: dateLabelFormat,
        firstDay: firstDayOfWeek
      }) : null;
      const startLabel = startRest ? startRest.label : "";
      const endLabel = endRest ? endRest.label : "";
      return {
        label: (startLabel || endLabel ? [startLabel, endLabel] : []).join(`${separator || " ~ "}`),
        startLabel,
        endLabel
      };
    };
    const getRangeValue = (sValue, eValue) => {
      const { modelValue, valueType } = props;
      let isArr = import_xe_utils38.default.isArray(modelValue);
      if (valueType) {
        switch (valueType) {
          case "array":
            isArr = true;
            break;
          case "string":
            isArr = false;
            break;
        }
      }
      if (sValue || eValue) {
        const rest = [sValue || "", eValue || ""];
        if (isArr) {
          return rest;
        }
        return rest.join(",");
      }
      return isArr ? [] : "";
    };
    const paraeUpdateModel = () => {
      const { type, modelValue } = props;
      const dateValueFormat = computeDateValueFormat.value;
      let sValue = "";
      let eValue = "";
      if (import_xe_utils38.default.isArray(modelValue)) {
        const date1 = parseDateString(modelValue[0], type, { valueFormat: dateValueFormat });
        const date2 = parseDateString(modelValue[1], type, { valueFormat: dateValueFormat });
        if (date1 || date2) {
          sValue = date1 || "";
          eValue = date2 || "";
        }
      } else if (import_xe_utils38.default.isString(modelValue)) {
        const strArr = modelValue.split(",");
        if (strArr[0] || strArr[1]) {
          sValue = strArr[0] || "";
          eValue = strArr[1] || "";
        }
      }
      return {
        sValue,
        eValue
      };
    };
    const parseUpdateData = () => {
      const { type, startValue, endValue } = props;
      const dateValueFormat = computeDateValueFormat.value;
      let sValue = "";
      let eValue = "";
      sValue = parseDateString(startValue, type, { valueFormat: dateValueFormat });
      eValue = parseDateString(endValue, type, { valueFormat: dateValueFormat });
      return {
        sValue,
        eValue
      };
    };
    const updateModelValue = (isModel) => {
      const { modelValue, startValue, endValue } = props;
      let restObj = {
        sValue: "",
        eValue: ""
      };
      if (isModel) {
        if (modelValue) {
          restObj = paraeUpdateModel();
        } else {
          restObj = parseUpdateData();
        }
      } else {
        if (startValue || endValue) {
          restObj = parseUpdateData();
        } else {
          restObj = paraeUpdateModel();
        }
      }
      reactData.startValue = restObj.sValue;
      reactData.endValue = restObj.eValue;
    };
    const triggerEvent = (evnt) => {
      const { startValue, endValue } = reactData;
      const value = getRangeValue(startValue, endValue);
      dispatchEvent(evnt.type, { value, startValue, endValue }, evnt);
    };
    const handleChange = (sValue, eValue, evnt) => {
      const { modelValue } = props;
      reactData.startValue = sValue;
      reactData.endValue = eValue;
      const value = getRangeValue(sValue, eValue);
      emit("update:modelValue", value);
      emit("update:startValue", sValue || "");
      emit("update:endValue", eValue || "");
      if (import_xe_utils38.default.toValueString(modelValue) !== value) {
        dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const changeEvent = (evnt) => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      dateRangePickerOpenEvent(evnt);
      triggerEvent(evnt);
    };
    const clickPrefixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { startValue, endValue } = reactData;
        const value = getRangeValue(startValue, endValue);
        dispatchEvent("prefix-click", { value, startValue, endValue }, evnt);
      }
    };
    const hidePanel = () => {
      return new Promise((resolve) => {
        reactData.visiblePanel = false;
        internalData.hpTimeout = setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      const startValue = "";
      const endValue = "";
      handleChange(startValue, endValue, evnt);
      dispatchEvent("clear", { value, startValue, endValue }, evnt);
    };
    const checkValue = () => {
      const $startDatePanel = refStartDatePanel.value;
      const $endDatePanel = refEndDatePanel.value;
      if ($startDatePanel && $endDatePanel) {
        const startValue = $startDatePanel.getModelValue();
        const endValue = $endDatePanel.getModelValue();
        if (!startValue || !endValue) {
          handleChange("", "", { type: "check" });
        }
      }
    };
    const handleSelectClose = () => {
      const { autoClose } = props;
      const { startValue, endValue } = reactData;
      const { selectStatus } = internalData;
      const isDatePickerType = computeIsDatePickerType.value;
      if (autoClose) {
        if (selectStatus && isDatePickerType) {
          if (startValue && endValue) {
            hidePanel();
          }
        }
      } else {
        if (startValue && endValue) {
          internalData.selectStatus = false;
        }
      }
    };
    const clickSuffixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { startValue, endValue } = reactData;
        const value = getRangeValue(startValue, endValue);
        dispatchEvent("suffix-click", { value, startValue, endValue }, evnt);
      }
    };
    const blurEvent = (evnt) => {
      const { startValue, endValue } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = "";
      if (!inpImmediate) {
        handleChange(startValue, endValue, evnt);
      }
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      dispatchEvent("blur", { value, startValue, endValue }, evnt);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const keydownEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const keyupEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const confirmEvent = (evnt) => {
      const $startDatePanel = refStartDatePanel.value;
      const $endDatePanel = refEndDatePanel.value;
      if ($startDatePanel && $endDatePanel) {
        const startValue = $startDatePanel.getModelValue();
        const endValue = $endDatePanel.getModelValue();
        if (startValue && !endValue || !startValue && endValue) {
          handleChange("", "", evnt);
        } else {
          $startDatePanel.confirmByEvent(evnt);
          $endDatePanel.confirmByEvent(evnt);
        }
        const value = getRangeValue(startValue, endValue);
        dispatchEvent("confirm", { value, startValue, endValue }, evnt);
      }
      hidePanel();
    };
    const startPanelChangeEvent = (params) => {
      const { selectStatus } = internalData;
      const { value, $event } = params;
      const endValue = selectStatus ? reactData.endValue : "";
      handleChange(value, endValue, $event);
      handleSelectClose();
      if (!selectStatus) {
        internalData.selectStatus = true;
      }
      nextTick(() => {
        const $startDatePanel = refStartDatePanel.value;
        const $endDatePanel = refEndDatePanel.value;
        if ($startDatePanel && $endDatePanel) {
          const startValue = $startDatePanel.getModelValue();
          if (!endValue && startValue) {
            $endDatePanel.setPanelDate(import_xe_utils38.default.toStringDate(startValue));
          }
        }
      });
    };
    const endPanelChangeEvent = (params) => {
      const { selectStatus } = internalData;
      const { value, $event } = params;
      const startValue = selectStatus ? reactData.startValue : "";
      handleChange(startValue, value, $event);
      handleSelectClose();
      if (!selectStatus) {
        internalData.selectStatus = true;
      }
      nextTick(() => {
        const $startDatePanel = refStartDatePanel.value;
        const $endDatePanel = refEndDatePanel.value;
        if ($startDatePanel && $endDatePanel) {
          const endValue = $endDatePanel.getModelValue();
          if (!startValue && endValue) {
            $startDatePanel.setPanelDate(import_xe_utils38.default.toStringDate(endValue));
          }
        }
      });
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel, isActivated } = reactData;
      const el = refElem.value;
      const panelWrapperElem = refPanelWrapper.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          if (visiblePanel) {
            checkValue();
            hidePanel();
          }
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hidePanel();
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelWrapperElem = refPanelWrapper.value;
          if (getEventTargetNode(evnt, panelWrapperElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { visiblePanel, isActivated } = reactData;
      if (visiblePanel) {
        hidePanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const targetElem = refInputTarget.value;
        if (targetElem) {
          targetElem.blur();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const { visiblePanel } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    const updateZindex = () => {
      const { zIndex } = props;
      if (zIndex) {
        reactData.panelIndex = zIndex;
      } else if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const { placement } = props;
      const { panelIndex } = reactData;
      const targetElem = refInputTarget.value;
      const panelElem = refInputPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return nextTick().then(handleStyle);
    };
    const showPanel = () => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        if (internalData.hpTimeout) {
          clearTimeout(internalData.hpTimeout);
          internalData.hpTimeout = void 0;
        }
        internalData.selectStatus = false;
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return nextTick();
    };
    const dateRangePickerOpenEvent = (evnt) => {
      const formReadonly = computeFormReadonly.value;
      if (!formReadonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const handleShortcutEvent = ({ option, $event }) => {
      const { type } = props;
      const shortcutOpts = computeShortcutOpts.value;
      const { autoClose } = shortcutOpts;
      const { code, clickMethod } = option;
      let startValue = reactData.startValue;
      let endValue = reactData.endValue;
      let value = getRangeValue(startValue, endValue);
      const shortcutParams = {
        $dateRangePicker: $xeDateRangePicker,
        option,
        value,
        startValue,
        endValue,
        code
      };
      if (!clickMethod && code) {
        const gCommandOpts = commands.get(code);
        const drpCommandMethod = gCommandOpts ? gCommandOpts.dateRangePickerCommandMethod : null;
        if (drpCommandMethod) {
          drpCommandMethod(shortcutParams);
        } else {
          const dateValueFormat = computeDateValueFormat.value;
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          switch (code) {
            case "last1":
            case "last3":
            case "last7":
            case "last30":
            case "last60":
            case "last90":
            case "last180": {
              const restObj = getRangeDateByCode(code, value, type, {
                valueFormat: dateValueFormat,
                firstDay: firstDayOfWeek
              });
              startValue = restObj.startValue;
              endValue = restObj.endValue;
              value = getRangeValue(startValue, endValue);
              shortcutParams.value = value;
              shortcutParams.startValue = startValue;
              shortcutParams.endValue = endValue;
              handleChange(startValue, endValue, $event);
              break;
            }
            default:
              errLog("vxe.error.notCommands", [`[date-range-picker] ${code}`]);
              break;
          }
        }
      } else {
        const optClickMethod = clickMethod || shortcutOpts.clickMethod;
        if (optClickMethod) {
          optClickMethod(shortcutParams);
        }
      }
      if (autoClose) {
        hidePanel();
      }
      dispatchEvent("shortcut-click", shortcutParams, $event);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $dateRangePicker: $xeDateRangePicker }, params));
    };
    dateRangePickerMethods = {
      dispatchEvent,
      setModelValue(startValue, endValue) {
        reactData.startValue = startValue || "";
        reactData.endValue = endValue || "";
        const value = getRangeValue(startValue, endValue);
        emit("update:modelValue", value);
      },
      setModelValueByEvent(evnt, startValue, endValue) {
        handleChange(startValue || "", endValue || "", evnt);
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeDateRangePicker, dateRangePickerMethods);
    const renderShortcutBtn = (pos, isVertical) => {
      const shortcutOpts = computeShortcutOpts.value;
      const { position, align, mode } = shortcutOpts;
      const shortcutList = computeShortcutList.value;
      if (isEnableConf(shortcutOpts) && shortcutList.length && (position || "left") === pos) {
        return h("div", {
          class: `vxe-date-range-picker--layout-${pos}-wrapper`
        }, [
          h(button_group_default, {
            options: shortcutList,
            mode,
            align,
            vertical: isVertical,
            onClick: handleShortcutEvent
          })
        ]);
      }
      return renderEmptyElement($xeDateRangePicker);
    };
    const renderPanel = () => {
      const { type, separator, autoClose, showConfirmButton, showClearButton } = props;
      const { initialized, isAniVisible, visiblePanel, panelPlacement, panelStyle, startValue, endValue } = reactData;
      const vSize = computeSize.value;
      const btnTransfer = computeBtnTransfer.value;
      const shortcutOpts = computeShortcutOpts.value;
      const isClearable = computeIsClearable.value;
      const panelLabelObj = computePanelLabelObj.value;
      const shortcutList = computeShortcutList.value;
      const isDateTimeType = computeIsDateTimeType.value;
      const defaultDates = computeDefaultDates.value;
      const defaultTimes = computeDefaultTimes.value;
      const { startLabel, endLabel } = panelLabelObj;
      const { position } = shortcutOpts;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const leftSlot = slots.left;
      const rightSlot = slots.right;
      const [sdDate, edDate] = defaultDates;
      const [sdTime, edTime] = defaultTimes;
      const hasShortcutBtn = shortcutList.length > 0;
      const showConfirmBtn = showConfirmButton === null ? isDateTimeType || !autoClose : showConfirmButton;
      const showClearBtn = showClearButton === null ? isClearable : showClearButton;
      return h(Teleport, {
        to: "body",
        disabled: btnTransfer ? !initialized : true
      }, [
        h("div", {
          ref: refInputPanel,
          class: ["vxe-table--ignore-clear vxe-date-range-picker--panel", `type--${type}`, {
            [`size--${vSize}`]: vSize,
            "is--transfer": btnTransfer,
            "ani--leave": isAniVisible,
            "ani--enter": visiblePanel,
            "show--top": !!(topSlot || headerSlot || hasShortcutBtn && (position === "top" || position === "header")),
            "show--bottom": !!(bottomSlot || footerSlot || hasShortcutBtn && (position === "bottom" || position === "footer")),
            "show--left": !!(leftSlot || hasShortcutBtn && position === "left"),
            "show--right": !!(rightSlot || hasShortcutBtn && position === "right")
          }],
          placement: panelPlacement,
          style: panelStyle
        }, initialized && (visiblePanel || isAniVisible) ? [
          h("div", {
            ref: refPanelWrapper,
            class: ["vxe-date-range-picker--layout-all-wrapper", `type--${type}`, {
              [`size--${vSize}`]: vSize
            }]
          }, [
            topSlot ? h("div", {
              class: "vxe-date-range-picker--layout-top-wrapper"
            }, topSlot({})) : renderShortcutBtn("top"),
            h("div", {
              class: "vxe-date-range-picker--layout-body-layout-wrapper"
            }, [
              leftSlot ? h("div", {
                class: "vxe-date-range-picker--layout-left-wrapper"
              }, leftSlot({})) : renderShortcutBtn("left", true),
              h("div", {
                class: "vxe-date-range-picker--layout-body-content-wrapper"
              }, [
                headerSlot ? h("div", {
                  class: "vxe-date-range-picker--layout-header-wrapper"
                }, headerSlot({})) : renderShortcutBtn("header"),
                h("div", {
                  class: "vxe-date-range-picker--layout-body-wrapper"
                }, [
                  h(date_panel_default, {
                    ref: refStartDatePanel,
                    modelValue: startValue,
                    type: props.type,
                    className: props.className,
                    minDate: props.minDate,
                    maxDate: props.maxDate,
                    endDate: endValue,
                    startDay: props.startDay,
                    labelFormat: props.labelFormat,
                    valueFormat: props.valueFormat,
                    timeFormat: props.timeFormat,
                    defaultDate: sdDate,
                    defaultTime: sdTime,
                    festivalMethod: props.festivalMethod,
                    disabledMethod: props.disabledMethod,
                    selectDay: props.selectDay,
                    onChange: startPanelChangeEvent
                  }),
                  h(date_panel_default, {
                    ref: refEndDatePanel,
                    modelValue: endValue,
                    type: props.type,
                    className: props.className,
                    minDate: props.minDate,
                    maxDate: props.maxDate,
                    startDate: startValue,
                    startDay: props.startDay,
                    labelFormat: props.labelFormat,
                    valueFormat: props.valueFormat,
                    timeFormat: props.timeFormat,
                    defaultDate: edDate,
                    defaultTime: edTime,
                    festivalMethod: props.festivalMethod,
                    disabledMethod: props.disabledMethod,
                    selectDay: props.selectDay,
                    onChange: endPanelChangeEvent
                  })
                ]),
                h("div", {
                  class: "vxe-date-range-picker--layout-footer-wrapper"
                }, [
                  h("div", {
                    class: "vxe-date-range-picker--layout-footer-label"
                  }, startLabel || endLabel ? [
                    h("span", startLabel),
                    h("span", `${separator || ""}`),
                    h("span", endLabel)
                  ] : []),
                  h("div", {
                    class: "vxe-date-range-picker--layout-footer-custom"
                  }, footerSlot ? footerSlot({}) : [renderShortcutBtn("footer")]),
                  h("div", {
                    class: "vxe-date-range-picker--layout-footer-btns"
                  }, [
                    showClearBtn ? h(button_default, {
                      size: "mini",
                      disabled: !(startValue || endValue),
                      content: getI18n("vxe.button.clear"),
                      onClick: clearValueEvent
                    }) : renderEmptyElement($xeDateRangePicker),
                    showConfirmBtn ? h(button_default, {
                      size: "mini",
                      status: "primary",
                      content: getI18n("vxe.button.confirm"),
                      onClick: confirmEvent
                    }) : renderEmptyElement($xeDateRangePicker)
                  ])
                ])
              ]),
              rightSlot ? h("div", {
                class: "vxe-date-range-picker--layout-right-wrapper"
              }, rightSlot({})) : renderShortcutBtn("right", true)
            ]),
            bottomSlot ? h("div", {
              class: "vxe-date-range-picker--layout-bottom-wrapper"
            }, bottomSlot({})) : renderShortcutBtn("bottom")
          ])
        ] : [])
      ]);
    };
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "vxe-date-range-picker--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "vxe-date-range-picker--prefix-icon"
        }, prefixSlot ? getSlotVNs2(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : null;
    };
    const renderSuffixIcon2 = () => {
      const { suffixIcon } = props;
      const { startValue, endValue } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isClearable = computeIsClearable.value;
      return h("div", {
        class: ["vxe-date-range-picker--suffix", {
          "is--clear": isClearable && !isDisabled && (startValue || endValue)
        }]
      }, [
        isClearable ? h("div", {
          class: "vxe-date-range-picker--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : renderEmptyElement($xeDateRangePicker),
        renderExtraSuffixIcon(),
        suffixSlot || suffixIcon ? h("div", {
          class: "vxe-date-range-picker--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs2(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : renderEmptyElement($xeDateRangePicker)
      ]);
    };
    const renderExtraSuffixIcon = () => {
      return h("div", {
        class: "vxe-date-range-picker--control-icon",
        onClick: dateRangePickerOpenEvent
      }, [
        h("i", {
          class: ["vxe-date-range-picker--date-picker-icon", getIcon().DATE_PICKER_DATE]
        })
      ]);
    };
    const renderVN = () => {
      const { className, type, name, autoComplete } = props;
      const { startValue, endValue, visiblePanel, isActivated } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const inputLabel = computeInputLabel.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-date-range-picker--readonly", `type--${type}`, className]
        }, inputLabel);
      }
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon2();
      const suffix = renderSuffixIcon2();
      return h("div", {
        ref: refElem,
        class: ["vxe-date-range-picker", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--active": isActivated,
          "show--clear": isClearable && !isDisabled && (startValue || endValue)
        }],
        spellcheck: false
      }, [
        prefix || renderEmptyElement($xeDateRangePicker),
        h("div", {
          class: "vxe-date-range-picker--wrapper"
        }, [
          h("input", {
            ref: refInputTarget,
            class: "vxe-date-range-picker--inner",
            value: inputLabel,
            name,
            type: "text",
            placeholder: inpPlaceholder,
            readonly: true,
            disabled: isDisabled,
            autocomplete: autoComplete,
            onKeydown: keydownEvent,
            onKeyup: keyupEvent,
            onClick: clickEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        suffix || renderEmptyElement($xeDateRangePicker),
        // 下拉面板
        renderPanel()
      ]);
    };
    watch(() => props.modelValue, () => {
      updateModelValue(true);
    });
    watch(computeMVal, () => {
      updateModelValue(false);
    });
    updateModelValue(true);
    nextTick(() => {
      globalEvents.on($xeDateRangePicker, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeDateRangePicker, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeDateRangePicker, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeDateRangePicker, "blur", handleGlobalBlurEvent);
      globalEvents.on($xeDateRangePicker, "resize", handleGlobalResizeEvent);
    });
    onDeactivated(() => {
      checkValue();
    });
    onUnmounted(() => {
      globalEvents.off($xeDateRangePicker, "mousewheel");
      globalEvents.off($xeDateRangePicker, "mousedown");
      globalEvents.off($xeDateRangePicker, "blur");
      globalEvents.off($xeDateRangePicker, "resize");
    });
    onBeforeUnmount(() => {
      checkValue();
    });
    provide("$xeDateRangePicker", $xeDateRangePicker);
    $xeDateRangePicker.renderVN = renderVN;
    return $xeDateRangePicker;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/date-range-picker/index.js
var VxeDateRangePicker = Object.assign({}, date_range_picker_default, {
  install(app) {
    app.component(date_range_picker_default.name, date_range_picker_default);
  }
});
dynamicApp.use(VxeDateRangePicker);
VxeUI.component(date_range_picker_default);
var DateRangePicker = VxeDateRangePicker;
var date_range_picker_default2 = VxeDateRangePicker;

// node_modules/vxe-pc-ui/es/drawer/index.js
var import_xe_utils40 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/drawer/src/drawer.js
var import_xe_utils39 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/loading/index.js
var VxeLoading = Object.assign({}, loading_default, {
  install(app) {
    app.component(loading_default.name, loading_default);
  }
});
var LoadingController = {
  open(options) {
    const opts = Object.assign({}, options);
    dynamicStore.globalLoading = {
      modelValue: true,
      text: opts.text,
      icon: opts.icon
    };
    checkDynamic();
  },
  close() {
    dynamicStore.globalLoading = null;
  }
};
dynamicApp.use(VxeLoading);
VxeUI.component(loading_default);
VxeUI.loading = LoadingController;
var Loading = VxeLoading;
var loading_default2 = VxeLoading;

// node_modules/vxe-pc-ui/es/drawer/src/drawer.js
var allActiveDrawers = [];
var drawer_default = defineVxeComponent({
  name: "VxeDrawer",
  props: {
    modelValue: Boolean,
    id: String,
    title: String,
    loading: {
      type: Boolean,
      default: null
    },
    className: String,
    position: {
      type: [String, Object],
      default: () => getConfig().drawer.position
    },
    lockView: {
      type: Boolean,
      default: () => getConfig().drawer.lockView
    },
    lockScroll: Boolean,
    mask: {
      type: Boolean,
      default: () => getConfig().drawer.mask
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().drawer.maskClosable
    },
    escClosable: {
      type: Boolean,
      default: () => getConfig().drawer.escClosable
    },
    cancelClosable: {
      type: Boolean,
      default: () => getConfig().drawer.cancelClosable
    },
    confirmClosable: {
      type: Boolean,
      default: () => getConfig().drawer.confirmClosable
    },
    showHeader: {
      type: Boolean,
      default: () => getConfig().drawer.showHeader
    },
    showFooter: {
      type: Boolean,
      default: () => getConfig().drawer.showFooter
    },
    showClose: {
      type: Boolean,
      default: () => getConfig().drawer.showClose
    },
    content: [Number, String],
    showCancelButton: {
      type: Boolean,
      default: null
    },
    cancelButtonText: {
      type: String,
      default: () => getConfig().drawer.cancelButtonText
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().drawer.showConfirmButton
    },
    confirmButtonText: {
      type: String,
      default: () => getConfig().drawer.confirmButtonText
    },
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().drawer.destroyOnClose
    },
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().drawer.showTitleOverflow
    },
    width: [Number, String],
    height: [Number, String],
    resize: {
      type: Boolean,
      default: () => getConfig().drawer.resize
    },
    zIndex: Number,
    transfer: {
      type: Boolean,
      default: () => getConfig().drawer.transfer
    },
    padding: {
      type: Boolean,
      default: () => getConfig().drawer.padding
    },
    size: {
      type: String,
      default: () => getConfig().drawer.size || getConfig().size
    },
    beforeHideMethod: {
      type: Function,
      default: () => getConfig().drawer.beforeHideMethod
    },
    slots: Object
  },
  emits: [
    "update:modelValue",
    "show",
    "hide",
    "before-hide",
    "close",
    "confirm",
    "cancel",
    "resize"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils39.default.uniqueId();
    const $xeModal = inject("$xeModal", null);
    const $xeParentDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refDrawerBox = ref();
    const refConfirmBtn = ref();
    const refCancelBtn = ref();
    const reactData = reactive({
      initialized: false,
      visible: false,
      contentVisible: false,
      drawerZIndex: 0,
      resizeFlag: 1
    });
    const refMaps = {
      refElem
    };
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().modal.transfer;
        if (import_xe_utils39.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeParentDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeDragType = computed(() => {
      switch (props.position) {
        case "top":
          return "sb";
        case "bottom":
          return "st";
        case "left":
          return "wr";
      }
      return "wl";
    });
    const computeMaps = {};
    const $xeDrawer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getBox = () => {
      const boxElem = refDrawerBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const { width, height } = props;
      const boxElem = getBox();
      if (boxElem) {
        boxElem.style.width = toCssUnit(width);
        boxElem.style.height = toCssUnit(height);
      }
      return nextTick();
    };
    const updateZindex = () => {
      const { zIndex } = props;
      const { drawerZIndex } = reactData;
      if (zIndex) {
        reactData.drawerZIndex = zIndex;
      } else if (drawerZIndex < getLastZIndex()) {
        reactData.drawerZIndex = nextZIndex();
      }
    };
    const closeDrawer2 = (type) => {
      const { beforeHideMethod } = props;
      const { visible } = reactData;
      const params = { type };
      if (visible) {
        Promise.resolve(beforeHideMethod ? beforeHideMethod(params) : null).then((rest) => {
          if (!import_xe_utils39.default.isError(rest)) {
            reactData.contentVisible = false;
            import_xe_utils39.default.remove(allActiveDrawers, (item) => item === $xeDrawer);
            dispatchEvent("before-hide", params, null);
            setTimeout(() => {
              reactData.visible = false;
              emit("update:modelValue", false);
              dispatchEvent("hide", params, null);
            }, 200);
          }
        }).catch((e) => e);
      }
      return nextTick();
    };
    const closeEvent = (evnt) => {
      const type = "close";
      dispatchEvent(type, { type }, evnt);
      closeDrawer2(type);
    };
    const confirmEvent = (evnt) => {
      const { confirmClosable } = props;
      const type = "confirm";
      dispatchEvent(type, { type }, evnt);
      if (confirmClosable) {
        closeDrawer2(type);
      }
    };
    const cancelEvent = (evnt) => {
      const { cancelClosable } = props;
      const type = "cancel";
      dispatchEvent(type, { type }, evnt);
      if (cancelClosable) {
        closeDrawer2(type);
      }
    };
    const openDrawer2 = () => {
      const { showFooter } = props;
      const { initialized, visible } = reactData;
      if (!initialized) {
        reactData.initialized = true;
      }
      if (!visible) {
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveDrawers.push($xeDrawer);
        setTimeout(() => {
          recalculate();
          reactData.contentVisible = true;
          nextTick(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = "";
            const params = { type };
            emit("update:modelValue", true);
            dispatchEvent("show", params, null);
          });
        }, 10);
      }
      return nextTick();
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $drawer: $xeDrawer }, params));
    };
    const drawerMethods = {
      dispatchEvent,
      open: openDrawer2,
      close() {
        return closeDrawer2("close");
      },
      getBox
    };
    const selfClickEvent = (evnt) => {
      const el = refElem.value;
      if (props.maskClosable && evnt.target === el) {
        const type = "mask";
        closeDrawer2(type);
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastDrawer = import_xe_utils39.default.max(allActiveDrawers, (item) => item.reactData.drawerZIndex);
        if (lastDrawer) {
          setTimeout(() => {
            if (lastDrawer === $xeDrawer && lastDrawer.props.escClosable) {
              const type = "exit";
              dispatchEvent("close", { type }, evnt);
              closeDrawer2(type);
            }
          }, 10);
        }
      }
    };
    const boxMousedownEvent = () => {
      const { drawerZIndex } = reactData;
      if (allActiveDrawers.some((comp) => comp.reactData.visible && comp.reactData.drawerZIndex > drawerZIndex)) {
        updateZindex();
      }
    };
    const dragEvent = (evnt) => {
      evnt.preventDefault();
      const { visibleHeight, visibleWidth } = getDomNode();
      const marginSize = 0;
      const targetElem = evnt.target;
      const type = targetElem.getAttribute("type");
      const minWidth = 0;
      const minHeight = 0;
      const maxWidth = visibleWidth;
      const maxHeight = visibleHeight;
      const boxElem = getBox();
      const clientWidth = boxElem.clientWidth;
      const clientHeight = boxElem.clientHeight;
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      const offsetTop = boxElem.offsetTop;
      const offsetLeft = boxElem.offsetLeft;
      const params = { type: "resize" };
      document.onmousemove = (evnt2) => {
        evnt2.preventDefault();
        let dragLeft;
        let dragTop;
        let width;
        let height;
        switch (type) {
          case "wl":
            dragLeft = disX - evnt2.clientX;
            width = dragLeft + clientWidth;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case "st":
            dragTop = disY - evnt2.clientY;
            height = clientHeight + dragTop;
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case "wr":
            dragLeft = evnt2.clientX - disX;
            width = dragLeft + clientWidth;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case "sb":
            dragTop = evnt2.clientY - disY;
            height = dragTop + clientHeight;
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
        }
        boxElem.className = boxElem.className.replace(/\s?is--drag/, "") + " is--drag";
        dispatchEvent("resize", params, evnt2);
        reactData.resizeFlag++;
      };
      document.onmouseup = () => {
        document.onmousemove = null;
        document.onmouseup = null;
        reactData.resizeFlag++;
        setTimeout(() => {
          boxElem.className = boxElem.className.replace(/\s?is--drag/, "");
        }, 50);
      };
    };
    const formDesignPrivateMethods = {};
    Object.assign($xeDrawer, drawerMethods, formDesignPrivateMethods);
    const renderTitles = () => {
      const { slots: propSlots = {}, showClose, title } = props;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      return [
        h("div", {
          class: "vxe-drawer--header-title"
        }, titleSlot ? getSlotVNs2(titleSlot({ $drawer: $xeDrawer })) : title ? getFuncText(title) : getI18n("vxe.alert.title")),
        h("div", {
          class: "vxe-drawer--header-right"
        }, [
          cornerSlot ? h("div", {
            class: "vxe-drawer--corner-wrapper"
          }, getSlotVNs2(cornerSlot({ $drawer: $xeDrawer }))) : renderEmptyElement($xeDrawer),
          showClose ? h("div", {
            class: ["vxe-drawer--close-btn", "trigger--btn"],
            title: getI18n("vxe.drawer.close"),
            onClick: closeEvent
          }, [
            h("i", {
              class: getIcon().DRAWER_CLOSE
            })
          ]) : renderEmptyElement($xeDrawer)
        ])
      ];
    };
    const renderHeader = () => {
      const { slots: propSlots = {}, showTitleOverflow } = props;
      const headerSlot = slots.header || propSlots.header;
      if (props.showHeader) {
        return h("div", {
          class: ["vxe-drawer--header", {
            "is--ellipsis": showTitleOverflow
          }]
        }, headerSlot ? getSlotVNs2(headerSlot({ $drawer: $xeDrawer })) : renderTitles());
      }
      return renderEmptyElement($xeDrawer);
    };
    const renderBody = () => {
      const { slots: propSlots = {}, content } = props;
      const defaultSlot = slots.default || propSlots.default;
      const leftSlot = slots.left || propSlots.left;
      const rightSlot = slots.right || propSlots.right;
      return h("div", {
        class: "vxe-drawer--body"
      }, [
        leftSlot ? h("div", {
          class: "vxe-drawer--body-left"
        }, getSlotVNs2(leftSlot({ $drawer: $xeDrawer }))) : renderEmptyElement($xeDrawer),
        h("div", {
          class: "vxe-drawer--body-default"
        }, [
          h("div", {
            class: "vxe-drawer--content"
          }, defaultSlot ? getSlotVNs2(defaultSlot({ $drawer: $xeDrawer })) : getFuncText(content))
        ]),
        rightSlot ? h("div", {
          class: "vxe-drawer--body-right"
        }, getSlotVNs2(rightSlot({ $drawer: $xeDrawer }))) : renderEmptyElement($xeDrawer),
        h(loading_default2, {
          class: "vxe-drawer--loading",
          modelValue: props.loading
        })
      ]);
    };
    const renderDefaultFooter = () => {
      const { slots: propSlots = {}, showCancelButton, showConfirmButton, loading: loading2 } = props;
      const lfSlot = slots.leftfoot || propSlots.leftfoot;
      const rfSlot = slots.rightfoot || propSlots.rightfoot;
      const btnVNs = [];
      if (showCancelButton) {
        btnVNs.push(h(button_default, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || getI18n("vxe.button.cancel"),
          onClick: cancelEvent
        }));
      }
      if (showConfirmButton) {
        btnVNs.push(h(button_default, {
          key: 2,
          ref: refConfirmBtn,
          loading: loading2,
          status: "primary",
          content: props.confirmButtonText || getI18n("vxe.button.confirm"),
          onClick: confirmEvent
        }));
      }
      return h("div", {
        class: "vxe-drawer--footer-wrapper"
      }, [
        h("div", {
          class: "vxe-drawer--footer-left"
        }, lfSlot ? getSlotVNs2(lfSlot({ $drawer: $xeDrawer })) : []),
        h("div", {
          class: "vxe-drawer--footer-right"
        }, rfSlot ? getSlotVNs2(rfSlot({ $drawer: $xeDrawer })) : btnVNs)
      ]);
    };
    const renderFooter = () => {
      const { slots: propSlots = {} } = props;
      const footerSlot = slots.footer || propSlots.footer;
      if (props.showFooter) {
        return h("div", {
          class: "vxe-drawer--footer"
        }, footerSlot ? getSlotVNs2(footerSlot({ $drawer: $xeDrawer })) : [renderDefaultFooter()]);
      }
      return renderEmptyElement($xeDrawer);
    };
    const renderVN = () => {
      const { slots: propSlots = {}, className, position, loading: loading2, lockScroll, padding, lockView, mask, resize, destroyOnClose } = props;
      const { initialized, contentVisible, visible } = reactData;
      const asideSlot = slots.aside || propSlots.aside;
      const vSize = computeSize.value;
      const dragType = computeDragType.value;
      const btnTransfer = computeBtnTransfer.value;
      return h(Teleport, {
        to: "body",
        disabled: btnTransfer ? !initialized : true
      }, [
        h("div", {
          ref: refElem,
          class: ["vxe-drawer--wrapper", `pos--${position}`, className || "", {
            [`size--${vSize}`]: vSize,
            "is--padding": padding,
            "lock--scroll": lockScroll,
            "lock--view": lockView,
            "is--resize": resize,
            "is--mask": mask,
            "is--visible": contentVisible,
            "is--active": visible,
            "is--loading": loading2
          }],
          style: {
            zIndex: reactData.drawerZIndex
          },
          onClick: selfClickEvent
        }, [
          h("div", {
            ref: refDrawerBox,
            class: "vxe-drawer--box",
            onMousedown: boxMousedownEvent
          }, [
            asideSlot ? h("div", {
              class: "vxe-drawer--aside"
            }, getSlotVNs2(asideSlot({ $drawer: $xeDrawer }))) : renderEmptyElement($xeDrawer),
            h("div", {
              class: "vxe-drawer--container"
            }, !reactData.initialized || destroyOnClose && !reactData.visible ? [] : [
              renderHeader(),
              renderBody(),
              renderFooter(),
              resize ? h("span", {
                class: "vxe-drawer--resize"
              }, [
                h("span", {
                  class: `${dragType}-resize`,
                  type: dragType,
                  onMousedown: dragEvent
                })
              ]) : renderEmptyElement($xeDrawer)
            ])
          ])
        ])
      ]);
    };
    watch(() => props.width, recalculate);
    watch(() => props.height, recalculate);
    watch(() => props.modelValue, (value) => {
      if (value) {
        openDrawer2();
      } else {
        closeDrawer2("model");
      }
    });
    onMounted(() => {
      nextTick(() => {
        if (props.modelValue) {
          openDrawer2();
        }
        recalculate();
      });
      if (props.escClosable) {
        globalEvents.on($xeDrawer, "keydown", handleGlobalKeydownEvent);
      }
    });
    onUnmounted(() => {
      globalEvents.off($xeDrawer, "keydown");
    });
    provide("$xeDrawer", $xeDrawer);
    $xeDrawer.renderVN = renderVN;
    return $xeDrawer;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/drawer/index.js
function handleDrawer(options) {
  checkDynamic();
  return new Promise((resolve) => {
    if (options && options.id && allActiveDrawers.some((comp) => comp.props.id === options.id)) {
      resolve("exist");
    } else {
      const _onHide = options.onHide;
      const drawerOpts = Object.assign(options, {
        key: import_xe_utils40.default.uniqueId(),
        modelValue: true,
        onHide(params) {
          const drawerList = dynamicStore.drawers;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.drawers = drawerList.filter((item) => item.key !== drawerOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.drawers.push(drawerOpts);
    }
  });
}
function getDrawer(id) {
  return import_xe_utils40.default.find(allActiveDrawers, ($drawer) => $drawer.props.id === id);
}
function closeDrawer(id) {
  const drawers = id ? [getDrawer(id)] : allActiveDrawers;
  const restPromises = [];
  drawers.forEach(($drawer) => {
    if ($drawer) {
      restPromises.push($drawer.close());
    }
  });
  return Promise.all(restPromises);
}
function openDrawer(options) {
  return handleDrawer(Object.assign({}, options));
}
var DrawerController = {
  get: getDrawer,
  close: closeDrawer,
  open: openDrawer
};
var VxeDrawer = Object.assign(drawer_default, {
  install: function(app) {
    app.component(drawer_default.name, drawer_default);
  }
});
VxeUI.drawer = DrawerController;
dynamicApp.use(VxeDrawer);
VxeUI.component(drawer_default);
var Drawer = VxeDrawer;
var drawer_default2 = VxeDrawer;

// node_modules/vxe-pc-ui/es/empty/src/empty.js
var import_xe_utils41 = __toESM(require_xe_utils());
var empty_default = defineVxeComponent({
  name: "VxeEmpty",
  props: {
    imageUrl: String,
    imageStyle: Object,
    icon: String,
    status: String,
    content: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils41.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeEmpty = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $empty: $xeEmpty }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeEmpty, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { imageUrl, imageStyle, icon, status, content } = props;
      return h("div", {
        ref: refElem,
        class: ["vxe-empty", {
          [`theme--${status}`]: status
        }]
      }, [
        h("div", {
          class: "vxe-empty--inner"
        }, [
          imageUrl ? h("div", {
            class: "vxe-empty--img-wrapper"
          }, [
            h("img", {
              src: imageUrl,
              style: imageStyle
            })
          ]) : h("div", {
            class: "vxe-empty--icon-wrapper"
          }, [
            h("i", {
              class: icon || getIcon().EMPTY_DEFAULT
            })
          ]),
          h("div", {
            class: "vxe-empty--content-wrapper"
          }, `${content || getI18n("vxe.empty.defText")}`)
        ])
      ]);
    };
    $xeEmpty.renderVN = renderVN;
    return $xeEmpty;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/empty/index.js
var VxeEmpty = Object.assign({}, empty_default, {
  install(app) {
    app.component(empty_default.name, empty_default);
  }
});
dynamicApp.use(VxeEmpty);
VxeUI.component(empty_default);
var Empty = VxeEmpty;
var empty_default2 = VxeEmpty;

// node_modules/vxe-pc-ui/es/form/src/form.js
var import_xe_utils48 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/form/src/util.js
var import_xe_utils43 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/form/src/itemInfo.js
var import_xe_utils42 = __toESM(require_xe_utils());
var ItemInfo = class {
  constructor($xeForm, item) {
    const { field, itemRender, formatter } = item;
    if (formatter) {
      if (import_xe_utils42.default.isString(formatter)) {
        const gFormatOpts = formats.get(formatter);
        if (!gFormatOpts || !gFormatOpts.formItemFormatMethod) {
          errLog("vxe.error.notFormats", [`[form] ${formatter}`]);
        }
      } else if (import_xe_utils42.default.isArray(formatter)) {
        const gFormatOpts = formats.get(formatter[0]);
        if (!gFormatOpts || !gFormatOpts.formItemFormatMethod) {
          errLog("vxe.error.notFormats", [`[form] ${formatter[0]}`]);
        }
      }
    }
    if (field && itemRender) {
      if (itemRender.startField && `${itemRender.startField}`.indexOf(field) >= 0) {
        errLog("vxe.error.modelConflicts", [`[form] field=${field}`, `item-render.startField=${itemRender.startField}`]);
      }
      if (itemRender.endField && `${itemRender.endField}`.indexOf(field) >= 0) {
        errLog("vxe.error.modelConflicts", [`[form] field=${field}`, `item-render.endField=${itemRender.endField}`]);
      }
    }
    Object.assign(this, {
      id: import_xe_utils42.default.uniqueId("item_"),
      title: item.title,
      field,
      span: item.span,
      align: item.align,
      verticalAlign: item.verticalAlign,
      titleBackground: item.titleBackground,
      titleBold: item.titleBold,
      titleAlign: item.titleAlign,
      titleWidth: item.titleWidth,
      titleColon: item.titleColon,
      vertical: item.vertical,
      padding: item.padding,
      titleAsterisk: item.titleAsterisk,
      titlePrefix: item.titlePrefix,
      titleSuffix: item.titleSuffix,
      titleOverflow: item.titleOverflow,
      showTitle: item.showTitle,
      resetValue: item.resetValue,
      visibleMethod: item.visibleMethod,
      visible: item.visible,
      showContent: item.showContent,
      folding: item.folding,
      collapseNode: item.collapseNode,
      className: item.className,
      contentClassName: item.contentClassName,
      contentStyle: item.contentStyle,
      titleClassName: item.titleClassName,
      titleStyle: item.titleStyle,
      itemRender,
      rules: item.rules,
      formatter,
      // 自定义参数
      params: item.params,
      // 渲染属性
      showError: false,
      showIconMsg: false,
      errRule: null,
      slots: item.slots,
      children: []
    });
  }
  update(name, value) {
    this[name] = value;
  }
};

// node_modules/vxe-pc-ui/es/form/src/util.js
function isFormItem(item) {
  return item instanceof ItemInfo;
}
function createItem($xeForm, _vm) {
  return isFormItem(_vm) ? _vm : new ItemInfo($xeForm, _vm);
}
function handleFieldOrItem($xeForm, fieldOrItem) {
  if (fieldOrItem) {
    return import_xe_utils43.default.isString(fieldOrItem) ? $xeForm.getItemByField(fieldOrItem) : fieldOrItem;
  }
  return null;
}
function isHiddenItem($xeForm, formItem) {
  const { reactData } = $xeForm;
  const { collapseAll } = reactData;
  const { folding, visible } = formItem;
  return visible === false || folding && collapseAll;
}
function isActiveItem($xeForm, formItem) {
  const $xeGrid = $xeForm.xeGrid;
  let { visibleMethod, itemRender, visible, field } = formItem;
  if (visible === false) {
    return visible;
  }
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const fiVisibleMethod = compConf ? compConf.formItemVisibleMethod || compConf.itemVisibleMethod : null;
  if (!visibleMethod && fiVisibleMethod) {
    visibleMethod = fiVisibleMethod;
  }
  if (!visibleMethod) {
    return true;
  }
  const formProps = $xeForm.props;
  const { data } = formProps;
  return visibleMethod({ data, field, property: field, item: formItem, $form: $xeForm, $grid: $xeGrid });
}
function watchItem(props, formItem) {
  Object.keys(props).forEach((name) => {
    watch(() => props[name], (value) => {
      formItem.update(name, value);
    });
  });
}
function assembleItem($xeForm, el, formItem, formGroup) {
  const { reactData } = $xeForm;
  const formProps = $xeForm.props;
  const { customLayout } = formProps;
  const { staticItems } = reactData;
  if (customLayout) {
    if (!staticItems.some((item) => item.id === formItem.id)) {
      staticItems.push(formItem);
    }
  } else {
    if (el) {
      const parentElem = el.parentNode;
      const parentItem = formGroup ? formGroup.formItem : null;
      const parentItems = parentItem ? parentItem.children : staticItems;
      if (parentElem) {
        parentItems.splice(import_xe_utils43.default.arrayIndexOf(parentElem.children, el), 0, formItem);
        reactData.staticItems = staticItems.slice(0);
      }
    }
  }
}
function destroyItem($xeForm, formItem) {
  const { reactData } = $xeForm;
  const { staticItems } = reactData;
  const index = import_xe_utils43.default.findIndexOf(staticItems, (item) => item.id === formItem.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  reactData.staticItems = staticItems.slice(0);
}

// node_modules/vxe-pc-ui/es/icon/src/icon.js
var import_xe_utils44 = __toESM(require_xe_utils());
var icon_default = defineVxeComponent({
  name: "VxeIcon",
  props: {
    name: String,
    className: String,
    roll: Boolean,
    status: String,
    size: {
      type: String,
      default: () => getConfig().icon.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils44.default.uniqueId();
    const { computeSize } = useSize(props);
    const $xeIcon = {
      xID,
      props,
      context
    };
    const clickEvent = (evnt) => {
      emit("click", createEvent(evnt, {}));
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $icon: $xeIcon }, params));
    };
    const iconMethods = {
      dispatchEvent
    };
    const iconPrivateMethods = {};
    Object.assign($xeIcon, iconMethods, iconPrivateMethods);
    const renderVN = () => {
      const { name, roll, status, className } = props;
      const vSize = computeSize.value;
      return h("i", {
        class: ["vxe-icon", `vxe-icon-${name}`, `${className || ""}`, {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          roll
        }],
        onClick: clickEvent
      });
    };
    $xeIcon.renderVN = renderVN;
    return $xeIcon;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form/src/render.js
var import_xe_utils45 = __toESM(require_xe_utils());
function renderPrefixIcon(titlePrefix) {
  return h("span", {
    class: "vxe-form--item-title-tip-prefix"
  }, [
    h(icon_default, {
      class: titlePrefix.icon || getIcon().FORM_PREFIX,
      status: titlePrefix.iconStatus
    })
  ]);
}
function renderSuffixIcon(titleSuffix) {
  return h("span", {
    class: "vxe-form--item-title-tip-suffix"
  }, [
    h(icon_default, {
      class: titleSuffix.icon || getIcon().FORM_SUFFIX,
      status: titleSuffix.iconStatus
    })
  ]);
}
function getItemClass($xeForm, item, isGroup) {
  const formProps = $xeForm.props;
  const formReactData = $xeForm.reactData;
  const $xeGrid = $xeForm.xeGrid;
  const { computeSize, computeValidOpts } = $xeForm.getComputeMaps();
  const { data, rules, readonly, disabled, span: allSpan, titleBackground: allTitleBackground, titleBold: allTitleBold, titleColon: allTitleColon, titleAsterisk: allTitleAsterisk, vertical: allVertical, padding: allPadding } = formProps;
  const { collapseAll } = formReactData;
  const { folding, field, itemRender, showError, className, vertical, padding, children, showContent } = item;
  const vSize = computeSize.value;
  const validOpts = computeValidOpts.value;
  const { showErrorMessage, showMessage, showErrorIcon } = validOpts;
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const itemClassName = compConf ? compConf.formItemClassName || compConf.itemClassName : "";
  const span = item.span || allSpan;
  const itemPadding = import_xe_utils45.default.eqNull(padding) ? allPadding : padding;
  const itemVertical = import_xe_utils45.default.eqNull(vertical) ? allVertical : vertical;
  const titleBackground = import_xe_utils45.default.eqNull(item.titleBackground) ? allTitleBackground : item.titleBackground;
  const titleBold = import_xe_utils45.default.eqNull(item.titleBold) ? allTitleBold : item.titleBold;
  const titleColon = import_xe_utils45.default.eqNull(item.titleColon) ? allTitleColon : item.titleColon;
  const titleAsterisk = import_xe_utils45.default.eqNull(item.titleAsterisk) ? allTitleAsterisk : item.titleAsterisk;
  const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeGrid };
  const hasGroup = children && children.length > 0;
  let isRequired = false;
  let isValid = false;
  if (!readonly && rules) {
    const itemRules = rules[field];
    if (itemRules && itemRules.length) {
      isValid = true;
      isRequired = itemRules.some((rule) => rule.required);
    }
  }
  return [
    isGroup || hasGroup ? "vxe-form--group" : "",
    "vxe-form--item",
    item.id,
    span ? `vxe-form--item-col_${span} is--span` : "",
    `${(import_xe_utils45.default.isBoolean(showErrorMessage) ? showErrorMessage : showMessage) ? "show" : "hide"}--err-msg`,
    className ? import_xe_utils45.default.isFunction(className) ? className(params) : className : "",
    itemClassName ? import_xe_utils45.default.isFunction(itemClassName) ? itemClassName(params) : itemClassName : "",
    {
      [`size--${vSize}`]: vSize,
      "is--colon": titleColon,
      "is--tbg": titleBackground,
      "is--bold": titleBold,
      "is--padding": itemPadding,
      "is--vertical": itemVertical,
      "is--asterisk": titleAsterisk,
      "hide--content": showContent === false,
      "is--valid": isValid,
      "is--required": isRequired,
      "is--hidden": folding && collapseAll,
      "is--active": isActiveItem($xeForm, item),
      "err--icon": showErrorIcon,
      "is--error": showError
    }
  ];
}
function getItemContentClass($xeForm, item, isGroup) {
  const formProps = $xeForm.props;
  const $xeGrid = $xeForm.xeGrid;
  const { data, readonly, disabled, align: allAlign, verticalAlign: allVerticalAlign } = formProps;
  const { field, itemRender, contentClassName, children } = item;
  const hasGroup = children && children.length > 0;
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const itemContentClassName = compConf ? compConf.formItemContentClassName || compConf.itemContentClassName : "";
  const align = hasGroup ? item.align : import_xe_utils45.default.eqNull(item.align) ? allAlign : item.align;
  const verticalAlign = hasGroup ? item.verticalAlign : import_xe_utils45.default.eqNull(item.verticalAlign) ? allVerticalAlign : item.verticalAlign;
  const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeGrid };
  return [
    isGroup || hasGroup ? "vxe-form--group-content vxe-form--item-row" : "",
    "vxe-form--item-content",
    align ? `align--${align}` : "",
    verticalAlign ? `vertical-align--${verticalAlign}` : "",
    itemContentClassName ? import_xe_utils45.default.isFunction(itemContentClassName) ? itemContentClassName(params) : itemContentClassName : "",
    contentClassName ? import_xe_utils45.default.isFunction(contentClassName) ? contentClassName(params) : contentClassName : ""
  ];
}
function renderTitle($xeForm, item, isGroup) {
  const formProps = $xeForm.props;
  const $xeGrid = $xeForm.xeGrid;
  const { data, readonly, disabled, titleAlign: allTitleAlign, titleWidth: allTitleWidth, titleOverflow: allTitleOverflow, vertical: allVertical } = formProps;
  const { slots, title, field, itemRender, titleOverflow, vertical, showTitle, titleClassName, titleStyle, titlePrefix, titleSuffix, children, showContent } = item;
  const { computeTooltipOpts } = $xeForm.getComputeMaps();
  const tooltipOpts = computeTooltipOpts.value;
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const itemTitleClassName = compConf ? compConf.formItemTitleClassName || compConf.itemTitleClassName : "";
  const itemTitleStyle = compConf ? compConf.formItemTitleStyle || compConf.itemTitleStyle : null;
  const itemVertical = import_xe_utils45.default.eqNull(vertical) ? allVertical : vertical;
  const titleAlign = import_xe_utils45.default.eqNull(item.titleAlign) ? allTitleAlign : item.titleAlign;
  const titleWidth = itemVertical ? null : import_xe_utils45.default.eqNull(item.titleWidth) ? allTitleWidth : item.titleWidth;
  const itemOverflow = import_xe_utils45.default.eqNull(titleOverflow) ? allTitleOverflow : titleOverflow;
  const ovEllipsis = itemOverflow === "ellipsis";
  const ovTitle = itemOverflow === "title";
  const ovTooltip = itemOverflow === true || itemOverflow === "tooltip";
  const hasEllipsis = ovTitle || ovTooltip || ovEllipsis;
  const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeGrid };
  const titleSlot = slots ? slots.title : null;
  const prefixSlot = slots ? slots.prefix : null;
  const suffixSlot = slots ? slots.suffix || slots.extra : null;
  const isTitle = showTitle !== false && (title || titleSlot);
  const hasGroup = children && children.length > 0;
  const titVNs = [];
  if (prefixSlot) {
    titVNs.push(h("span", {
      key: "pt",
      class: "vxe-form--item-title-prefix"
    }, $xeForm.callSlot(prefixSlot, params)));
  }
  if (titlePrefix) {
    titVNs.push(titlePrefix.content || titlePrefix.message ? h(tooltip_default, Object.assign(Object.assign(Object.assign({ key: "pm" }, tooltipOpts), titlePrefix), { content: getFuncText(titlePrefix.content || titlePrefix.message) }), {
      default: () => renderPrefixIcon(titlePrefix)
    }) : renderPrefixIcon(titlePrefix));
  }
  const rftTitle = compConf ? compConf.renderFormItemTitle || compConf.renderItemTitle : null;
  titVNs.push(h("span", {
    key: "pl",
    class: "vxe-form--item-title-label"
  }, titleSlot ? $xeForm.callSlot(titleSlot, params) : rftTitle ? getSlotVNs2(rftTitle(itemRender, params)) : getFuncText(item.title)));
  const fixVNs = [];
  if (titleSuffix) {
    fixVNs.push(titleSuffix.content || titleSuffix.message ? h(tooltip_default, Object.assign(Object.assign(Object.assign({ key: "sm" }, tooltipOpts), titleSuffix), { content: getFuncText(titleSuffix.content || titleSuffix.message) }), {
      default: () => renderSuffixIcon(titleSuffix)
    }) : renderSuffixIcon(titleSuffix));
  }
  if (suffixSlot) {
    fixVNs.push(h("span", {
      key: "st",
      class: "vxe-form--item-title-suffix"
    }, $xeForm.callSlot(suffixSlot, params)));
  }
  const ons = ovTooltip ? {
    onMouseenter(evnt) {
      $xeForm.triggerTitleTipEvent(evnt, params);
    },
    onMouseleave: $xeForm.handleTitleTipLeaveEvent
  } : {};
  const itStyle = Object.assign({}, import_xe_utils45.default.isFunction(itemTitleStyle) ? itemTitleStyle(params) : itemTitleStyle, import_xe_utils45.default.isFunction(titleStyle) ? titleStyle(params) : titleStyle);
  if (titleWidth && titleWidth !== "auto" && showContent !== false) {
    itStyle.width = toCssUnit(titleWidth);
  }
  return isTitle ? h("div", Object.assign({ class: [
    isGroup || hasGroup ? "vxe-form--group-title" : "",
    "vxe-form--item-title",
    titleAlign ? `align--${titleAlign}` : "",
    hasEllipsis ? "is--ellipsis" : "",
    itemTitleClassName ? import_xe_utils45.default.isFunction(itemTitleClassName) ? itemTitleClassName(params) : itemTitleClassName : "",
    titleClassName ? import_xe_utils45.default.isFunction(titleClassName) ? titleClassName(params) : titleClassName : ""
  ], style: itStyle, itemid: item.id, title: ovTitle ? getFuncText(title) : null }, ons), [
    h("div", {
      class: "vxe-form--item-title-content"
    }, titVNs),
    h("div", {
      class: "vxe-form--item-title-postfix"
    }, fixVNs)
  ]) : renderEmptyElement($xeForm);
}
function renderItemErrorIcon($xeForm, item) {
  const { computeValidOpts } = $xeForm.getComputeMaps();
  const validOpts = computeValidOpts.value;
  const { showErrorIcon, errorIcon } = validOpts;
  const { errRule, showIconMsg } = item;
  if (!showErrorIcon) {
    return renderEmptyElement($xeForm);
  }
  return h("div", {
    key: "emi",
    class: ["vxe-form-item--valid-error-icon-wrapper", {
      "is--show": showIconMsg,
      "is--hide": !showIconMsg
    }]
  }, [
    h("span", {
      class: "vxe-form-item--valid-error-icon-btn",
      onClick(evnt) {
        $xeForm.handleValidIconEvent(evnt, { item });
      }
    }, [
      h("i", {
        class: errorIcon || getIcon().FORM_VALID_ERROR_ICON
      })
    ]),
    h("div", {
      class: "vxe-form-item--valid-error-icon-msg-tip"
    }, errRule ? [
      h("div", {
        class: `vxe-form-item--valid-error-icon-msg vxe-form-item--valid-error-icon-theme-${validOpts.theme || "normal"}`
      }, errRule.content || errRule.message)
    ] : [])
  ]);
}
function renderItemContent($xeForm, item) {
  const formProps = $xeForm.props;
  const formReactData = $xeForm.reactData;
  const formInternalData = $xeForm.internalData;
  const $xeGrid = $xeForm.xeGrid;
  const { computeCollapseOpts, computeValidOpts } = $xeForm.getComputeMaps();
  const { itemFormatCache } = formInternalData;
  const { data, readonly, disabled } = formProps;
  const { collapseAll } = formReactData;
  const { slots, field, itemRender, collapseNode, errRule, formatter } = item;
  const defaultSlot = slots ? slots.default : null;
  const validSlot = slots ? slots.valid : null;
  const collapseOpts = computeCollapseOpts.value;
  const validOpts = computeValidOpts.value;
  const { showErrorMessage, showMessage } = validOpts;
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const itemValue = import_xe_utils45.default.get(data, field);
  const params = { data, disabled, readonly, field, property: field, item, itemValue, $form: $xeForm, $grid: $xeGrid };
  let contentVNs = [];
  const rftContent = compConf ? compConf.renderFormItemContent || compConf.renderItemContent : null;
  if (defaultSlot) {
    contentVNs = $xeForm.callSlot(defaultSlot, params);
  } else if (rftContent) {
    contentVNs = getSlotVNs2(rftContent(itemRender, params));
  } else if (field) {
    let itemLabel = itemValue;
    if (formatter) {
      let formatData;
      if (field) {
        const itemRest = itemFormatCache[field];
        if (itemRest) {
          formatData = itemRest.formatData;
          if (formatData) {
            if (formatData.value === itemValue) {
              return formatData.label;
            }
          } else {
            formatData = itemRest.formatData = {};
          }
        } else {
          itemFormatCache[field] = { field };
        }
      }
      if (import_xe_utils45.default.isString(formatter)) {
        const gFormatOpts = formats.get(formatter);
        const fiFormatMethod = gFormatOpts ? gFormatOpts.formItemFormatMethod : null;
        itemLabel = fiFormatMethod ? fiFormatMethod(params) : "";
      } else if (import_xe_utils45.default.isArray(formatter)) {
        const gFormatOpts = formats.get(formatter[0]);
        const fiFormatMethod = gFormatOpts ? gFormatOpts.formItemFormatMethod : null;
        itemLabel = fiFormatMethod ? fiFormatMethod(params, ...formatter.slice(1)) : "";
      } else {
        itemLabel = formatter(params);
      }
      if (formatData) {
        formatData.value = itemValue;
        formatData.label = itemLabel;
      }
    }
    contentVNs = [eqEmptyValue(itemLabel) ? "" : `${itemLabel}`];
  }
  if (collapseNode) {
    contentVNs.push(h("div", {
      class: "vxe-form--item-trigger-node",
      onClick: $xeForm.toggleCollapseEvent
    }, [
      h("span", {
        class: "vxe-form--item-trigger-text"
      }, collapseAll ? collapseOpts.unfoldButtonText || getI18n("vxe.form.unfolding") : collapseOpts.foldButtonText || getI18n("vxe.form.folding")),
      h("i", {
        class: ["vxe-form--item-trigger-icon", collapseAll ? collapseOpts.foldIcon || getIcon().FORM_FOLDING : collapseOpts.unfoldIcon || getIcon().FORM_UNFOLDING]
      })
    ]));
  }
  if (errRule && (import_xe_utils45.default.isBoolean(showErrorMessage) ? showErrorMessage : showMessage)) {
    const validParams = Object.assign(Object.assign({}, params), { rule: errRule });
    contentVNs.push(h("div", {
      class: "vxe-form-item--valid-error-tip",
      style: errRule.maxWidth ? {
        width: toCssUnit(errRule.maxWidth)
      } : null
    }, [
      h("div", {
        class: `vxe-form-item--valid-error-wrapper vxe-form-item--valid-error-theme-${validOpts.theme || "normal"}`
      }, [
        validSlot ? $xeForm.callSlot(validSlot, validParams) : [
          h("span", {
            class: "vxe-form--item--valid-error-msg"
          }, errRule.content || errRule.message)
        ]
      ])
    ]));
  }
  return h("div", {
    key: "ct",
    class: "vxe-form--item-inner"
  }, contentVNs);
}

// node_modules/vxe-pc-ui/es/form/src/form-config-item.js
var import_xe_utils46 = __toESM(require_xe_utils());
var VxeFormConfigItem = defineVxeComponent({
  name: "VxeFormConfigItem",
  props: {
    itemConfig: Object
  },
  setup(props) {
    const $xeForm = inject("$xeForm", {});
    const xeformiteminfo = { itemConfig: props.itemConfig };
    provide("xeFormItemInfo", xeformiteminfo);
    const renderItem = ($xeForm2, item) => {
      const formProps = $xeForm2.props;
      const $xeGrid = $xeForm2.xeGrid;
      const { data, readonly, disabled } = formProps;
      const { visible, field, itemRender, contentStyle, children, showContent } = item;
      const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm2, $grid: $xeGrid };
      const hasGroup = children && children.length > 0;
      if (visible === false) {
        return renderEmptyElement($xeForm2);
      }
      return h("div", {
        key: item.id,
        itemid: item.id,
        class: getItemClass($xeForm2, item),
        style: import_xe_utils46.default.isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [
        renderTitle($xeForm2, item),
        showContent === false ? renderEmptyElement($xeForm2) : h("div", {
          class: getItemContentClass($xeForm2, item),
          style: Object.assign({}, import_xe_utils46.default.isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, import_xe_utils46.default.isFunction(contentStyle) ? contentStyle(params) : contentStyle)
        }, hasGroup ? children.map((childItem) => renderItem($xeForm2, childItem)) : [
          renderItemContent($xeForm2, item),
          renderItemErrorIcon($xeForm2, item)
        ])
      ]);
    };
    const renderVN = () => {
      return renderItem($xeForm, props.itemConfig);
    };
    const $xeFormconfigitem = {
      renderVN
    };
    provide("$xeFormGroup", null);
    return $xeFormconfigitem;
  },
  render() {
    return this.renderVN();
  }
});
var form_config_item_default = VxeFormConfigItem;

// node_modules/vxe-pc-ui/es/form/render/index.js
var import_xe_utils47 = __toESM(require_xe_utils());
var componentDefaultModelProp = "modelValue";
function getOldComponentName(name) {
  return `vxe-${`${name || ""}`.replace("$", "")}`;
}
function getDefaultComponent(renderOpts) {
  const { name } = renderOpts;
  return getComponent(name) || resolveComponent(`${name}`);
}
function getOldComponent({ name }) {
  return resolveComponent(getOldComponentName(name));
}
function getNativeAttrs(renderOpts) {
  let { name, attrs } = renderOpts;
  if (name === "input") {
    attrs = Object.assign({ type: "text" }, attrs);
  }
  return attrs;
}
function getComponentFormItemProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils47.default.assign({}, defaultProps, renderOpts.props, { [componentDefaultModelProp]: value });
}
function getNativeElementOns(renderOpts, params, modelFunc, changeFunc) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const isSameEvent = changeEvent === modelEvent;
  const ons = {};
  if (events) {
    import_xe_utils47.default.objectEach(events, (func, key) => {
      ons[getOnName(key)] = function(...args) {
        func(params, ...args);
      };
    });
  }
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getComponentOns(renderOpts, params, eFns, eventOns) {
  const { events } = renderOpts;
  const { model: modelFunc, change: changeFunc } = eFns || {};
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const ons = {};
  import_xe_utils47.default.objectEach(events, (func, key) => {
    ons[getOnName(key)] = function(...args) {
      if (!import_xe_utils47.default.isFunction(func)) {
        errLog("vxe.error.errFunc", [`[form] ${func}`]);
      }
      func(params, ...args);
    };
  });
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return eventOns ? Object.assign(ons, eventOns) : ons;
}
function getItemOns(renderOpts, params) {
  const { $form, data, field } = params;
  return getComponentOns(renderOpts, params, {
    model(value) {
      import_xe_utils47.default.set(data, field, value);
    },
    change() {
      $form.updateStatus(params);
    }
  });
}
function getNativeItemOns(renderOpts, params) {
  const { $form, data, field } = params;
  return getNativeElementOns(renderOpts, params, (evnt) => {
    const itemValue = evnt.target.value;
    import_xe_utils47.default.set(data, field, itemValue);
  }, () => {
    $form.updateStatus(params);
  });
}
function renderNativeOptgroup(renderOpts, params, renderOptionsMethods) {
  const { optionGroups, optionGroupProps = {} } = renderOpts;
  const groupOptions = optionGroupProps.options || "options";
  const groupLabel = optionGroupProps.label || "label";
  if (optionGroups) {
    return optionGroups.map((group, gIndex) => {
      return h("optgroup", {
        key: gIndex,
        label: group[groupLabel]
      }, renderOptionsMethods(group[groupOptions], renderOpts, params));
    });
  }
  return [];
}
function nativeItemRender(renderOpts, params) {
  const { data, field } = params;
  const { name } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  const itemValue = import_xe_utils47.default.get(data, field);
  return [
    h(`${name}`, Object.assign(Object.assign(Object.assign({ class: `vxe-default-${name}` }, attrs), { value: attrs && name === "input" && (attrs.type === "submit" || attrs.type === "reset") ? null : itemValue }), getNativeItemOns(renderOpts, params)))
  ];
}
function defaultItemRender(renderOpts, params) {
  const { data, field } = params;
  const itemValue = import_xe_utils47.default.get(data, field);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldItemRender(renderOpts, params) {
  const { data, field } = params;
  const itemValue = import_xe_utils47.default.get(data, field);
  return [
    h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldButtonItemRender(renderOpts, params) {
  return [
    h(resolveComponent("vxe-button"), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function oldButtonsItemRender(renderOpts, params) {
  const { children } = renderOpts;
  return children ? children.map((childRenderOpts) => oldButtonItemRender(childRenderOpts, params)[0]) : [];
}
function renderNativeFormOptions(options, renderOpts, params) {
  const { data, field } = params;
  const { optionProps = {} } = renderOpts;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const cellValue = import_xe_utils47.default.get(data, field);
  if (options) {
    return options.map((item, oIndex) => {
      return h("option", {
        key: oIndex,
        value: item[valueProp],
        disabled: item[disabledProp],
        /* eslint-disable eqeqeq */
        selected: item[valueProp] == cellValue
      }, item[labelProp]);
    });
  }
  return [];
}
function defaultFormItemRender(renderOpts, params) {
  const { data, field } = params;
  const itemValue = import_xe_utils47.default.get(data, field);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function formItemRadioAndCheckboxRender(renderOpts, params) {
  const { options, optionProps } = renderOpts;
  const { data, field } = params;
  const itemValue = import_xe_utils47.default.get(data, field);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({
      options,
      optionProps
    }, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldFormItemRadioAndCheckboxRender(renderOpts, params) {
  const { name, options, optionProps = {} } = renderOpts;
  const { data, field } = params;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const itemValue = import_xe_utils47.default.get(data, field);
  const compName = getOldComponentName(name);
  if (options) {
    return [
      h(resolveComponent(`${compName}-group`), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)), {
        default: () => {
          return options.map((item, index) => {
            return h(resolveComponent(compName), {
              key: index,
              label: item[valueProp],
              content: item[labelProp],
              disabled: item[disabledProp]
            });
          });
        }
      })
    ];
  }
  return [
    h(resolveComponent(compName), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
renderer.mixin({
  input: {
    formItemAutoFocus: "input",
    renderFormItemContent: nativeItemRender
  },
  textarea: {
    formItemAutoFocus: "textarea",
    renderFormItemContent: nativeItemRender
  },
  select: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      return [
        h("select", Object.assign(Object.assign({ class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeItemOns(renderOpts, params)), renderOpts.optionGroups ? renderNativeOptgroup(renderOpts, params, renderNativeFormOptions) : renderNativeFormOptions(renderOpts.options, renderOpts, params))
      ];
    }
  },
  VxeInput: {
    formItemAutoFocus: "input",
    renderFormItemContent: defaultItemRender
  },
  VxeNumberInput: {
    formItemAutoFocus: "input",
    renderFormItemContent: defaultItemRender
  },
  VxePasswordInput: {
    formItemAutoFocus: "input",
    renderFormItemContent: defaultItemRender
  },
  VxeTextarea: {
    formItemAutoFocus: "textarea",
    renderFormItemContent: defaultItemRender
  },
  VxeDatePicker: {
    formItemAutoFocus: "input",
    renderFormItemContent: defaultItemRender
  },
  VxeDateRangePicker: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { startField, endField } = renderOpts;
      const { $form, data, field } = params;
      const itemValue = import_xe_utils47.default.get(data, field);
      const seProps = {};
      const seOs = {};
      if (startField && endField) {
        seProps.startValue = import_xe_utils47.default.get(data, startField);
        seProps.endValue = import_xe_utils47.default.get(data, endField);
        seOs["onUpdate:startValue"] = (value) => {
          if (startField) {
            import_xe_utils47.default.set(data, startField, value);
          }
        };
        seOs["onUpdate:endValue"] = (value) => {
          if (endField) {
            import_xe_utils47.default.set(data, endField, value);
          }
        };
      }
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, seProps)), getComponentOns(renderOpts, params, {
          model(value) {
            import_xe_utils47.default.set(data, field, value);
          },
          change() {
            $form.updateStatus(params);
          }
        }, seOs)))
      ];
    }
  },
  VxeButton: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeButtonGroup: {
    renderFormItemContent(renderOpts, params) {
      const { options } = renderOpts;
      const { data, field } = params;
      const itemValue = import_xe_utils47.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ options }, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeSelect: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      const itemValue = import_xe_utils47.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps, optionGroups, optionGroupProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeTreeSelect: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps } = renderOpts;
      const itemValue = import_xe_utils47.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeTableSelect: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps } = renderOpts;
      const itemValue = import_xe_utils47.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeColorPicker: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options } = renderOpts;
      const itemValue = import_xe_utils47.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { colors: options })), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeIconPicker: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options } = renderOpts;
      const itemValue = import_xe_utils47.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { icons: options })), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeRadio: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeRadioGroup: {
    renderFormItemContent: formItemRadioAndCheckboxRender
  },
  VxeCheckbox: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeCheckboxGroup: {
    renderFormItemContent: formItemRadioAndCheckboxRender
  },
  VxeSwitch: {
    renderFormItemContent: defaultItemRender
  },
  VxeRate: {
    renderFormItemContent: defaultItemRender
  },
  VxeSlider: {
    renderFormItemContent: defaultItemRender
  },
  VxeImage: {
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { props } = renderOpts;
      const itemValue = import_xe_utils47.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { src: itemValue }), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeImageGroup: {
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { props } = renderOpts;
      const itemValue = import_xe_utils47.default.get(data, field);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { urlList: itemValue }), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeUpload: {
    renderFormItemContent: defaultItemRender
  },
  // 以下已废弃
  $input: {
    formItemAutoFocus: "input",
    renderFormItemContent: oldItemRender
  },
  $textarea: {
    formItemAutoFocus: "textarea",
    renderFormItemContent: oldItemRender
  },
  $button: {
    renderFormItemContent: oldButtonItemRender
  },
  $buttons: {
    renderFormItemContent: oldButtonsItemRender
  },
  $select: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      const itemValue = import_xe_utils47.default.get(data, field);
      return [
        h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps, optionGroups, optionGroupProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  $radio: {
    renderFormItemContent: oldFormItemRadioAndCheckboxRender
  },
  $checkbox: {
    renderFormItemContent: oldFormItemRadioAndCheckboxRender
  },
  $switch: {
    renderFormItemContent: oldItemRender
  }
  // 以上已废弃
});

// node_modules/vxe-pc-ui/es/form/src/form.js
var Rule = class {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.min,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
};
function validREValue(pattern, val) {
  if (pattern && !(import_xe_utils48.default.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
    return false;
  }
  return true;
}
function validMaxValue(max, num) {
  if (!import_xe_utils48.default.eqNull(max) && num > import_xe_utils48.default.toNumber(max)) {
    return false;
  }
  return true;
}
function validMinValue(min, num) {
  if (!import_xe_utils48.default.eqNull(min) && num < import_xe_utils48.default.toNumber(min)) {
    return false;
  }
  return true;
}
function validRuleValue(rule, val, required) {
  const { type, min, max, pattern } = rule;
  const isArrType = type === "array";
  const isNumType = type === "number";
  const isStrType = type === "string";
  const strVal = `${val}`;
  if (!validREValue(pattern, strVal)) {
    return false;
  }
  if (isArrType) {
    if (!import_xe_utils48.default.isArray(val)) {
      return false;
    }
    if (required) {
      if (!val.length) {
        return false;
      }
    }
    if (!validMinValue(min, val.length)) {
      return false;
    }
    if (!validMaxValue(max, val.length)) {
      return false;
    }
  } else if (isNumType) {
    const numVal = Number(val);
    if (isNaN(numVal)) {
      return false;
    }
    if (!validMinValue(min, numVal)) {
      return false;
    }
    if (!validMaxValue(max, numVal)) {
      return false;
    }
  } else {
    if (isStrType) {
      if (!import_xe_utils48.default.isString(val)) {
        return false;
      }
    }
    if (required) {
      if (!strVal) {
        return false;
      }
    }
    if (!validMinValue(min, strVal.length)) {
      return false;
    }
    if (!validMaxValue(max, strVal.length)) {
      return false;
    }
  }
  return true;
}
function checkRuleStatus(rule, val) {
  const { required } = rule;
  const isEmptyVal = import_xe_utils48.default.isArray(val) ? !val.length : eqEmptyValue(val);
  if (required) {
    if (isEmptyVal) {
      return false;
    }
    if (!validRuleValue(rule, val, required)) {
      return false;
    }
  } else {
    if (!isEmptyVal) {
      if (!validRuleValue(rule, val, required)) {
        return false;
      }
    }
  }
  return true;
}
function createInternalData() {
  return {
    meTimeout: void 0,
    stTimeout: void 0,
    tooltipStore: {
      item: null,
      visible: false
    },
    itemFormatCache: {}
  };
}
var form_default = defineVxeComponent({
  name: "VxeForm",
  props: {
    collapseStatus: {
      type: Boolean,
      default: true
    },
    loading: Boolean,
    data: Object,
    size: {
      type: String,
      default: () => getConfig().form.size || getConfig().size
    },
    span: {
      type: [String, Number],
      default: () => getConfig().form.span
    },
    align: {
      type: String,
      default: () => getConfig().form.align
    },
    verticalAlign: {
      type: String,
      default: () => getConfig().form.verticalAlign
    },
    border: {
      type: Boolean,
      default: () => getConfig().form.border
    },
    titleBackground: {
      type: Boolean,
      default: () => getConfig().form.titleBackground
    },
    titleBold: {
      type: Boolean,
      default: () => getConfig().form.titleBold
    },
    titleAlign: {
      type: String,
      default: () => getConfig().form.titleAlign
    },
    titleWidth: {
      type: [String, Number],
      default: () => getConfig().form.titleWidth
    },
    titleColon: {
      type: Boolean,
      default: () => getConfig().form.titleColon
    },
    titleAsterisk: {
      type: Boolean,
      default: () => getConfig().form.titleAsterisk
    },
    titleOverflow: {
      type: [Boolean, String],
      default: () => getConfig().form.titleOverflow
    },
    vertical: {
      type: Boolean,
      default: () => getConfig().form.vertical
    },
    padding: {
      type: Boolean,
      default: () => getConfig().form.padding
    },
    className: [String, Function],
    readonly: Boolean,
    disabled: Boolean,
    items: Array,
    rules: Object,
    preventSubmit: {
      type: Boolean,
      default: () => getConfig().form.preventSubmit
    },
    validConfig: Object,
    tooltipConfig: Object,
    collapseConfig: Object,
    customLayout: {
      type: Boolean,
      default: () => getConfig().form.customLayout
    },
    params: Object
  },
  emits: [
    "update:collapseStatus",
    "collapse",
    "toggle-collapse",
    "submit",
    "submit-invalid",
    "reset"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeGrid = inject("$xeGrid", null);
    const xID = import_xe_utils48.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      collapseAll: props.collapseStatus,
      staticItems: [],
      formItems: [],
      itemWidth: 0
    });
    const internalData = createInternalData();
    const refElem = ref();
    const refTooltip = ref();
    let formMethods = {};
    const computeValidOpts = computed(() => {
      return Object.assign({}, getConfig().form.validConfig, props.validConfig);
    });
    const computeTooltipOpts = computed(() => {
      return Object.assign({}, getConfig().tooltip, getConfig().form.tooltipConfig, props.tooltipConfig);
    });
    const computeCollapseOpts = computed(() => {
      return Object.assign({}, getConfig().form.collapseConfig, props.collapseConfig);
    });
    const computeAutoItemWidthList = computed(() => {
      const { titleWidth: allTitleWidth, vertical: allVertical } = props;
      const { formItems } = reactData;
      const itemList = [];
      import_xe_utils48.default.eachTree(formItems, (item) => {
        const { titleWidth, vertical } = item;
        if (titleWidth === "auto") {
          itemList.push(item);
        } else {
          const itemVertical = import_xe_utils48.default.eqNull(vertical) ? allVertical : vertical;
          const itemTitleWidth = itemVertical ? null : import_xe_utils48.default.eqNull(titleWidth) ? allTitleWidth : titleWidth;
          if (itemTitleWidth === "auto" && (!item.children || !item.children.length)) {
            itemList.push(item);
          }
        }
      }, { children: "children" });
      return itemList;
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize,
      computeValidOpts,
      computeTooltipOpts,
      computeCollapseOpts,
      computeAutoItemWidthList
    };
    const $xeForm = {
      xID,
      props,
      context,
      reactData,
      internalData,
      xeGrid: $xeGrid,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils48.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils48.default.isFunction(slotFunc)) {
          return getSlotVNs2(slotFunc(params));
        }
      }
      return [];
    };
    const loadItem = (list) => {
      if (list.length) {
        list.forEach((item) => {
          if (item.slots) {
            import_xe_utils48.default.each(item.slots, (func) => {
              if (!import_xe_utils48.default.isFunction(func)) {
                if (!slots[func]) {
                  errLog("vxe.error.notSlot", [`[form] ${func}`]);
                }
              }
            });
          }
        });
      }
      reactData.staticItems = import_xe_utils48.default.mapTree(list, (item) => createItem($xeForm, item), { children: "children" });
      internalData.itemFormatCache = {};
      return nextTick().then(() => {
        return recalculate();
      });
    };
    const getItems = () => {
      const itemList = [];
      import_xe_utils48.default.eachTree(reactData.formItems, (item) => {
        itemList.push(item);
      }, { children: "children" });
      return itemList;
    };
    const getItemByField = (field) => {
      const rest = import_xe_utils48.default.findTree(reactData.formItems, (item) => item.field === field, { children: "children" });
      return rest ? rest.item : null;
    };
    const getCollapseStatus = () => {
      return reactData.collapseAll;
    };
    const toggleCollapse = () => {
      const status = !getCollapseStatus();
      reactData.collapseAll = status;
      emit("update:collapseStatus", status);
      return nextTick();
    };
    const toggleCollapseEvent = (evnt) => {
      const actionRest = toggleCollapse();
      const status = getCollapseStatus();
      formMethods.dispatchEvent("toggle-collapse", { status, collapse: status, data: props.data }, evnt);
      formMethods.dispatchEvent("collapse", { status, collapse: status, data: props.data }, evnt);
      actionRest.then(() => {
        recalculate().then(() => {
          if ($xeGrid) {
            $xeGrid.recalculate(true);
          }
        });
        if ($xeGrid) {
          $xeGrid.recalculate();
        }
      });
    };
    const clearValidate = (fieldOrItem) => {
      if (fieldOrItem) {
        let fields = fieldOrItem;
        if (!import_xe_utils48.default.isArray(fieldOrItem)) {
          fields = [fieldOrItem];
        }
        fields.forEach((field) => {
          if (field) {
            const item = handleFieldOrItem($xeForm, field);
            if (item) {
              item.showError = false;
              item.showIconMsg = false;
            }
          }
        });
      } else {
        getItems().forEach((item) => {
          item.showError = false;
          item.showIconMsg = false;
        });
      }
      return nextTick();
    };
    const getResetValue = (item, data, itemValue) => {
      const { field, resetValue } = item;
      if (import_xe_utils48.default.isFunction(resetValue)) {
        return resetValue({ field, item, data, $form: $xeForm, $grid: $xeGrid });
      } else if (import_xe_utils48.default.eqNull(resetValue)) {
        if (import_xe_utils48.default.isArray(itemValue)) {
          return [];
        }
      }
      return resetValue;
    };
    const reset = () => {
      const { data } = props;
      const itemList = getItems();
      if (data) {
        itemList.forEach((item) => {
          const { field, itemRender } = item;
          if (isEnableConf(itemRender)) {
            const { name, startField, endField } = itemRender;
            const compConf = renderer.get(name);
            const fiResetMethod = compConf ? compConf.formItemResetMethod || compConf.itemResetMethod : null;
            if (compConf && fiResetMethod) {
              fiResetMethod({ data, field, property: field, item, $form: $xeForm, $grid: $xeGrid });
            } else if (field) {
              const itemValue = import_xe_utils48.default.get(data, field);
              import_xe_utils48.default.set(data, field, getResetValue(item, data, itemValue));
            }
            if (startField && endField) {
              import_xe_utils48.default.set(data, startField, getResetValue(item, data, import_xe_utils48.default.get(data, startField)));
              import_xe_utils48.default.set(data, endField, getResetValue(item, data, import_xe_utils48.default.get(data, endField)));
            }
          }
        });
      }
      internalData.itemFormatCache = {};
      clearValidate();
      return recalculate();
    };
    const resetEvent = (evnt) => {
      evnt.preventDefault();
      reset();
      formMethods.dispatchEvent("reset", { data: props.data }, evnt);
    };
    const handleFocus = (fields) => {
      const el = refElem.value;
      if (el) {
        for (let i = 0; i < fields.length; i++) {
          const field = fields[i];
          const item = getItemByField(field);
          if (item && isEnableConf(item.itemRender)) {
            const { itemRender } = item;
            const compConf = renderer.get(itemRender.name);
            if (!i) {
              scrollToView(el.querySelector(`.${item.id}`));
            }
            let inputElem = null;
            const autoFocus = itemRender.autoFocus || itemRender.autofocus || (compConf ? compConf.formItemAutoFocus : null);
            if (import_xe_utils48.default.isFunction(autoFocus)) {
              inputElem = autoFocus({ $form: $xeForm, $grid: $xeGrid, item, data: props.data, field });
            } else {
              if (autoFocus === true) {
                inputElem = el.querySelector(`.${item.id} input,textarea`);
              } else if (autoFocus) {
                inputElem = el.querySelector(`.${item.id} ${autoFocus}`);
              }
            }
            if (inputElem) {
              inputElem.focus();
              break;
            }
          }
        }
      }
    };
    const validItemRules = (validType, fields, val) => {
      const { data, rules: formRules } = props;
      const errorMaps = {};
      if (!import_xe_utils48.default.isArray(fields)) {
        fields = [fields];
      }
      return Promise.all(fields.map((property) => {
        const errorRules = [];
        const syncVailds = [];
        if (property && formRules) {
          const rules = import_xe_utils48.default.get(formRules, property);
          if (rules) {
            const itemValue = import_xe_utils48.default.isUndefined(val) ? import_xe_utils48.default.get(data, property) : val;
            rules.forEach((rule) => {
              const { trigger, validator } = rule;
              if (validType === "all" || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    itemValue,
                    rule,
                    rules,
                    data,
                    field: property,
                    property,
                    $form: $xeForm
                  };
                  let customValid;
                  if (import_xe_utils48.default.isString(validator)) {
                    const gvItem = validators.get(validator);
                    if (gvItem) {
                      const validatorMethod = gvItem.formItemValidatorMethod || gvItem.itemValidatorMethod;
                      if (validatorMethod) {
                        customValid = validatorMethod(validParams);
                      } else {
                        warnLog("vxe.error.notValidators", [`[form] ${validator}`]);
                      }
                    } else {
                      errLog("vxe.error.notValidators", [`[form] ${validator}`]);
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (import_xe_utils48.default.isError(customValid)) {
                      errorRules.push(new Rule({ type: "custom", trigger, content: customValid.message, rule: new Rule(rule) }));
                    } else if (customValid.catch) {
                      syncVailds.push(customValid.catch((e) => {
                        errorRules.push(new Rule({ type: "custom", trigger, content: e ? e.message : rule.content || rule.message, rule: new Rule(rule) }));
                      }));
                    }
                  }
                } else {
                  if (!checkRuleStatus(rule, itemValue)) {
                    errorRules.push(new Rule(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncVailds).then(() => {
          if (errorRules.length) {
            errorMaps[property] = errorRules.map((rule) => {
              return {
                $form: $xeForm,
                rule,
                data,
                field: property,
                property
              };
            });
          }
        });
      })).then(() => {
        if (!import_xe_utils48.default.isEmpty(errorMaps)) {
          return Promise.reject(errorMaps);
        }
      });
    };
    const beginValidate = (itemList, type, callback) => {
      const { data, rules: formRules } = props;
      const validOpts = computeValidOpts.value;
      const validRest = {};
      const validFields = [];
      const itemValids = [];
      clearTimeout(internalData.meTimeout);
      if (data && formRules) {
        itemList.forEach((item) => {
          const { field } = item;
          if (field && !isHiddenItem($xeForm, item) && isActiveItem($xeForm, item)) {
            itemValids.push(validItemRules(type || "all", field).then(() => {
              item.errRule = null;
            }).catch((errorMaps) => {
              const rest = errorMaps[field];
              if (!validRest[field]) {
                validRest[field] = [];
              }
              validRest[field].push(rest);
              validFields.push(field);
              item.errRule = rest[0].rule;
              return Promise.reject(rest);
            }));
          }
        });
        return Promise.all(itemValids).then(() => {
          if (callback) {
            callback();
          }
        }).catch(() => {
          return new Promise((resolve) => {
            internalData.meTimeout = setTimeout(() => {
              itemList.forEach((item) => {
                if (item.errRule) {
                  item.showError = true;
                }
              });
            }, 20);
            if (validOpts.autoPos !== false) {
              nextTick(() => {
                handleFocus(validFields);
              });
            }
            if (callback) {
              callback(validRest);
              resolve();
            } else {
              resolve(validRest);
            }
          });
        });
      }
      if (callback) {
        callback();
      }
      return Promise.resolve();
    };
    const validate = (callback) => {
      const { readonly } = props;
      clearValidate();
      if (readonly) {
        return nextTick();
      }
      return beginValidate(getItems(), "", callback).then((params) => {
        recalculate();
        return params;
      });
    };
    const validateField = (fieldOrItem, callback) => {
      const { readonly } = props;
      if (readonly) {
        return nextTick();
      }
      let fields = [];
      if (fieldOrItem) {
        if (import_xe_utils48.default.isArray(fieldOrItem)) {
          fields = fieldOrItem;
        } else {
          fields = [fieldOrItem];
        }
      }
      return beginValidate(fields.map((field) => handleFieldOrItem($xeForm, field)), "", callback).then((params) => {
        recalculate();
        return params;
      });
    };
    const submitEvent = (evnt) => {
      const { readonly } = props;
      evnt.preventDefault();
      if (!props.preventSubmit) {
        clearValidate();
        if (readonly) {
          formMethods.dispatchEvent("submit", { data: props.data }, evnt);
          recalculate();
          return;
        }
        beginValidate(getItems()).then((errMap) => {
          if (errMap) {
            formMethods.dispatchEvent("submit-invalid", { data: props.data, errMap }, evnt);
          } else {
            formMethods.dispatchEvent("submit", { data: props.data }, evnt);
          }
          recalculate();
        });
      }
    };
    const closeTooltip = () => {
      const { tooltipStore } = internalData;
      const $tooltip = refTooltip.value;
      if (tooltipStore.visible) {
        Object.assign(tooltipStore, {
          item: null,
          visible: false
        });
        if ($tooltip) {
          $tooltip.close();
        }
      }
      return nextTick();
    };
    const triggerTitleTipEvent = (evnt, params) => {
      const { item } = params;
      const { tooltipStore } = internalData;
      const $tooltip = refTooltip.value;
      const overflowElem = evnt.currentTarget.children[0];
      const content = (overflowElem.textContent || "").trim();
      const isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      clearTimeout(internalData.stTimeout);
      if (tooltipStore.item !== item) {
        closeTooltip();
      }
      if (content && isCellOverflow) {
        Object.assign(tooltipStore, {
          item,
          visible: true
        });
        if ($tooltip) {
          $tooltip.open(overflowElem, content);
        }
      }
    };
    const handleTitleTipLeaveEvent = () => {
      const tooltipOpts = computeTooltipOpts.value;
      let $tooltip = refTooltip.value;
      if ($tooltip) {
        $tooltip.setActived(false);
      }
      if (tooltipOpts.enterable) {
        internalData.stTimeout = setTimeout(() => {
          $tooltip = refTooltip.value;
          if ($tooltip && !$tooltip.isActived()) {
            closeTooltip();
          }
        }, tooltipOpts.leaveDelay);
      } else {
        closeTooltip();
      }
    };
    const triggerItemEvent = (evnt, field, itemValue) => {
      if (field) {
        return validItemRules(evnt ? ["blur"].includes(evnt.type) ? "blur" : "change" : "all", field, itemValue).then(() => {
          clearValidate(field);
        }).catch((errorMaps) => {
          const rest = errorMaps[field];
          const item = getItemByField(field);
          if (rest && item) {
            item.showError = true;
            item.errRule = rest[0].rule;
          }
        });
      }
      return nextTick();
    };
    const updateStatus = (scope, itemValue) => {
      const { field } = scope;
      return triggerItemEvent(new Event("change"), field, itemValue);
    };
    const recalculate = () => {
      const autoItemWidthList = computeAutoItemWidthList.value;
      const el = refElem.value;
      if (el && autoItemWidthList.length) {
        const itemElList = el.querySelectorAll(autoItemWidthList.map((item) => `.vxe-form--item-title[itemid="${item.id}"]`).join(","));
        let maxItemWidth = 0;
        import_xe_utils48.default.arrayEach(itemElList, (itemEl) => {
          itemEl.style.width = "";
          maxItemWidth = Math.max(maxItemWidth, Math.ceil(itemEl.clientWidth + 2));
        });
        import_xe_utils48.default.arrayEach(itemElList, (itemEl) => {
          itemEl.style.width = `${maxItemWidth}px`;
        });
      }
      return nextTick();
    };
    const handleGlobalResizeEvent = () => {
      recalculate();
    };
    formMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $form: $xeForm, $grid: $xeGrid }, params));
      },
      reset,
      validate,
      validateField,
      clearValidate,
      updateStatus,
      toggleCollapse,
      getItems,
      getItemByField,
      closeTooltip,
      recalculate
    };
    const formPrivateMethods = {
      callSlot,
      triggerItemEvent,
      toggleCollapseEvent,
      triggerTitleTipEvent,
      handleTitleTipLeaveEvent,
      handleValidIconEvent(evnt, params) {
        const { item } = params;
        item.showIconMsg = !item.showIconMsg;
      }
    };
    Object.assign($xeForm, formMethods, formPrivateMethods);
    const renderVN = () => {
      const { loading: loading2, border, className, data, customLayout } = props;
      const { formItems } = reactData;
      const vSize = computeSize.value;
      const tooltipOpts = computeTooltipOpts.value;
      const defaultSlot = slots.default;
      return h("form", {
        ref: refElem,
        class: ["vxe-form", className ? import_xe_utils48.default.isFunction(className) ? className({ items: formItems, data, $form: $xeForm }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--border": border,
          "custom--layout": customLayout,
          "is--loading": loading2
        }],
        onSubmit: submitEvent,
        onReset: resetEvent
      }, [
        h("div", {
          class: "vxe-form--wrapper vxe-form--item-row"
        }, customLayout ? defaultSlot ? defaultSlot({}) : [] : formItems.map((item, index) => {
          return h(form_config_item_default, {
            key: index,
            itemConfig: item
          });
        })),
        h("div", {
          class: "vxe-form-slots",
          ref: "hideItem"
        }, customLayout ? [] : defaultSlot ? defaultSlot({}) : []),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-form--loading",
          modelValue: loading2
        }),
        /**
         * 工具提示
         */
        h(tooltip_default, Object.assign({ ref: refTooltip }, tooltipOpts))
      ]);
    };
    const recalcFlag = ref(0);
    watch(() => props.vertical, () => {
      recalcFlag.value++;
    });
    watch(() => props.titleWidth, () => {
      recalcFlag.value++;
    });
    watch(recalcFlag, () => {
      nextTick().then(() => {
        recalculate();
      });
    });
    const staticItemFlag = ref(0);
    watch(() => reactData.staticItems.length, () => {
      staticItemFlag.value++;
    });
    watch(() => reactData.staticItems, () => {
      staticItemFlag.value++;
    });
    watch(staticItemFlag, () => {
      reactData.formItems = reactData.staticItems;
      recalcFlag.value++;
    });
    const itemFlag = ref(0);
    watch(() => props.items ? props.items.length : -1, () => {
      itemFlag.value++;
    });
    watch(() => props.items, () => {
      itemFlag.value++;
    });
    watch(itemFlag, () => {
      loadItem(props.items || []);
    });
    watch(() => props.collapseStatus, (value) => {
      reactData.collapseAll = !!value;
    });
    watch(() => props.readonly, () => {
      clearValidate();
    });
    watch(() => props.disabled, () => {
      clearValidate();
    });
    onMounted(() => {
      nextTick(() => {
        if (props.customLayout && props.items) {
          errLog("vxe.error.errConflicts", ["[form] custom-layout", "items"]);
        }
      });
      globalEvents.on($xeForm, "resize", handleGlobalResizeEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeForm, "resize");
      import_xe_utils48.default.assign(internalData, createInternalData());
    });
    if (props.items) {
      loadItem(props.items);
    }
    provide("xeFormItemInfo", null);
    provide("$xeForm", $xeForm);
    provide("$xeFormGroup", null);
    provide("$xeFormItem", null);
    $xeForm.renderVN = renderVN;
    return $xeForm;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form/index.js
var VxeForm = Object.assign(form_default, {
  install(app) {
    app.component(form_default.name, form_default);
  }
});
dynamicApp.use(VxeForm);
VxeUI.component(form_default);
var Form = VxeForm;
var form_default2 = VxeForm;

// node_modules/vxe-pc-ui/es/form/src/form-item.js
var import_xe_utils49 = __toESM(require_xe_utils());
var formItemProps = {
  title: String,
  field: String,
  span: {
    type: [String, Number],
    default: null
  },
  align: {
    type: String,
    default: null
  },
  verticalAlign: {
    type: String,
    default: null
  },
  titleBackground: {
    type: Boolean,
    default: null
  },
  titleBold: {
    type: Boolean,
    default: null
  },
  titleAlign: {
    type: String,
    default: null
  },
  titleWidth: {
    type: [String, Number],
    default: null
  },
  titleColon: {
    type: Boolean,
    default: null
  },
  titleAsterisk: {
    type: Boolean,
    default: null
  },
  showTitle: {
    type: Boolean,
    default: true
  },
  vertical: {
    type: Boolean,
    default: null
  },
  padding: {
    type: Boolean,
    default: null
  },
  formatter: [String, Function],
  className: [String, Function],
  contentClassName: [String, Function],
  contentStyle: [Object, Function],
  titleClassName: [String, Function],
  titleStyle: [Object, Function],
  titleOverflow: {
    type: [Boolean, String],
    default: null
  },
  titlePrefix: Object,
  titleSuffix: Object,
  resetValue: { default: null },
  visibleMethod: Function,
  visible: {
    type: Boolean,
    default: null
  },
  showContent: {
    type: Boolean,
    default: null
  },
  folding: Boolean,
  collapseNode: Boolean,
  itemRender: Object,
  rules: Array,
  params: Object
};
var form_item_default = defineVxeComponent({
  name: "VxeFormItem",
  props: formItemProps,
  setup(props, { slots }) {
    const xID = import_xe_utils49.default.uniqueId();
    const refElem = ref();
    const $xeForm = inject("$xeForm", {});
    const $xeFormGroup = inject("$xeFormGroup", null);
    const formItem = reactive(createItem($xeForm, props));
    formItem.slots = slots;
    const formItemInfo = { itemConfig: formItem };
    provide("xeFormItemInfo", formItemInfo);
    const renderItem = ($xeForm2, item) => {
      const formProps = $xeForm2.props;
      const $xeGrid = $xeForm2.xeGrid;
      const { data, readonly, disabled } = formProps;
      const { visible, field, itemRender, contentStyle, showContent } = item;
      const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm2, $grid: $xeGrid };
      if (visible === false) {
        return renderEmptyElement($xeFormItem);
      }
      return h("div", {
        ref: refElem,
        key: item.id,
        itemid: item.id,
        class: getItemClass($xeForm2, item),
        style: import_xe_utils49.default.isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [
        renderTitle($xeForm2, item),
        showContent === false ? renderEmptyElement($xeFormItem) : h("div", {
          class: getItemContentClass($xeForm2, item),
          style: Object.assign({}, import_xe_utils49.default.isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, import_xe_utils49.default.isFunction(contentStyle) ? contentStyle(params) : contentStyle)
        }, [
          renderItemContent($xeForm2, item),
          renderItemErrorIcon($xeForm2, item)
        ])
      ]);
    };
    const renderVN = () => {
      const customLayout = $xeForm ? $xeForm.props.customLayout : false;
      const item = formItem;
      return customLayout ? renderItem($xeForm, item) : h("div", {
        ref: refElem
      });
    };
    const $xeFormItem = {
      xID,
      formItem,
      renderVN
    };
    watchItem(props, formItem);
    onMounted(() => {
      const elem = refElem.value;
      assembleItem($xeForm, elem, formItem, $xeFormGroup);
    });
    onUnmounted(() => {
      destroyItem($xeForm, formItem);
    });
    provide("$xeFormItem", $xeFormItem);
    provide("$xeFormGroup", null);
    return $xeFormItem;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form/src/form-group.js
var import_xe_utils50 = __toESM(require_xe_utils());
var form_group_default = defineVxeComponent({
  name: "VxeFormGroup",
  props: formItemProps,
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils50.default.uniqueId();
    const refElem = ref();
    const $xeForm = inject("$xeForm", {});
    const $xeParentFormGroup = inject("$xeFormGroup", null);
    const formItem = reactive(createItem($xeForm, props));
    formItem.slots = slots;
    formItem.children = [];
    const formItemInfo = { itemConfig: formItem };
    provide("xeFormItemInfo", formItemInfo);
    const renderVN = () => {
      const formProps = $xeForm.props;
      const $xeGrid = $xeForm.xeGrid;
      const item = formItem;
      const { data, readonly, disabled } = formProps;
      const { visible, field, itemRender, contentStyle } = item;
      const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const defaultSlot = slots ? slots.default : null;
      const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeGrid };
      if (visible === false) {
        return renderEmptyElement($xeFormGroup);
      }
      return h("div", {
        ref: refElem,
        key: item.id,
        itemid: item.id,
        class: getItemClass($xeForm, item, true),
        style: import_xe_utils50.default.isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [
        renderTitle($xeForm, item, true),
        h("div", {
          class: getItemContentClass($xeForm, item, true),
          style: Object.assign({}, import_xe_utils50.default.isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, import_xe_utils50.default.isFunction(contentStyle) ? contentStyle(params) : contentStyle)
        }, defaultSlot ? defaultSlot({}) : [])
      ]);
    };
    const $xeFormGroup = {
      xID,
      formItem,
      renderVN
    };
    watchItem(props, formItem);
    onMounted(() => {
      const elem = refElem.value;
      assembleItem($xeForm, elem, formItem, $xeParentFormGroup);
    });
    onUnmounted(() => {
      destroyItem($xeForm, formItem);
    });
    provide("$xeFormGroup", $xeFormGroup);
    provide("$xeFormItem", null);
    return $xeFormGroup;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-gather/index.js
var VxeFormGatherComponent = Object.assign({}, form_group_default, { name: "VxeFormGather" });
var VxeFormGather = Object.assign(VxeFormGatherComponent, {
  install(app) {
    app.component(VxeFormGatherComponent.name, VxeFormGatherComponent);
  }
});
dynamicApp.use(VxeFormGather);
VxeUI.component(VxeFormGatherComponent);
var FormGather = VxeFormGather;
var form_gather_default = VxeFormGather;

// node_modules/vxe-pc-ui/es/form-group/index.js
var VxeFormGroup = Object.assign(form_group_default, {
  install(app) {
    app.component(form_group_default.name, form_group_default);
  }
});
dynamicApp.use(VxeFormGroup);
VxeUI.component(form_group_default);
var FormGroup = VxeFormGroup;
var form_group_default2 = VxeFormGroup;

// node_modules/vxe-pc-ui/es/form-item/index.js
var VxeFormItem = Object.assign(form_item_default, {
  install(app) {
    app.component(form_item_default.name, form_item_default);
  }
});
dynamicApp.use(VxeFormItem);
VxeUI.component(form_item_default);
var FormItem = VxeFormItem;
var form_item_default2 = VxeFormItem;

// node_modules/vxe-pc-ui/es/icon/index.js
var VxeIcon = Object.assign({}, icon_default, {
  install(app) {
    app.component(icon_default.name, icon_default);
  }
});
dynamicApp.use(VxeIcon);
VxeUI.component(icon_default);
var Icon = VxeIcon;
var icon_default2 = VxeIcon;

// node_modules/vxe-pc-ui/es/icon-picker/src/icon-picker.js
var import_xe_utils51 = __toESM(require_xe_utils());
var icon_picker_default = defineVxeComponent({
  name: "VxeIconPicker",
  props: {
    modelValue: String,
    placeholder: String,
    clearable: Boolean,
    size: {
      type: String,
      default: () => getConfig().iconPicker.size || getConfig().size
    },
    className: [String, Function],
    popupClassName: [String, Function],
    showIconTitle: {
      type: Boolean,
      default: () => getConfig().iconPicker.showIconTitle
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    icons: Array,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils51.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      selectIcon: `${props.modelValue || ""}`,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      // hpTimeout: undefined
    };
    const refElem = ref();
    const refInput = ref();
    const refOptionPanel = ref();
    const refMaps = {
      refElem
    };
    const $xeIconPicker = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let iconPickerMethods = {};
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().iconPicker.transfer;
        if (import_xe_utils51.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().select.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseSelect");
    });
    const computeIconList = computed(() => {
      let { icons } = props;
      if (!icons || !icons.length) {
        icons = getConfig().iconPicker.icons || [];
      }
      return icons.map((item) => {
        if (import_xe_utils51.default.isString(item)) {
          return {
            title: item,
            icon: `vxe-icon-${`${item || ""}`.replace(/^vxe-icon-/, "")}`
          };
        }
        return {
          title: `${item.title || ""}`,
          icon: item.icon || "",
          iconRender: item.iconRender
        };
      });
    });
    const computeIconGroupList = computed(() => {
      const iconList = computeIconList.value;
      return import_xe_utils51.default.chunk(iconList, 4);
    });
    const computeSelectIconItem = computed(() => {
      const { selectIcon } = reactData;
      const iconList = computeIconList.value;
      return selectIcon ? iconList.find((item) => item.icon === selectIcon) : null;
    });
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (panelElem && el) {
          const targetHeight = el.offsetHeight;
          const targetWidth = el.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(el);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showOptionPanel = () => {
      const { hpTimeout } = internalData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = void 0;
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      reactData.selectIcon = selectValue;
      if (selectValue !== props.modelValue) {
        emit("update:modelValue", selectValue);
        dispatchEvent("change", { value: selectValue }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const focusEvent = () => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
      }
    };
    const blurEvent = () => {
      reactData.isActivated = false;
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      dispatchEvent("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const togglePanelEvent = (evnt) => {
      evnt.preventDefault();
      if (reactData.visiblePanel) {
        hideOptionPanel();
      } else {
        showOptionPanel();
      }
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      dispatchEvent("click", {}, evnt);
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isSpacebar = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            evnt.preventDefault();
            evnt.stopPropagation();
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
          } else if (isSpacebar) {
            evnt.preventDefault();
          }
        } else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { visiblePanel, isActivated } = reactData;
      if (visiblePanel) {
        hideOptionPanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $iconPicker: $xeIconPicker }, params));
    };
    iconPickerMethods = {
      dispatchEvent,
      isPanelVisible() {
        return reactData.visiblePanel;
      },
      togglePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return nextTick();
      },
      hidePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return nextTick();
      },
      showPanel() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return nextTick();
      },
      focus() {
        const $input = refInput.value;
        reactData.isActivated = true;
        if ($input) {
          $input.blur();
        }
        return nextTick();
      },
      blur() {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
        reactData.isActivated = false;
        return nextTick();
      }
    };
    const handleClickIconEvent = (evnt, item) => {
      const value = item.icon;
      changeEvent(evnt, value);
      hideOptionPanel();
    };
    Object.assign($xeIconPicker, iconPickerMethods);
    const renderIconWrapper = () => {
      const { showIconTitle } = props;
      const iconGroupList = computeIconGroupList.value;
      const isDisabled = computeIsDisabled.value;
      return h("div", {
        class: "vxe-ico-picker--list-wrapper"
      }, iconGroupList.map((list) => {
        return h("div", {
          class: "vxe-ico-picker--list"
        }, list.map((item) => {
          const { iconRender } = item;
          const compConf = iconRender ? renderer.get(iconRender.name) : null;
          const oIconMethod = compConf ? compConf.renderIconPickerOptionIcon : null;
          return h("div", {
            class: "vxe-ico-picker--item",
            onClick(evnt) {
              if (!isDisabled) {
                handleClickIconEvent(evnt, item);
              }
            }
          }, [
            h("div", {
              class: "vxe-ico-picker--item-icon"
            }, oIconMethod && iconRender ? getSlotVNs2(oIconMethod(iconRender, { $iconPicker: $xeIconPicker, option: item })) : [
              h("i", {
                class: item.icon || ""
              })
            ]),
            showIconTitle ? h("div", {
              class: "vxe-ico-picker--item-title"
            }, `${item.title || ""}`) : renderEmptyElement($xeIconPicker)
          ]);
        }));
      }));
    };
    const renderIconView = () => {
      const { selectIcon } = reactData;
      const selectIconItem = computeSelectIconItem.value;
      if (selectIconItem) {
        const { iconRender } = selectIconItem;
        const compConf = iconRender ? renderer.get(iconRender.name) : null;
        const oIconMethod = compConf ? compConf.renderIconPickerOptionIcon : null;
        if (oIconMethod && iconRender) {
          return h("div", {
            key: "inc",
            class: "vxe-ico-picker--icon"
          }, getSlotVNs2(oIconMethod(iconRender, { $iconPicker: $xeIconPicker, option: selectIconItem })));
        }
      }
      return h("div", {
        key: "ind",
        class: "vxe-ico-picker--icon"
      }, [
        h("i", {
          class: selectIcon
        })
      ]);
    };
    const renderVN = () => {
      const { className, popupClassName, clearable } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel, selectIcon } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-ico-picker--readonly", className]
        }, [
          h("i", {
            class: selectIcon
          })
        ]);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-ico-picker", className ? import_xe_utils51.default.isFunction(className) ? className({ $iconPicker: $xeIconPicker }) : className : "", {
          [`size--${vSize}`]: vSize,
          "show--clear": clearable && !isDisabled && !!selectIcon,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--active": isActivated
        }]
      }, [
        h("div", {
          class: "vxe-ico-picker--inner",
          onClick: clickEvent
        }, [
          h("input", {
            ref: refInput,
            class: "vxe-ico-picker--input",
            onFocus: focusEvent,
            onBlur: blurEvent
          }),
          selectIcon ? renderIconView() : h("div", {
            class: "vxe-ico-picker--placeholder"
          }, inpPlaceholder),
          h("div", {
            class: "vxe-ico-picker--suffix"
          }, [
            h("div", {
              class: "vxe-ico-picker--clear-icon",
              onClick: clearEvent
            }, [
              h("i", {
                class: getIcon().INPUT_CLEAR
              })
            ]),
            h("div", {
              class: "vxe-ico-picker--suffix-icon"
            }, [
              h("i", {
                class: visiblePanel ? getIcon().ICON_PICKER_OPEN : getIcon().ICON_PICKER_CLOSE
              })
            ])
          ])
        ]),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-ico-picker--panel", popupClassName ? import_xe_utils51.default.isFunction(popupClassName) ? popupClassName({ $iconPicker: $xeIconPicker }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, [
            initialized && (visiblePanel || isAniVisible) ? h("div", {
              class: "vxe-ico-picker--panel-wrapper"
            }, [
              renderIconWrapper()
            ]) : renderEmptyElement($xeIconPicker)
          ])
        ])
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.selectIcon = `${val || ""}`;
    });
    onMounted(() => {
      globalEvents.on($xeIconPicker, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeIconPicker, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeIconPicker, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeIconPicker, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeIconPicker, "mousewheel");
      globalEvents.off($xeIconPicker, "mousedown");
      globalEvents.off($xeIconPicker, "keydown");
      globalEvents.off($xeIconPicker, "blur");
    });
    provide("$xeIconPicker", $xeIconPicker);
    $xeIconPicker.renderVN = renderVN;
    return $xeIconPicker;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/icon-picker/index.js
var VxeIconPicker = Object.assign(icon_picker_default, {
  install: function(app) {
    app.component(icon_picker_default.name, icon_picker_default);
  }
});
dynamicApp.use(VxeIconPicker);
VxeUI.component(icon_picker_default);
var IconPicker = VxeIconPicker;
var icon_picker_default2 = VxeIconPicker;

// node_modules/vxe-pc-ui/es/image/src/image.js
var import_xe_utils54 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/image/src/preview.js
var import_xe_utils52 = __toESM(require_xe_utils());
var preview_default = defineVxeComponent({
  name: "VxeImagePreview",
  props: {
    modelValue: Number,
    urlList: Array,
    urlField: {
      type: String,
      default: () => getConfig().imagePreview.urlField
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().imagePreview.maskClosable
    },
    marginSize: {
      type: String,
      default: () => getConfig().imagePreview.marginSize
    },
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().imagePreview.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().imagePreview.showDownloadButton
    },
    zIndex: Number,
    toolbarConfig: Object,
    beforeDownloadMethod: Function,
    downloadMethod: Function
  },
  emits: [
    "update:modelValue",
    "change",
    "download",
    "download-fail",
    "rotate",
    "close"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils52.default.uniqueId();
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const reactData = reactive({
      activeIndex: props.modelValue || 0,
      offsetPct11: false,
      offsetScale: 0,
      offsetRotate: 0,
      offsetLeft: 0,
      offsetTop: 0
    });
    const computeUrlProp = computed(() => {
      return props.urlField || "url";
    });
    const computeMarginSize = computed(() => {
      return import_xe_utils52.default.toNumber(props.marginSize || 0) || 16;
    });
    const computeToolbarOpts = computed(() => {
      return Object.assign({}, getConfig().imagePreview.toolbarConfig, props.toolbarConfig);
    });
    const computeRotateText = computed(() => {
      const { offsetRotate } = reactData;
      if (offsetRotate) {
        return `${offsetRotate}°`;
      }
      return "0°";
    });
    const computeScaleText = computed(() => {
      const { offsetScale } = reactData;
      if (offsetScale) {
        return `${import_xe_utils52.default.ceil((1 + offsetScale) * 100)}%`;
      }
      return "100%";
    });
    const computeImgList = computed(() => {
      const { urlList } = props;
      const urlProp = computeUrlProp.value;
      if (urlList && urlList.length) {
        return urlList.map((item) => {
          if (import_xe_utils52.default.isString(item)) {
            return item;
          }
          if (item[urlProp]) {
            return item[urlProp];
          }
          return "";
        });
      }
      return [];
    });
    const computeImgTransform = computed(() => {
      let { offsetScale, offsetRotate, offsetLeft, offsetTop } = reactData;
      const stys = [];
      let targetScale = 1;
      if (offsetScale) {
        targetScale = 1 + offsetScale;
        stys.push(`scale(${targetScale})`);
      }
      if (offsetRotate) {
        stys.push(`rotate(${offsetRotate}deg)`);
      }
      if (offsetLeft || offsetTop) {
        offsetLeft /= targetScale;
        offsetTop /= targetScale;
        let targetOffsetLeft = offsetLeft;
        let targetOffsetTop = offsetTop;
        if (offsetRotate) {
          switch (offsetRotate % 360) {
            case 90:
            case -270:
              targetOffsetLeft = offsetTop;
              targetOffsetTop = -offsetLeft;
              break;
            case 180:
            case -180:
              targetOffsetLeft = -offsetLeft;
              targetOffsetTop = -offsetTop;
              break;
            case 270:
            case -90:
              targetOffsetLeft = -offsetTop;
              targetOffsetTop = offsetLeft;
              break;
          }
        }
        stys.push(`translate(${targetOffsetLeft}px, ${targetOffsetTop}px)`);
      }
      return stys.length ? stys.join(" ") : "";
    });
    const computeMaps = {
      computeImgList
    };
    const $xeImagePreview = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $imagePreview: $xeImagePreview }, params));
    };
    const imagePreviewMethods = {
      dispatchEvent
    };
    const emitModel = (value) => {
      reactData.activeIndex = value;
      emit("update:modelValue", value);
    };
    const handleCloseEvent = (evnt) => {
      dispatchEvent("close", {}, evnt);
    };
    const imagePreviewPrivateMethods = {};
    const resetStyle = () => {
      const elem = refElem.value;
      removeClass(elem, "is--move");
      Object.assign(reactData, {
        offsetPct11: false,
        offsetScale: 0,
        offsetRotate: 0,
        offsetLeft: 0,
        offsetTop: 0
      });
    };
    const getOffsetZoomStep = () => {
      const { offsetScale } = reactData;
      let stepNum = 0.02;
      if (offsetScale >= -0.6) {
        stepNum = 0.04;
        if (offsetScale >= -0.4) {
          stepNum = 0.07;
          if (offsetScale >= 0) {
            stepNum = 0.1;
            if (offsetScale >= 3) {
              stepNum = 0.25;
              if (offsetScale >= 8) {
                stepNum = 0.4;
                if (offsetScale >= 16) {
                  stepNum = 0.6;
                  if (offsetScale >= 24) {
                    stepNum = 0.9;
                    if (offsetScale >= 32) {
                      stepNum = 1.3;
                      if (offsetScale >= 39) {
                        stepNum = 1.9;
                        if (offsetScale >= 45) {
                          stepNum = 2.5;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return stepNum;
    };
    const handleZoom = (isAdd) => {
      const { offsetScale } = reactData;
      const stepNum = getOffsetZoomStep();
      if (isAdd) {
        reactData.offsetScale = Number(Math.min(49, offsetScale + stepNum).toFixed(2));
      } else {
        reactData.offsetScale = Number(Math.max(-0.9, offsetScale - stepNum).toFixed(2));
      }
    };
    const handleChangeEvent = (evnt, isNext) => {
      let activeIndex = reactData.activeIndex || 0;
      const imgList = computeImgList.value;
      if (isNext) {
        if (activeIndex >= imgList.length - 1) {
          activeIndex = 0;
        } else {
          activeIndex++;
        }
      } else {
        if (activeIndex <= 0) {
          activeIndex = imgList.length - 1;
        } else {
          activeIndex--;
        }
      }
      const imgUrl = imgList[activeIndex || 0];
      reactData.activeIndex = activeIndex;
      resetStyle();
      emitModel(activeIndex);
      dispatchEvent("change", { url: imgUrl, activeIndex }, evnt);
    };
    const handleRotateImgEvent = (evnt, isRight) => {
      const imgList = computeImgList.value;
      const { activeIndex } = reactData;
      const imgUrl = imgList[activeIndex || 0];
      let offsetRotate = reactData.offsetRotate;
      if (isRight) {
        offsetRotate += 90;
      } else {
        offsetRotate -= 90;
      }
      reactData.offsetRotate = offsetRotate;
      dispatchEvent("rotate", { url: imgUrl, rotateValue: offsetRotate }, evnt);
    };
    const handlePct11 = () => {
      resetStyle();
      reactData.offsetPct11 = true;
    };
    const handlePrintImg = () => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      if (VxeUI.print) {
        VxeUI.print({
          align: "center",
          pageBreaks: [
            {
              bodyHtml: `<img src="${imgUrl}" style="max-width:100%;max-height:100%;">`
            }
          ]
        });
      }
    };
    const handleDownloadEvent = (evnt, imgUrl) => {
      dispatchEvent("download", { url: imgUrl }, evnt);
    };
    const handleDefaultDownload = (evnt, imgUrl) => {
      if (VxeUI.saveFile) {
        fetch(imgUrl).then((res) => {
          return res.blob().then((blob) => {
            VxeUI.saveFile({
              filename: imgUrl,
              content: blob
            });
            handleDownloadEvent(evnt, imgUrl);
          });
        }).catch(() => {
          if (VxeUI.modal) {
            VxeUI.modal.message({
              content: getI18n("vxe.error.downErr"),
              status: "error"
            });
          }
        });
      }
    };
    const handleDownloadImg = (evnt) => {
      const { activeIndex } = reactData;
      const toolbarOpts = computeToolbarOpts.value;
      const btnConf = toolbarOpts.download;
      const btnOpts = import_xe_utils52.default.isBoolean(btnConf) ? {} : btnConf ? Object.assign({}, btnConf) : {};
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      const beforeDownloadFn = props.beforeDownloadMethod || btnOpts.beforeDownloadMethod || getConfig().imagePreview.beforeDownloadMethod;
      const downloadFn = props.downloadMethod || btnOpts.downloadMethod || getConfig().imagePreview.downloadMethod;
      Promise.resolve(beforeDownloadFn ? beforeDownloadFn({
        $imagePreview: $xeImagePreview,
        url: imgUrl,
        index: activeIndex || 0
      }) : true).then((status) => {
        if (status) {
          if (downloadFn) {
            Promise.resolve(downloadFn({
              $imagePreview: $xeImagePreview,
              url: imgUrl,
              index: activeIndex || 0
            })).then(() => {
              handleDownloadEvent(evnt, imgUrl);
            }).catch((e) => e);
          } else {
            handleDefaultDownload(evnt, imgUrl);
          }
        }
      });
    };
    const handleOperationBtn = (evnt, code) => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      if (imgUrl) {
        switch (code) {
          case "zoomOut":
            handleZoom(false);
            break;
          case "zoomIn":
            handleZoom(true);
            break;
          case "pctFull":
            resetStyle();
            break;
          case "pct11":
            handlePct11();
            break;
          case "rotateLeft":
            handleRotateImgEvent(evnt, false);
            break;
          case "rotateRight":
            handleRotateImgEvent(evnt, true);
            break;
          case "print":
            handlePrintImg();
            break;
          case "download":
            handleDownloadImg(evnt);
            break;
        }
      }
    };
    const wheelEvent = (evnt) => {
      const delta = evnt.deltaY;
      if (delta > 0) {
        evnt.preventDefault();
        handleZoom(false);
      } else if (delta < 0) {
        evnt.preventDefault();
        handleZoom(true);
      }
    };
    const moveEvent = (evnt) => {
      const { offsetTop, offsetLeft } = reactData;
      const elem = refElem.value;
      evnt.preventDefault();
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const startX = evnt.pageX;
      const startY = evnt.pageY;
      const marginSize = computeMarginSize.value;
      document.onmousemove = (et) => {
        const { pageX, pageY } = et;
        const { visibleHeight, visibleWidth } = getDomNode();
        et.preventDefault();
        addClass(elem, "is--move");
        if (pageX > marginSize && pageY > marginSize && pageX < visibleWidth - marginSize && pageY < visibleHeight - marginSize) {
          reactData.offsetLeft = offsetLeft + pageX - startX;
          reactData.offsetTop = offsetTop + pageY - startY;
        }
      };
      document.onmouseup = () => {
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        removeClass(elem, "is--move");
      };
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const isControlKey = hasControlKey(evnt);
      const hasShiftKey = evnt.shiftKey;
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDownArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
      const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
      const isR = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.R);
      const isP = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.P);
      if (isUpArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetTop -= 1;
        } else {
          handleZoom(true);
        }
      } else if (isDownArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetTop += 1;
        } else {
          handleZoom(false);
        }
      } else if (isLeftArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetLeft -= 1;
        } else {
          handleChangeEvent(evnt, false);
        }
      } else if (isRightArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetLeft += 1;
        } else {
          handleChangeEvent(evnt, true);
        }
      } else if (isR && isControlKey) {
        evnt.preventDefault();
        if (hasShiftKey) {
          handleRotateImgEvent(evnt, false);
        } else {
          handleRotateImgEvent(evnt, true);
        }
      } else if (isP && isControlKey) {
        evnt.preventDefault();
        handlePrintImg();
      }
    };
    const handleClickMaskEvent = (evnt) => {
      if (props.maskClosable) {
        if (evnt.target === evnt.currentTarget) {
          dispatchEvent("close", {}, evnt);
        }
      }
    };
    Object.assign($xeImagePreview, imagePreviewMethods, imagePreviewPrivateMethods);
    const renderImgWrapper = () => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgTransform = computeImgTransform.value;
      return h("div", {
        class: "vxe-image-preview--img-list",
        onClick: handleClickMaskEvent
      }, imgList.map((url, index) => {
        const isActive = activeIndex === index;
        return h("img", {
          class: ["vxe-image-preview--img-item", {
            "is--active": isActive
          }],
          src: url,
          style: isActive ? {
            transform: imgTransform
          } : null,
          onMousedown(evnt) {
            moveEvent(evnt);
          }
        });
      }));
    };
    const renderOperationBtn = (code, icon) => {
      const toolbarOpts = computeToolbarOpts.value;
      const btnConf = toolbarOpts[code];
      const btnOpts = import_xe_utils52.default.isBoolean(btnConf) ? {} : btnConf ? Object.assign({}, btnConf) : {};
      const showBtn = btnConf !== false;
      return showBtn ? h("div", {
        class: "vxe-image-preview--operation-btn",
        title: getI18n(`vxe.imagePreview.operBtn.${code}`),
        onClick(evnt) {
          handleOperationBtn(evnt, code);
        }
      }, [
        h("i", {
          class: btnOpts.icon || getIcon()[icon]
        })
      ]) : renderEmptyElement($xeImagePreview);
    };
    const renderBtnWrapper = () => {
      const { showPrintButton, showDownloadButton } = props;
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const rotateText = computeRotateText.value;
      const scaleText = computeScaleText.value;
      const toolbarOpts = computeToolbarOpts.value;
      return h("div", {
        class: "vxe-image-preview--btn-wrapper"
      }, [
        h("div", {
          class: "vxe-image-preview--close-wrapper"
        }, [
          h("div", {
            class: "vxe-image-preview--close-btn",
            onClick: handleCloseEvent
          }, [
            h("i", {
              class: getIcon().IMAGE_PREVIEW_CLOSE
            })
          ]),
          h("div", {
            class: "vxe-image-preview--close-bg"
          })
        ]),
        imgList.length > 1 ? h("div", {
          class: "vxe-image-preview--previous-btn",
          onClick(evnt) {
            handleChangeEvent(evnt, false);
          }
        }, [
          h("i", {
            class: getIcon().IMAGE_PREVIEW_PREVIOUS
          })
        ]) : renderEmptyElement($xeImagePreview),
        imgList.length > 1 ? h("div", {
          class: "vxe-image-preview--next-btn",
          onClick(evnt) {
            handleChangeEvent(evnt, true);
          }
        }, [
          h("i", {
            class: getIcon().IMAGE_PREVIEW_NEXT
          })
        ]) : renderEmptyElement($xeImagePreview),
        h("div", {
          class: "vxe-image-preview--operation-info"
        }, [
          h("div", {
            class: "vxe-image-preview--operation-deg"
          }, rotateText),
          h("div", {
            class: "vxe-image-preview--operation-pct"
          }, scaleText)
        ]),
        h("div", {
          class: "vxe-image-preview--operation-wrapper"
        }, [
          h("div", {
            class: "vxe-image-preview--operation-active-count"
          }, [
            h("span", {
              class: "vxe-image-preview--operation-active-current"
            }, `${(activeIndex || 0) + 1}`),
            h("span", {
              class: "vxe-image-preview--operation-active-total"
            }, `/${imgList.length}`)
          ]),
          renderOperationBtn("zoomOut", "IMAGE_PREVIEW_ZOOM_OUT"),
          renderOperationBtn("zoomIn", "IMAGE_PREVIEW_ZOOM_IN"),
          renderOperationBtn("pctFull", "IMAGE_PREVIEW_PCT_FULL"),
          renderOperationBtn("pct11", "IMAGE_PREVIEW_PCT_1_1"),
          renderOperationBtn("rotateLeft", "IMAGE_PREVIEW_ROTATE_LEFT"),
          renderOperationBtn("rotateRight", "IMAGE_PREVIEW_ROTATE_RIGHT"),
          showPrintButton || toolbarOpts.print ? renderOperationBtn("print", "IMAGE_PREVIEW_PRINT") : renderEmptyElement($xeImagePreview),
          showDownloadButton || toolbarOpts.download ? renderOperationBtn("download", "IMAGE_PREVIEW_DOWNLOAD") : renderEmptyElement($xeImagePreview)
        ])
      ]);
    };
    const renderVN = () => {
      const { offsetPct11 } = reactData;
      return h("div", {
        ref: refElem,
        class: ["vxe-image-preview", {
          "is--pct11": offsetPct11
        }]
      }, [
        renderImgWrapper(),
        renderBtnWrapper()
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.activeIndex = val;
      resetStyle();
    });
    onMounted(() => {
      const elem = refElem.value;
      if (elem) {
        elem.addEventListener("wheel", wheelEvent, { passive: false });
      }
      globalEvents.on($xeImagePreview, "keydown", handleGlobalKeydownEvent);
    });
    onBeforeUnmount(() => {
      const elem = refElem.value;
      if (elem) {
        elem.removeEventListener("wheel", wheelEvent);
        removeClass(elem, "is--move");
      }
    });
    onUnmounted(() => {
      globalEvents.off($xeImagePreview, "keydown");
    });
    provide("$xeImagePreview", $xeImagePreview);
    $xeImagePreview.renderVN = renderVN;
    return renderVN;
  }
});

// node_modules/vxe-pc-ui/es/image/src/util.js
var import_xe_utils53 = __toESM(require_xe_utils());
var openPreviewImage = (options) => {
  if (VxeUI.modal) {
    const opts = Object.assign({
      escClosable: true
    }, options);
    const { urlList, activeIndex, zIndex } = opts;
    const { rotate, change } = opts.events || {};
    const modalId = import_xe_utils53.default.uniqueId("image-preview");
    VxeUI.modal.open({
      id: modalId,
      title: "预览",
      width: "100%",
      height: "100%",
      showHeader: false,
      showFooter: false,
      padding: false,
      escClosable: opts.escClosable,
      zIndex,
      className: "vxe-image-preview-popup-wrapper",
      slots: {
        default() {
          return h(preview_default, {
            modelValue: activeIndex,
            urlList,
            urlField: opts.urlField,
            marginSize: opts.marginSize,
            maskClosable: opts.maskClosable,
            toolbarConfig: opts.toolbarConfig,
            showPrintButton: opts.showPrintButton,
            showDownloadButton: opts.showDownloadButton,
            beforeDownloadMethod: opts.beforeDownloadMethod,
            downloadMethod: opts.downloadMethod,
            onClose() {
              VxeUI.modal.close(modalId);
            },
            onChange(eventParams) {
              if (change) {
                change.call(this, eventParams);
              }
            },
            onRotate(eventParams) {
              if (rotate) {
                rotate.call(this, eventParams);
              }
            }
          });
        }
      }
    });
  }
  return Promise.resolve();
};

// node_modules/vxe-pc-ui/es/image/src/image.js
var image_default = defineVxeComponent({
  name: "VxeImage",
  props: {
    src: [String, Array],
    alt: [String, Number],
    loading: String,
    title: [String, Number],
    width: [String, Number],
    height: [String, Number],
    circle: Boolean,
    zIndex: Number,
    maskClosable: {
      type: Boolean,
      default: () => getConfig().image.maskClosable
    },
    toolbarConfig: Object,
    showPreview: {
      type: Boolean,
      default: () => getConfig().image.showPreview
    },
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().image.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().image.showDownloadButton
    },
    size: {
      type: String,
      default: () => getConfig().image.size || getConfig().size
    },
    getThumbnailUrlMethod: Function
  },
  emits: [
    "click",
    "change",
    "rotate"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils54.default.uniqueId();
    const $xeImageGroup = inject("$xeImageGroup", null);
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeImgStyle = computed(() => {
      const { width, height } = props;
      const style = {};
      if (width && height) {
        style.maxWidth = toCssUnit(width);
        style.maxHeight = toCssUnit(height);
      } else {
        if (width) {
          style.width = toCssUnit(width);
        }
        if (height) {
          style.height = toCssUnit(height);
        }
      }
      return style;
    });
    const computeImgList = computed(() => {
      const { src } = props;
      if (src) {
        return (import_xe_utils54.default.isArray(src) ? src : [src]).map((item) => {
          if (import_xe_utils54.default.isString(item)) {
            return {
              url: item,
              alt: ""
            };
          }
          return {
            url: item.url,
            alt: item.alt
          };
        });
      }
      return [];
    });
    const computeImgItem = computed(() => {
      const imgList = computeImgList.value;
      return imgList[0];
    });
    const computeImgUrl = computed(() => {
      const imgItem = computeImgItem.value;
      return imgItem ? `${imgItem.url || ""}` : "";
    });
    const computeImgThumbnailUrl = computed(() => {
      const getThumbnailUrlFn = props.getThumbnailUrlMethod || getConfig().image.getThumbnailUrlMethod;
      const imgUrl = computeImgUrl.value;
      return getThumbnailUrlFn ? getThumbnailUrlFn({ url: imgUrl, $image: $xeImage }) : "";
    });
    const computeMaps = {
      computeSize
    };
    const $xeImage = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const imageMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $image: $xeImage }, params));
      }
    };
    const clickEvent = (evnt) => {
      const { showPreview, toolbarConfig, showPrintButton, showDownloadButton, maskClosable, zIndex } = props;
      const imgList = computeImgList.value;
      const imgUrl = computeImgUrl.value;
      if ($xeImageGroup) {
        $xeImageGroup.handleClickImgEvent(evnt, { url: imgUrl });
      } else {
        if (showPreview && imgUrl) {
          openPreviewImage({
            urlList: imgList,
            toolbarConfig,
            showPrintButton,
            showDownloadButton,
            maskClosable,
            zIndex,
            events: {
              change(eventParams) {
                $xeImage.dispatchEvent("change", eventParams, eventParams.$event);
              },
              rotate(eventParams) {
                $xeImage.dispatchEvent("rotate", eventParams, eventParams.$event);
              }
            }
          });
        }
        $xeImage.dispatchEvent("click", { url: imgUrl }, evnt);
      }
    };
    const imagePrivateMethods = {};
    Object.assign($xeImage, imageMethods, imagePrivateMethods);
    const renderVN = () => {
      const { alt, loading: loading2, circle } = props;
      const imgStyle = computeImgStyle.value;
      const imgUrl = computeImgUrl.value;
      const imgThumbnailUrl = computeImgThumbnailUrl.value;
      const vSize = computeSize.value;
      return h("img", {
        ref: refElem,
        class: ["vxe-image", {
          [`size--${vSize}`]: vSize,
          "is--circle": circle
        }],
        src: imgThumbnailUrl || imgUrl,
        alt,
        loading: loading2,
        style: imgStyle,
        onClick: clickEvent
      });
    };
    $xeImage.renderVN = renderVN;
    return $xeImage;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/image/index.js
var VxeImage = Object.assign({}, image_default, {
  install(app) {
    app.component(image_default.name, image_default);
  }
});
dynamicApp.use(VxeImage);
VxeUI.component(image_default);
var Image2 = VxeImage;
var image_default2 = VxeImage;

// node_modules/vxe-pc-ui/es/image/src/group.js
var import_xe_utils55 = __toESM(require_xe_utils());
var group_default2 = defineVxeComponent({
  name: "VxeImageGroup",
  props: {
    urlList: [Array, String],
    showPreview: {
      type: Boolean,
      default: () => getConfig().imageGroup.showPreview
    },
    imageStyle: Object,
    zIndex: Number,
    size: {
      type: String,
      default: () => getConfig().imageGroup.size || getConfig().size
    },
    toolbarConfig: Object,
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().imageGroup.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().imageGroup.showDownloadButton
    },
    getThumbnailUrlMethod: Function
  },
  emits: [
    "click",
    "change",
    "rotate"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils55.default.uniqueId();
    const { computeSize } = useSize(props);
    const computeImgList = computed(() => {
      const { urlList } = props;
      if (urlList) {
        return (import_xe_utils55.default.isArray(urlList) ? urlList : [urlList]).map((item) => {
          if (import_xe_utils55.default.isString(item)) {
            return {
              url: item,
              alt: ""
            };
          }
          return {
            url: item.url,
            alt: item.alt
          };
        });
      }
      return [];
    });
    const computeImgStyleOpts = computed(() => {
      return Object.assign({}, getConfig().imageGroup.imageStyle, props.imageStyle);
    });
    const computeGetThumbnailUrlMethod = computed(() => {
      return props.getThumbnailUrlMethod || getConfig().imageGroup.getThumbnailUrlMethod;
    });
    const computeMaps = {
      computeSize
    };
    const $xeImageGroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    const imageGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $imageGroup: $xeImageGroup }, params));
      }
    };
    const imageGroupPrivateMethods = {
      handleClickImgEvent(evnt, params) {
        const { showPreview, toolbarConfig, showPrintButton, showDownloadButton, zIndex } = props;
        const { url } = params;
        const imgList = computeImgList.value;
        if (showPreview && url) {
          openPreviewImage({
            activeIndex: Math.max(0, import_xe_utils55.default.findIndexOf(imgList, (item) => item.url === url)),
            urlList: imgList,
            toolbarConfig,
            showPrintButton,
            showDownloadButton,
            zIndex,
            events: {
              change(eventParams) {
                $xeImageGroup.dispatchEvent("change", eventParams, eventParams.$event);
              },
              rotate(eventParams) {
                $xeImageGroup.dispatchEvent("rotate", eventParams, eventParams.$event);
              }
            }
          });
        }
        $xeImageGroup.dispatchEvent("click", { url, urlList: imgList }, evnt);
      }
    };
    Object.assign($xeImageGroup, imageGroupMethods, imageGroupPrivateMethods);
    const renderVN = () => {
      const imgList = computeImgList.value;
      const vSize = computeSize.value;
      const imgStyleOpts = computeImgStyleOpts.value;
      const getThumbnailUrlMethod = computeGetThumbnailUrlMethod.value;
      return h("div", {
        class: ["vxe-image-group", {
          [`size--${vSize}`]: vSize
        }]
      }, imgList ? imgList.map((item, index) => {
        return h(image_default, {
          key: index,
          src: item.url,
          alt: item.alt,
          width: imgStyleOpts.width,
          height: imgStyleOpts.height,
          getThumbnailUrlMethod
        });
      }) : []);
    };
    $xeImageGroup.renderVN = renderVN;
    provide("$xeImageGroup", $xeImageGroup);
    return $xeImageGroup;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/image-group/index.js
var VxeImageGroup = Object.assign({}, group_default2, {
  install(app) {
    app.component(group_default2.name, group_default2);
  }
});
dynamicApp.use(VxeImageGroup);
VxeUI.component(group_default2);
var ImageGroup = VxeImageGroup;
var image_group_default = VxeImageGroup;

// node_modules/vxe-pc-ui/es/image-preview/index.js
var VxeImagePreview = Object.assign(preview_default, {
  install(app) {
    app.component(preview_default.name, preview_default);
  }
});
VxeUI.previewImage = openPreviewImage;
dynamicApp.use(VxeImagePreview);
VxeUI.component(preview_default);
var ImagePreview = VxeImagePreview;
var image_preview_default = VxeImagePreview;

// node_modules/vxe-pc-ui/es/input/index.js
var VxeInput = Object.assign(input_default, {
  install(app) {
    app.component(input_default.name, input_default);
  }
});
dynamicApp.use(VxeInput);
VxeUI.component(input_default);
var Input = VxeInput;
var input_default2 = VxeInput;

// node_modules/vxe-pc-ui/es/layout-aside/src/layout-aside.js
var import_xe_utils56 = __toESM(require_xe_utils());
var layout_aside_default = defineVxeComponent({
  name: "VxeLayoutAside",
  props: {
    width: [String, Number],
    collapsed: Boolean,
    collapseWidth: [String, Number],
    loading: Boolean,
    padding: Boolean,
    size: {
      type: String,
      default: () => getConfig().layoutAside.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils56.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeWrapperWidth = computed(() => {
      const { width, collapsed, collapseWidth } = props;
      if (collapsed) {
        if (collapseWidth) {
          return toCssUnit(collapseWidth);
        }
      } else {
        if (width) {
          return toCssUnit(width);
        }
      }
      return "";
    });
    const computeMaps = {
      computeSize
    };
    const $xeLayoutAside = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutAside: $xeLayoutAside }, params));
    };
    const layoutAsideMethods = {
      dispatchEvent
    };
    const layoutAsidePrivateMethods = {};
    Object.assign($xeLayoutAside, layoutAsideMethods, layoutAsidePrivateMethods);
    const renderVN = () => {
      const { width, collapsed, loading: loading2, padding } = props;
      const wrapperWidth = computeWrapperWidth.value;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      return h("aside", {
        ref: refElem,
        class: ["vxe-layout-aside", {
          [`size--${vSize}`]: vSize,
          "is--padding": padding,
          "is--default-width": !width,
          "is--collapse": collapsed,
          "is--loading": loading2
        }],
        style: wrapperWidth ? {
          width: wrapperWidth
        } : null
      }, [
        h("div", {
          class: "vxe-layout-aside--inner"
        }, defaultSlot ? defaultSlot({}) : []),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    provide("$xeLayoutAside", $xeLayoutAside);
    $xeLayoutAside.renderVN = renderVN;
    return $xeLayoutAside;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/layout-aside/index.js
var VxeLayoutAside = Object.assign({}, layout_aside_default, {
  install(app) {
    app.component(layout_aside_default.name, layout_aside_default);
  }
});
dynamicApp.use(VxeLayoutAside);
VxeUI.component(layout_aside_default);
var LayoutAside = VxeLayoutAside;
var layout_aside_default2 = VxeLayoutAside;

// node_modules/vxe-pc-ui/es/layout-body/src/layout-body.js
var import_xe_utils57 = __toESM(require_xe_utils());
var layout_body_default = defineVxeComponent({
  name: "VxeLayoutBody",
  props: {
    loading: Boolean,
    padding: Boolean,
    size: {
      type: String,
      default: () => getConfig().layoutBody.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils57.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeLayoutBody = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutBody: $xeLayoutBody }, params));
    };
    const layoutBodyMethods = {
      dispatchEvent
    };
    const layoutBodyPrivateMethods = {};
    Object.assign($xeLayoutBody, layoutBodyMethods, layoutBodyPrivateMethods);
    const renderVN = () => {
      const { loading: loading2, padding } = props;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-layout-body", {
          [`size--${vSize}`]: vSize,
          "is--loading": loading2,
          "is--padding": padding
        }]
      }, [
        h("div", {
          class: "vxe-layout-body--inner"
        }, defaultSlot ? defaultSlot({}) : []),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    $xeLayoutBody.renderVN = renderVN;
    return $xeLayoutBody;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/layout-body/index.js
var VxeLayoutBody = Object.assign({}, layout_body_default, {
  install(app) {
    app.component(layout_body_default.name, layout_body_default);
  }
});
dynamicApp.use(VxeLayoutBody);
VxeUI.component(layout_body_default);
var LayoutBody = VxeLayoutBody;
var layout_body_default2 = VxeLayoutBody;

// node_modules/vxe-pc-ui/es/layout-container/src/layout-container.js
var import_xe_utils58 = __toESM(require_xe_utils());
var layout_container_default = defineVxeComponent({
  name: "VxeLayoutContainer",
  props: {
    vertical: Boolean,
    size: {
      type: String,
      default: () => getConfig().layoutContainer.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils58.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeLayoutContainer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutContainer: $xeLayoutContainer }, params));
    };
    const layoutContainerMethods = {
      dispatchEvent
    };
    const layoutContainerPrivateMethods = {};
    Object.assign($xeLayoutContainer, layoutContainerMethods, layoutContainerPrivateMethods);
    const renderVN = () => {
      const { vertical } = props;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-layout-container", {
          [`size--${vSize}`]: vSize,
          "is--vertical": vertical
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutContainer.renderVN = renderVN;
    return $xeLayoutContainer;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/layout-container/index.js
var VxeLayoutContainer = Object.assign({}, layout_container_default, {
  install(app) {
    app.component(layout_container_default.name, layout_container_default);
  }
});
dynamicApp.use(VxeLayoutContainer);
VxeUI.component(layout_container_default);
var LayoutContainer = VxeLayoutContainer;
var layout_container_default2 = VxeLayoutContainer;

// node_modules/vxe-pc-ui/es/layout-footer/src/layout-footer.js
var import_xe_utils59 = __toESM(require_xe_utils());
var layout_footer_default = defineVxeComponent({
  name: "VxeLayoutFooter",
  props: {
    fixed: Boolean,
    align: String
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils59.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutFooter = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutFooter: $xeLayoutFooter }, params));
    };
    const layoutFooterMethods = {
      dispatchEvent
    };
    const layoutFooterPrivateMethods = {};
    Object.assign($xeLayoutFooter, layoutFooterMethods, layoutFooterPrivateMethods);
    const renderVN = () => {
      const { fixed, align } = props;
      const defaultSlot = slots.default;
      return h("footer", {
        ref: refElem,
        class: ["vxe-layout-footer", align ? `align--${align}` : "", {
          "is--fixed": fixed
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutFooter.renderVN = renderVN;
    return $xeLayoutFooter;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/layout-footer/index.js
var VxeLayoutFooter = Object.assign({}, layout_footer_default, {
  install(app) {
    app.component(layout_footer_default.name, layout_footer_default);
  }
});
dynamicApp.use(VxeLayoutFooter);
VxeUI.component(layout_footer_default);
var LayoutFooter = VxeLayoutFooter;
var layout_footer_default2 = VxeLayoutFooter;

// node_modules/vxe-pc-ui/es/layout-header/src/layout-header.js
var import_xe_utils60 = __toESM(require_xe_utils());
var layout_header_default = defineVxeComponent({
  name: "VxeLayoutHeader",
  props: {
    fixed: Boolean
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils60.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutHeader = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutHeader: $xeLayoutHeader }, params));
    };
    const layoutHeaderMethods = {
      dispatchEvent
    };
    const layoutHeaderPrivateMethods = {};
    Object.assign($xeLayoutHeader, layoutHeaderMethods, layoutHeaderPrivateMethods);
    const renderVN = () => {
      const { fixed } = props;
      const defaultSlot = slots.default;
      return h("header", {
        ref: refElem,
        class: ["vxe-layout-header", {
          "is--fixed": fixed
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutHeader.renderVN = renderVN;
    return $xeLayoutHeader;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/layout-header/index.js
var VxeLayoutHeader = Object.assign({}, layout_header_default, {
  install(app) {
    app.component(layout_header_default.name, layout_header_default);
  }
});
dynamicApp.use(VxeLayoutHeader);
VxeUI.component(layout_header_default);
var LayoutHeader = VxeLayoutHeader;
var layout_header_default2 = VxeLayoutHeader;

// node_modules/vxe-pc-ui/es/link/src/link.js
var import_xe_utils61 = __toESM(require_xe_utils());
var link_default = defineVxeComponent({
  name: "VxeLink",
  props: {
    href: String,
    target: String,
    status: String,
    title: [String, Number],
    disabled: Boolean,
    icon: String,
    routerLink: Object,
    underline: {
      type: Boolean,
      default: () => getConfig().link.underline
    },
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    content: [String, Number],
    size: {
      type: String,
      default: () => getConfig().link.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils61.default.uniqueId();
    const { computeSize } = useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLink = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $link: $xeLink }, params));
    };
    const linkMethods = {
      dispatchEvent
    };
    const linkPrivateMethods = {};
    const clickEvent = (evnt) => {
      const { disabled } = props;
      if (!disabled) {
        dispatchEvent("click", {}, evnt);
      }
    };
    Object.assign($xeLink, linkMethods, linkPrivateMethods);
    const renderContent = () => {
      const { icon, content } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      const textContent = import_xe_utils61.default.toValueString(content);
      return [
        iconSlot || icon ? h("span", {
          class: "vxe-link--icon"
        }, iconSlot ? getSlotVNs2(iconSlot({})) : [
          h("i", {
            class: icon
          })
        ]) : renderEmptyElement($xeLink),
        defaultSlot || textContent ? h("span", {
          class: "vxe-link--content"
        }, defaultSlot ? defaultSlot({}) : textContent) : renderEmptyElement($xeLink)
      ];
    };
    const renderVN = () => {
      const { status, target, href, title, underline, disabled, routerLink } = props;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      if (!permissionInfo.visible) {
        return renderEmptyElement($xeLink);
      }
      if (routerLink && !disabled) {
        return h(resolveComponent("router-link"), {
          class: ["vxe-link", {
            [`size--${vSize}`]: vSize,
            [`theme--${status}`]: status,
            "is--disabled": disabled,
            "is--underline": underline
          }],
          title,
          target,
          to: disabled ? null : routerLink,
          onClick: clickEvent
        }, {
          default() {
            return renderContent();
          }
        });
      }
      return h("a", {
        ref: refElem,
        class: ["vxe-link", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--disabled": disabled,
          "is--underline": underline
        }],
        href: disabled ? null : href,
        target,
        title,
        onClick: clickEvent
      }, renderContent());
    };
    $xeLink.renderVN = renderVN;
    return $xeLink;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/link/index.js
var VxeLink = Object.assign({}, link_default, {
  install(app) {
    app.component(link_default.name, link_default);
  }
});
dynamicApp.use(VxeLink);
VxeUI.component(link_default);
var Link = VxeLink;
var link_default2 = VxeLink;

// node_modules/vxe-pc-ui/es/list/src/list.js
var import_xe_utils62 = __toESM(require_xe_utils());
function createInternalData2() {
  return {
    resizeObserver: void 0,
    fullData: [],
    lastScrollLeft: 0,
    lastScrollTop: 0,
    scrollYStore: {
      startIndex: 0,
      endIndex: 0,
      visibleSize: 0,
      offsetSize: 0,
      rowHeight: 0
    }
  };
}
var list_default = defineVxeComponent({
  name: "VxeList",
  props: {
    data: Array,
    height: [Number, String],
    maxHeight: [Number, String],
    loading: Boolean,
    className: [String, Function],
    size: {
      type: String,
      default: () => getConfig().list.size || getConfig().size
    },
    autoResize: {
      type: Boolean,
      default: () => getConfig().list.autoResize
    },
    syncResize: [Boolean, String, Number],
    virtualYConfig: Object,
    scrollY: Object
  },
  emits: [
    "scroll"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils62.default.uniqueId();
    const browseObj2 = import_xe_utils62.default.browse();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      scrollYLoad: false,
      bodyHeight: 0,
      customHeight: 0,
      customMaxHeight: 0,
      parentHeight: 0,
      topSpaceHeight: 0,
      items: []
    });
    const internalData = createInternalData2();
    const refElem = ref();
    const refVirtualWrapper = ref();
    const refVirtualBody = ref();
    const refMaps = {
      refElem
    };
    const $xeList = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeSYOpts = computed(() => {
      return Object.assign({}, getConfig().list.virtualYConfig || getConfig().list.scrollY, props.virtualYConfig || props.scrollY);
    });
    const computeStyles = computed(() => {
      const { height, maxHeight } = props;
      const { customHeight, customMaxHeight } = reactData;
      const style = {};
      if (height) {
        style.height = `${customHeight}px`;
      } else if (maxHeight) {
        style.height = "auto";
        style.maxHeight = `${customMaxHeight}px`;
      }
      return style;
    });
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $list: $xeList }, params));
    };
    const calcTableHeight = (key) => {
      const { parentHeight } = reactData;
      const val = props[key];
      let num = 0;
      if (val) {
        if (val === "100%" || val === "auto") {
          num = parentHeight;
        } else {
          if (isScale(val)) {
            num = Math.floor((import_xe_utils62.default.toInteger(val) || 1) / 100 * parentHeight);
          } else {
            num = import_xe_utils62.default.toNumber(val);
          }
          num = Math.max(40, num);
        }
      }
      return num;
    };
    const updateHeight = () => {
      reactData.customHeight = calcTableHeight("height");
      reactData.customMaxHeight = calcTableHeight("maxHeight");
    };
    const updateYSpace = () => {
      const { scrollYLoad } = reactData;
      const { scrollYStore, fullData } = internalData;
      reactData.bodyHeight = scrollYLoad ? fullData.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const handleData = () => {
      const { scrollYLoad } = reactData;
      const { fullData, scrollYStore } = internalData;
      reactData.items = scrollYLoad ? fullData.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullData.slice(0);
      return nextTick();
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return nextTick().then(() => {
        const { scrollYLoad } = reactData;
        const { scrollYStore } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const sYOpts = computeSYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (sYOpts.sItem) {
            firstItemElem = virtualBodyElem.querySelector(sYOpts.sItem);
          }
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(12, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, Math.ceil(scrollBodyElem.clientHeight / rowHeight));
          const offsetYSize = sYOpts.oSize ? import_xe_utils62.default.toNumber(sYOpts.oSize) : browseObj2.edge ? 10 : 0;
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex + visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
      });
    };
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
      }
      return nextTick();
    };
    const scrollTo2 = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollLeft) {
        if (!import_xe_utils62.default.isNumber(scrollLeft)) {
          scrollTop = scrollLeft.top;
          scrollLeft = scrollLeft.left;
        }
      }
      if (import_xe_utils62.default.isNumber(scrollLeft)) {
        scrollBodyElem.scrollLeft = scrollLeft;
      }
      if (import_xe_utils62.default.isNumber(scrollTop)) {
        scrollBodyElem.scrollTop = scrollTop;
      }
      if (reactData.scrollYLoad) {
        return new Promise((resolve) => {
          setTimeout(() => {
            nextTick(() => {
              resolve();
            });
          }, 50);
        });
      }
      return nextTick();
    };
    const refreshScroll = () => {
      const { lastScrollLeft, lastScrollTop } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo2(lastScrollLeft, lastScrollTop);
        }
      });
    };
    const recalculate = () => {
      const el = refElem.value;
      if (el) {
        const parentEl = el.parentElement;
        reactData.parentHeight = parentEl ? parentEl.clientHeight : 0;
        updateHeight();
        if (el.clientWidth && el.clientHeight) {
          return computeScrollLoad();
        }
      }
      return nextTick();
    };
    const loadYData = (evnt) => {
      const { scrollYStore } = internalData;
      const { startIndex, endIndex, visibleSize, offsetSize, rowHeight } = scrollYStore;
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    const scrollEvent = (evnt) => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData(evnt);
      }
      dispatchEvent("scroll", { scrollLeft, scrollTop, isX, isY }, evnt);
    };
    const loadData = (datas) => {
      const { scrollYStore } = internalData;
      const sYOpts = computeSYOpts.value;
      const fullData = datas || [];
      Object.assign(scrollYStore, {
        startIndex: 0,
        endIndex: 1,
        visibleSize: 0
      });
      internalData.fullData = fullData;
      reactData.scrollYLoad = !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt <= fullData.length);
      handleData();
      return computeScrollLoad().then(() => {
        refreshScroll();
      });
    };
    const listMethods = {
      dispatchEvent,
      loadData,
      /**
       * 重新加载数据
       * @param {Array} datas 数据
       */
      reloadData(datas) {
        clearScroll();
        return loadData(datas);
      },
      recalculate,
      scrollTo: scrollTo2,
      refreshScroll,
      clearScroll
    };
    Object.assign($xeList, listMethods);
    const renderVN = () => {
      const { className, loading: loading2 } = props;
      const { bodyHeight, topSpaceHeight, items } = reactData;
      const defaultSlot = slots.default;
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-list", className ? import_xe_utils62.default.isFunction(className) ? className({ $list: $xeList }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--loading": loading2
        }]
      }, [
        h("div", {
          ref: refVirtualWrapper,
          class: "vxe-list--virtual-wrapper",
          style: styles,
          onScroll: scrollEvent
        }, [
          h("div", {
            class: "vxe-list--y-space",
            style: {
              height: bodyHeight ? `${bodyHeight}px` : ""
            }
          }),
          h("div", {
            ref: refVirtualBody,
            class: "vxe-list--body",
            style: {
              marginTop: topSpaceHeight ? `${topSpaceHeight}px` : ""
            }
          }, defaultSlot ? defaultSlot({ items, $list: $xeList }) : [])
        ]),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-list--loading",
          modelValue: loading2
        })
      ]);
    };
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      loadData(props.data || []);
    });
    watch(() => props.height, () => {
      recalculate();
    });
    watch(() => props.maxHeight, () => {
      recalculate();
    });
    watch(() => props.syncResize, (value) => {
      if (value) {
        recalculate();
        nextTick(() => setTimeout(() => recalculate()));
      }
    });
    onActivated(() => {
      recalculate().then(() => refreshScroll());
    });
    nextTick(() => {
      loadData(props.data || []);
    });
    onMounted(() => {
      recalculate();
      if (props.autoResize) {
        const el = refElem.value;
        const resizeObserver = globalResize.create(() => recalculate());
        resizeObserver.observe(el);
        if (el) {
          resizeObserver.observe(el.parentElement);
        }
        internalData.resizeObserver = resizeObserver;
      }
      globalEvents.on($xeList, "resize", recalculate);
    });
    onUnmounted(() => {
      const { resizeObserver } = internalData;
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      globalEvents.off($xeList, "resize");
      import_xe_utils62.default.assign(internalData, createInternalData2());
    });
    $xeList.renderVN = renderVN;
    return $xeList;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/list/index.js
var VxeList = Object.assign(list_default, {
  install(app) {
    app.component(list_default.name, list_default);
  }
});
dynamicApp.use(VxeList);
VxeUI.component(list_default);
var List = VxeList;
var list_default2 = VxeList;

// node_modules/vxe-pc-ui/es/menu/src/menu.js
var import_xe_utils63 = __toESM(require_xe_utils());
var menu_default = defineVxeComponent({
  name: "VxeMenu",
  props: {
    modelValue: [String, Number],
    expandAll: Boolean,
    accordion: {
      type: Boolean,
      default: () => getConfig().menu.accordion
    },
    collapsed: {
      type: Boolean,
      default: null
    },
    collapseFixed: Boolean,
    loading: Boolean,
    options: {
      type: Array,
      default: () => []
    },
    size: {
      type: String,
      default: () => getConfig().menu.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils63.default.uniqueId();
    const $xeLayoutAside = inject("$xeLayoutAside", null);
    const refElem = ref();
    const refCollapseElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: !!props.collapsed,
      isEnterCollapse: false,
      collapseStyle: {},
      collapseZindex: 0,
      activeName: props.modelValue,
      menuList: [],
      itemHeight: 1
    });
    const refMaps = {
      refElem
    };
    const computeIsCollapsed = computed(() => {
      const { collapsed } = props;
      if (import_xe_utils63.default.isBoolean(collapsed)) {
        return collapsed;
      }
      if ($xeLayoutAside) {
        return !!$xeLayoutAside.props.collapsed;
      }
      return false;
    });
    const computeCollapseWidth = computed(() => {
      let collapseWidth = "";
      if ($xeLayoutAside) {
        collapseWidth = $xeLayoutAside.props.collapseWidth || "";
      }
      return collapseWidth;
    });
    const computeCollapseEnterWidth = computed(() => {
      let width = "";
      if ($xeLayoutAside) {
        width = $xeLayoutAside.props.width || "";
      }
      return width;
    });
    const computeMaps = {
      computeSize
    };
    const $xeMenu = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getMenuTitle = (item) => {
      return `${item.title || item.name}`;
    };
    const updateZindex = () => {
      if (reactData.collapseZindex < getLastZIndex()) {
        reactData.collapseZindex = nextZIndex();
      }
    };
    const updateActiveMenu = (isDefExpand) => {
      const { activeName } = reactData;
      import_xe_utils63.default.eachTree(reactData.menuList, (item, index, items, path, parent2, nodes) => {
        if (item.itemKey === activeName) {
          nodes.forEach((obj) => {
            obj.isActive = true;
            if (isDefExpand) {
              obj.isExpand = true;
            }
          });
          item.isExactActive = true;
        } else {
          item.isExactActive = false;
          item.isActive = false;
        }
      }, { children: "childList" });
    };
    const updateMenuConfig = () => {
      const { options, expandAll } = props;
      reactData.menuList = import_xe_utils63.default.mapTree(options, (item, index, items, path, parent2) => {
        const objItem = Object.assign(Object.assign({}, item), { parentKey: parent2 ? parent2.name || path.slice(0, path.length - 1).join(",") : "", level: path.length, itemKey: item.name || path.join(","), isExactActive: false, isActive: false, isExpand: import_xe_utils63.default.isBoolean(item.expanded) ? item.expanded : !!expandAll, hasChild: item.children && item.children.length > 0 });
        return objItem;
      }, { children: "children", mapChildren: "childList" });
    };
    const updateCollapseStyle = () => {
      const { collapseFixed } = props;
      if (collapseFixed) {
        nextTick(() => {
          const { isEnterCollapse } = reactData;
          const isCollapsed = computeIsCollapsed.value;
          const collapseEnterWidth = computeCollapseEnterWidth.value;
          const collapseWidth = computeCollapseWidth.value;
          const el = refElem.value;
          if (el) {
            const clientRect = el.getBoundingClientRect();
            const parentNode = el.parentNode;
            reactData.collapseStyle = isCollapsed ? {
              top: toCssUnit(clientRect.top),
              left: toCssUnit(clientRect.left),
              height: toCssUnit(parentNode.clientHeight),
              width: isEnterCollapse ? collapseEnterWidth ? toCssUnit(collapseEnterWidth) : "" : collapseWidth ? toCssUnit(collapseWidth) : "",
              zIndex: reactData.collapseZindex
            } : {};
          }
        });
      }
    };
    const handleCollapseMenu = () => {
      const { collapseFixed } = props;
      if (collapseFixed) {
        const { initialized } = reactData;
        const isCollapsed = computeIsCollapsed.value;
        if (isCollapsed) {
          if (!initialized) {
            reactData.initialized = true;
            nextTick(() => {
              const collapseEl = refCollapseElem.value;
              if (collapseEl) {
                document.body.appendChild(collapseEl);
              }
            });
          }
        }
        reactData.isEnterCollapse = false;
        updateZindex();
        updateCollapseStyle();
      }
    };
    const handleClickIconCollapse = (evnt, item, itemList) => {
      const { accordion } = props;
      const { hasChild, isExpand } = item;
      if (hasChild) {
        evnt.stopPropagation();
        evnt.preventDefault();
        if (accordion) {
          itemList.forEach((obj) => {
            if (obj !== item) {
              obj.isExpand = false;
            }
          });
        }
        item.isExpand = !isExpand;
      }
    };
    const emitModel = (value) => {
      reactData.activeName = value;
      emit("update:modelValue", value);
    };
    const handleClickMenu = (evnt, item, itemList) => {
      const { itemKey, routerLink, hasChild } = item;
      if (routerLink) {
        emitModel(itemKey);
        handleMenuMouseleave();
      } else {
        if (hasChild) {
          handleClickIconCollapse(evnt, item, itemList);
        } else {
          emitModel(itemKey);
          handleMenuMouseleave();
        }
      }
      dispatchEvent("click", { menu: item }, evnt);
    };
    const handleMenuMouseenter = () => {
      const { collapseStyle } = reactData;
      const collapseEnterWidth = computeCollapseEnterWidth.value;
      reactData.collapseStyle = Object.assign({}, collapseStyle, {
        width: collapseEnterWidth ? toCssUnit(collapseEnterWidth) : ""
      });
      reactData.isEnterCollapse = true;
    };
    const handleMenuMouseover = () => {
      const { isEnterCollapse } = reactData;
      if (!isEnterCollapse) {
        handleMenuMouseenter();
      }
    };
    const handleMenuMouseleave = () => {
      const { collapseStyle } = reactData;
      const el = refElem.value;
      reactData.collapseStyle = Object.assign({}, collapseStyle, {
        width: el ? toCssUnit(el.offsetWidth) : ""
      });
      reactData.isEnterCollapse = false;
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils63.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils63.default.isFunction(slotFunc)) {
          return getSlotVNs2(slotFunc(params));
        }
      }
      return [];
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $menu: $xeMenu }, params));
    };
    const menuMethods = {
      dispatchEvent
    };
    const menuPrivateMethods = {};
    Object.assign($xeMenu, menuMethods, menuPrivateMethods);
    const renderMenuTitle = (item, itemList) => {
      const { icon, isExpand, hasChild } = item;
      const itemSlots = item.slots || {};
      const optionSlot = itemSlots.default || slots.option;
      const titleSlot = itemSlots.title || slots.optionTitle || slots["option-title"];
      const iconSlot = itemSlots.icon || slots.optionIcon || slots["option-icon"];
      const title = getMenuTitle(item);
      const isCollapsed = computeIsCollapsed.value;
      const params = {
        option: item,
        collapsed: isCollapsed
      };
      return [
        optionSlot ? renderEmptyElement($xeMenu) : h("div", {
          class: "vxe-menu--item-link-icon"
        }, iconSlot ? callSlot(iconSlot, params) : icon ? [h("i", {
          class: icon
        })] : []),
        optionSlot ? h("div", {
          class: "vxe-menu--item-custom-title"
        }, callSlot(optionSlot, params)) : h("div", {
          class: "vxe-menu--item-link-title",
          title
        }, titleSlot ? callSlot(titleSlot, params) : title),
        hasChild ? h("div", {
          class: "vxe-menu--item-link-collapse",
          onClick(evnt) {
            handleClickIconCollapse(evnt, item, itemList);
          }
        }, [
          h("i", {
            class: isExpand ? getIcon().MENU_ITEM_EXPAND_OPEN : getIcon().MENU_ITEM_EXPAND_CLOSE
          })
        ]) : renderEmptyElement($xeMenu)
      ];
    };
    const renderDefaultChildren = (item, itemList) => {
      const { itemKey, level, hasChild, isActive, isExactActive, isExpand, routerLink, childList } = item;
      const { isEnterCollapse } = reactData;
      const isCollapsed = computeIsCollapsed.value;
      if (item.permissionCode) {
        if (!permission.checkVisible(item.permissionCode)) {
          return renderEmptyElement($xeMenu);
        }
      }
      return h("div", {
        key: itemKey,
        class: ["vxe-menu--item-wrapper", `vxe-menu--item-level${level}`, {
          "is--exact-active": isExactActive,
          "is--active": isActive,
          "is--expand": (!isCollapsed || isEnterCollapse) && isExpand
        }]
      }, [
        routerLink ? h(resolveComponent("router-link"), {
          class: "vxe-menu--item-link",
          to: routerLink,
          onClick(evnt) {
            handleClickMenu(evnt, item, itemList);
          }
        }, {
          default: () => renderMenuTitle(item, itemList)
        }) : h("div", {
          class: "vxe-menu--item-link",
          onClick(evnt) {
            handleClickMenu(evnt, item, itemList);
          }
        }, renderMenuTitle(item, itemList)),
        hasChild ? h("div", {
          class: "vxe-menu--item-group"
        }, childList.map((child) => renderDefaultChildren(child, childList))) : renderEmptyElement($xeMenu)
      ]);
    };
    const renderCollapseChildren = (item, itemList) => {
      const { itemKey, level, hasChild, isActive, isExactActive, routerLink, childList } = item;
      if (item.permissionCode) {
        if (!permission.checkVisible(item.permissionCode)) {
          return renderEmptyElement($xeMenu);
        }
      }
      return h("div", {
        key: itemKey,
        class: ["vxe-menu--item-wrapper", `vxe-menu--item-level${level}`, {
          "is--exact-active": isExactActive,
          "is--active": isActive
        }]
      }, [
        routerLink ? h(resolveComponent("router-link"), {
          class: "vxe-menu--item-link",
          to: routerLink,
          onClick(evnt) {
            handleClickMenu(evnt, item, itemList);
          }
        }, {
          default: () => renderMenuTitle(item, itemList)
        }) : h("div", {
          class: "vxe-menu--item-link",
          onClick(evnt) {
            handleClickMenu(evnt, item, itemList);
          }
        }, renderMenuTitle(item, itemList)),
        hasChild ? h("div", {
          class: "vxe-menu--item-group"
        }, childList.map((child) => renderDefaultChildren(child, childList))) : renderEmptyElement($xeMenu)
      ]);
    };
    const renderVN = () => {
      const { loading: loading2, collapseFixed } = props;
      const { initialized, menuList, collapseStyle, isEnterCollapse } = reactData;
      const vSize = computeSize.value;
      const isCollapsed = computeIsCollapsed.value;
      let ons = {};
      if (collapseFixed) {
        ons = {
          onMouseenter: handleMenuMouseenter,
          onMouseover: handleMenuMouseover,
          onMouseleave: handleMenuMouseleave
        };
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-menu", {
          [`size--${vSize}`]: vSize,
          "is--collapsed": isCollapsed,
          "is--loading": loading2
        }]
      }, [
        h("div", {
          class: "vxe-menu--item-list"
        }, menuList.map((child) => isCollapsed ? renderCollapseChildren(child, menuList) : renderDefaultChildren(child, menuList))),
        initialized ? h("div", Object.assign({ ref: refCollapseElem, class: ["vxe-menu--collapse-wrapper", {
          [`size--${vSize}`]: vSize,
          "is--collapsed": isCollapsed,
          "is--enter": isEnterCollapse,
          "is--loading": loading2
        }], style: collapseStyle }, ons), [
          isCollapsed ? h("div", {
            class: "vxe-menu--item-list"
          }, menuList.map((child) => renderDefaultChildren(child, menuList))) : renderEmptyElement($xeMenu)
        ]) : renderEmptyElement($xeMenu),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    const optFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optFlag.value++;
    });
    watch(() => props.options, () => {
      optFlag.value++;
    });
    watch(optFlag, () => {
      updateMenuConfig();
      updateActiveMenu(true);
    });
    watch(() => props.modelValue, (val) => {
      reactData.activeName = val;
    });
    watch(() => reactData.activeName, () => {
      updateActiveMenu(true);
    });
    watch(computeIsCollapsed, () => {
      handleCollapseMenu();
    });
    onMounted(() => {
      globalEvents.on($xeMenu, "resize", updateCollapseStyle);
      updateCollapseStyle();
    });
    onBeforeUnmount(() => {
      globalEvents.off($xeMenu, "resize");
      const collapseEl = refCollapseElem.value;
      if (collapseEl) {
        const parentNode = collapseEl.parentNode;
        if (parentNode) {
          parentNode.removeChild(collapseEl);
        }
      }
    });
    updateMenuConfig();
    updateActiveMenu(true);
    $xeMenu.renderVN = renderVN;
    return $xeMenu;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/menu/index.js
var VxeMenu = Object.assign({}, menu_default, {
  install(app) {
    app.component(menu_default.name, menu_default);
  }
});
dynamicApp.use(VxeMenu);
VxeUI.component(menu_default);
var Menu = VxeMenu;
var menu_default2 = VxeMenu;

// node_modules/vxe-pc-ui/es/modal/index.js
var import_xe_utils65 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/modal/src/modal.js
var import_xe_utils64 = __toESM(require_xe_utils());
var allActiveModals = [];
var msgQueue = [];
var notifyQueue = [];
var lockScrollAttrKey = "data-vxe-lock-scroll";
var lockScrollCssWidthKey = "--vxe-ui-modal-lock-scroll-view-width";
var modal_default = defineVxeComponent({
  name: "VxeModal",
  props: {
    modelValue: Boolean,
    id: String,
    type: {
      type: String,
      default: "modal"
    },
    loading: {
      type: Boolean,
      default: null
    },
    status: String,
    iconStatus: String,
    className: String,
    top: {
      type: [Number, String],
      default: () => getConfig().modal.top
    },
    position: [String, Object],
    title: String,
    duration: {
      type: [Number, String],
      default: () => getConfig().modal.duration
    },
    content: [Number, String],
    showCancelButton: {
      type: Boolean,
      default: null
    },
    cancelButtonText: {
      type: String,
      default: () => getConfig().modal.cancelButtonText
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().modal.showConfirmButton
    },
    confirmButtonText: {
      type: String,
      default: () => getConfig().modal.confirmButtonText
    },
    lockView: {
      type: Boolean,
      default: () => getConfig().modal.lockView
    },
    lockScroll: Boolean,
    mask: {
      type: Boolean,
      default: () => getConfig().modal.mask
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().modal.maskClosable
    },
    escClosable: {
      type: Boolean,
      default: () => getConfig().modal.escClosable
    },
    cancelClosable: {
      type: Boolean,
      default: () => getConfig().modal.cancelClosable
    },
    confirmClosable: {
      type: Boolean,
      default: () => getConfig().modal.confirmClosable
    },
    resize: Boolean,
    showHeader: {
      type: Boolean,
      default: () => getConfig().modal.showHeader
    },
    showFooter: {
      type: Boolean,
      default: () => getConfig().modal.showFooter
    },
    showZoom: Boolean,
    zoomConfig: Object,
    showMaximize: {
      type: Boolean,
      default: () => handleBooleanDefaultValue(getConfig().modal.showMaximize)
    },
    showMinimize: {
      type: Boolean,
      default: () => handleBooleanDefaultValue(getConfig().modal.showMinimize)
    },
    showClose: {
      type: Boolean,
      default: () => getConfig().modal.showClose
    },
    dblclickZoom: {
      type: Boolean,
      default: () => getConfig().modal.dblclickZoom
    },
    width: [Number, String],
    height: [Number, String],
    minWidth: {
      type: [Number, String],
      default: () => getConfig().modal.minWidth
    },
    minHeight: {
      type: [Number, String],
      default: () => getConfig().modal.minHeight
    },
    zIndex: Number,
    marginSize: {
      type: [Number, String],
      default: () => getConfig().modal.marginSize
    },
    fullscreen: Boolean,
    draggable: {
      type: Boolean,
      default: () => getConfig().modal.draggable
    },
    remember: {
      type: Boolean,
      default: () => getConfig().modal.remember
    },
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().modal.destroyOnClose
    },
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().modal.showTitleOverflow
    },
    transfer: {
      type: Boolean,
      default: () => getConfig().modal.transfer
    },
    storage: {
      type: Boolean,
      default: () => getConfig().modal.storage
    },
    storageKey: {
      type: String,
      default: () => getConfig().modal.storageKey
    },
    padding: {
      type: Boolean,
      default: () => getConfig().modal.padding
    },
    size: {
      type: String,
      default: () => getConfig().modal.size || getConfig().size
    },
    beforeHideMethod: Function,
    slots: Object,
    /**
     * 已废弃
     * @deprecated
     */
    message: [Number, String],
    /**
     * 已废弃
     * @deprecated
     */
    animat: {
      type: Boolean,
      default: () => getConfig().modal.animat
    }
  },
  emits: [
    "update:modelValue",
    "show",
    "hide",
    "before-hide",
    "close",
    "confirm",
    "cancel",
    "zoom",
    "resize",
    "move"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils64.default.uniqueId();
    const $xeParentModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      visible: false,
      contentVisible: false,
      modalTop: 0,
      modalZindex: 0,
      prevZoomStatus: "",
      zoomStatus: "",
      revertLocat: null,
      prevLocat: null,
      firstOpen: true,
      resizeFlag: 1
    });
    const internalData = {
      msgTimeout: void 0
    };
    const refElem = ref();
    const refModalBox = ref();
    const refHeaderElem = ref();
    const refConfirmBtn = ref();
    const refCancelBtn = ref();
    const refMaps = {
      refElem
    };
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().modal.transfer;
        if (import_xe_utils64.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeParentModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeIsMsg = computed(() => {
      return props.type === "message" || props.type === "notification";
    });
    const computeIsMinimizeStatus = computed(() => {
      return reactData.zoomStatus === "minimize";
    });
    const computeIsMaximizeStatus = computed(() => {
      return reactData.zoomStatus === "maximize";
    });
    const computeZoomOpts = computed(() => {
      return Object.assign({}, getConfig().modal.zoomConfig, props.zoomConfig);
    });
    const computeMaps = {
      computeSize,
      computeZoomOpts
    };
    const $xeModal = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    let modalMethods = {};
    const getBox = () => {
      const boxElem = refModalBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const { width, height } = props;
      const boxElem = getBox();
      if (boxElem) {
        boxElem.style.width = width ? toCssUnit(width) : "";
        boxElem.style.height = height ? toCssUnit(height) : "";
      }
      return nextTick();
    };
    const updateZindex = () => {
      const { zIndex } = props;
      const { modalZindex } = reactData;
      if (zIndex) {
        reactData.modalZindex = zIndex;
      } else {
        const isMsg = computeIsMsg.value;
        if (isMsg) {
          if (modalZindex < getSubLastZIndex()) {
            reactData.modalZindex = nextSubZIndex();
          }
        } else {
          if (modalZindex < getLastZIndex()) {
            reactData.modalZindex = nextZIndex();
          }
        }
      }
    };
    const updatePosition = () => {
      return nextTick().then(() => {
        const { position } = props;
        const marginSize = import_xe_utils64.default.toNumber(props.marginSize);
        const boxElem = getBox();
        if (!boxElem) {
          return;
        }
        const clientVisibleWidth = document.documentElement.clientWidth || document.body.clientWidth;
        const clientVisibleHeight = document.documentElement.clientHeight || document.body.clientHeight;
        const isPosCenter = position === "center";
        const { top, left } = import_xe_utils64.default.isString(position) ? { top: position, left: position } : Object.assign({}, position);
        const topCenter = isPosCenter || top === "center";
        const leftCenter = isPosCenter || left === "center";
        let posTop = "";
        let posLeft = "";
        if (left && !leftCenter) {
          posLeft = isNaN(left) ? left : `${left}px`;
        } else {
          posLeft = `${Math.max(marginSize, clientVisibleWidth / 2 - boxElem.offsetWidth / 2)}px`;
        }
        if (top && !topCenter) {
          posTop = isNaN(top) ? top : `${top}px`;
        } else {
          posTop = `${Math.max(marginSize, clientVisibleHeight / 2 - boxElem.offsetHeight / 2)}px`;
        }
        boxElem.style.top = posTop;
        boxElem.style.left = posLeft;
      });
    };
    const updateStyle = () => {
      nextTick(() => {
        const { type } = props;
        const queueList = type === "notification" ? notifyQueue : msgQueue;
        let offsetTop = 0;
        queueList.forEach((comp) => {
          const boxElem = comp.getBox();
          if (boxElem) {
            offsetTop += import_xe_utils64.default.toNumber(comp.props.top);
            comp.reactData.modalTop = offsetTop;
            offsetTop += boxElem.clientHeight;
          }
        });
      });
    };
    const removeMsgQueue = () => {
      const { type } = props;
      const queueList = type === "notification" ? notifyQueue : msgQueue;
      if (queueList.indexOf($xeModal) > -1) {
        import_xe_utils64.default.remove(queueList, (comp) => comp === $xeModal);
      }
      updateStyle();
    };
    const closeModal2 = (type) => {
      const { remember } = props;
      const { visible } = reactData;
      const isMsg = computeIsMsg.value;
      const beforeHideFn = props.beforeHideMethod || getConfig().modal.beforeHideMethod;
      const params = { type };
      if (visible) {
        Promise.resolve(beforeHideFn ? beforeHideFn(params) : null).then((rest) => {
          if (!import_xe_utils64.default.isError(rest)) {
            if (isMsg) {
              removeMsgQueue();
            }
            reactData.contentVisible = false;
            if (!remember) {
              handleRevert();
            }
            import_xe_utils64.default.remove(allActiveModals, (item) => item === $xeModal);
            dispatchEvent("before-hide", params, null);
            setTimeout(() => {
              reactData.visible = false;
              emitModel(false);
              dispatchEvent("hide", params, null);
            }, 200);
            removeBodyLockScroll();
          }
        }).catch((e) => e);
      }
      return nextTick();
    };
    const closeEvent = (evnt) => {
      const type = "close";
      dispatchEvent(type, { type }, evnt);
      closeModal2(type);
    };
    const confirmEvent = (evnt) => {
      const { confirmClosable } = props;
      const type = "confirm";
      dispatchEvent(type, { type }, evnt);
      if (confirmClosable) {
        closeModal2(type);
      }
    };
    const cancelEvent = (evnt) => {
      const { cancelClosable } = props;
      const type = "cancel";
      dispatchEvent(type, { type }, evnt);
      if (cancelClosable) {
        closeModal2(type);
      }
    };
    const getStorageMap = (key) => {
      const version3 = getConfig().version;
      const rest = import_xe_utils64.default.toStringJSON(localStorage.getItem(key) || "");
      return rest && rest._v === version3 ? rest : { _v: version3 };
    };
    const hasPosStorage = () => {
      const { id, storage, storageKey } = props;
      return !!(id && storage && getStorageMap(storageKey)[id]);
    };
    const restorePosStorage = () => {
      const { id, storage, storageKey } = props;
      if (id && storage) {
        const posStorage = getStorageMap(storageKey)[id];
        if (posStorage) {
          const boxElem = getBox();
          const [left, top, width, height, zoomLeft, zoomTop, zoomWidth, zoomHeight] = posStorage.split(",");
          if (boxElem) {
            if (left) {
              boxElem.style.left = `${left}px`;
            }
            if (top) {
              boxElem.style.top = `${top}px`;
            }
            if (width) {
              boxElem.style.width = `${width}px`;
            }
            if (height) {
              boxElem.style.height = `${height}px`;
            }
          }
          if (zoomLeft && zoomTop) {
            reactData.revertLocat = {
              left: zoomLeft,
              top: zoomTop,
              width: zoomWidth,
              height: zoomHeight
            };
          }
        }
      }
    };
    const addMsgQueue = () => {
      const { type } = props;
      const queueList = type === "notification" ? notifyQueue : msgQueue;
      if (queueList.indexOf($xeModal) === -1) {
        queueList.push($xeModal);
      }
      updateStyle();
    };
    const savePosStorage = () => {
      const { id, storage, storageKey } = props;
      const { zoomStatus, revertLocat } = reactData;
      if (zoomStatus) {
        return;
      }
      if (id && storage) {
        const boxElem = getBox();
        if (!boxElem) {
          return;
        }
        const posStorageMap = getStorageMap(storageKey);
        posStorageMap[id] = [
          boxElem.style.left,
          boxElem.style.top,
          boxElem.clientWidth,
          boxElem.clientHeight
        ].concat(revertLocat ? [
          revertLocat.left,
          revertLocat.top,
          revertLocat.width,
          revertLocat.height
        ] : []).map((val) => val ? import_xe_utils64.default.toNumber(val) : "").join(",");
        localStorage.setItem(storageKey, import_xe_utils64.default.toJSONString(posStorageMap));
      }
    };
    const handleMinimize = () => {
      const zoomOpts = computeZoomOpts.value;
      const { minimizeLayout, minimizeMaxSize, minimizeHorizontalOffset, minimizeVerticalOffset, minimizeOffsetMethod } = zoomOpts;
      const isHorizontalLayout = minimizeLayout === "horizontal";
      const prevZoomStatus = reactData.zoomStatus;
      const hlMList = [];
      const vlMList = [];
      allActiveModals.forEach((item) => {
        if (item.xID !== $xeModal.xID && item.props.type === "modal" && item.reactData.zoomStatus === "minimize") {
          const itemZoomOpts = item.getComputeMaps().computeZoomOpts.value;
          if (itemZoomOpts.minimizeLayout === "horizontal") {
            hlMList.push(item);
          } else {
            vlMList.push(item);
          }
        }
      });
      const mList = isHorizontalLayout ? hlMList : vlMList;
      if (minimizeMaxSize && mList.length >= minimizeMaxSize) {
        if (VxeUI.modal) {
          VxeUI.modal.message({
            status: "error",
            content: getI18n("vxe.modal.miniMaxSize", [minimizeMaxSize])
          });
        }
        return Promise.resolve({
          status: false
        });
      }
      reactData.prevZoomStatus = prevZoomStatus;
      reactData.zoomStatus = "minimize";
      return nextTick().then(() => {
        const boxElem = getBox();
        if (!boxElem) {
          return {
            status: false
          };
        }
        const headerEl = refHeaderElem.value;
        if (!headerEl) {
          return {
            status: false
          };
        }
        const { visibleHeight } = getDomNode();
        if (!prevZoomStatus) {
          reactData.revertLocat = {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft,
            width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),
            height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)
          };
        }
        const targetModal = import_xe_utils64.default[isHorizontalLayout ? "max" : "min"](mList, ($modal) => {
          const boxElem2 = $modal.getBox();
          return boxElem2 ? import_xe_utils64.default.toNumber(boxElem2.style[isHorizontalLayout ? "left" : "top"]) : 0;
        });
        let targetTop = visibleHeight - headerEl.offsetHeight - 16;
        let targetLeft = 16;
        if (targetModal) {
          const minBoxElem = targetModal.getBox();
          if (minBoxElem) {
            const boxLeft = import_xe_utils64.default.toNumber(minBoxElem.style.left);
            const boxTop = import_xe_utils64.default.toNumber(minBoxElem.style.top);
            let offsetObj = {};
            if (isHorizontalLayout) {
              offsetObj = Object.assign({}, minimizeHorizontalOffset);
            } else {
              offsetObj = Object.assign({}, minimizeVerticalOffset);
            }
            targetLeft = boxLeft + import_xe_utils64.default.toNumber(offsetObj.left);
            targetTop = boxTop + import_xe_utils64.default.toNumber(offsetObj.top);
            if (minimizeOffsetMethod) {
              offsetObj = minimizeOffsetMethod({
                $modal: $xeModal,
                left: targetLeft,
                top: targetTop
              });
              targetLeft = import_xe_utils64.default.toNumber(offsetObj.left);
              targetTop = import_xe_utils64.default.toNumber(offsetObj.top);
            }
          }
        }
        Object.assign(boxElem.style, {
          top: `${targetTop}px`,
          left: `${targetLeft}px`,
          width: "200px",
          height: `${headerEl.offsetHeight}px`
        });
        savePosStorage();
        return {
          status: true
        };
      });
    };
    const handleMaximize = () => {
      const prevZoomStatus = reactData.zoomStatus;
      reactData.prevZoomStatus = prevZoomStatus;
      reactData.zoomStatus = "maximize";
      return nextTick().then(() => {
        const boxElem = getBox();
        if (boxElem) {
          if (!prevZoomStatus) {
            const marginSize = import_xe_utils64.default.toNumber(props.marginSize);
            const clientVisibleWidth = document.documentElement.clientWidth || document.body.clientWidth;
            const clientVisibleHeight = document.documentElement.clientHeight || document.body.clientHeight;
            reactData.revertLocat = {
              top: Math.max(marginSize, clientVisibleHeight / 2 - boxElem.offsetHeight / 2),
              left: Math.max(marginSize, clientVisibleWidth / 2 - boxElem.offsetWidth / 2),
              width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),
              height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)
            };
          }
          Object.assign(boxElem.style, {
            top: "0",
            left: "0",
            width: "100%",
            height: "100%"
          });
        }
        savePosStorage();
        return {
          status: true
        };
      });
    };
    const handleMsgAutoClose = () => {
      const { duration } = props;
      if (duration !== -1) {
        internalData.msgTimeout = setTimeout(() => closeModal2("close"), import_xe_utils64.default.toNumber(duration));
      }
    };
    const removeBodyLockScroll = () => {
      const htmlElem = document.documentElement;
      const lockData = htmlElem.getAttribute(lockScrollAttrKey);
      if (lockData) {
        const lockList = lockData.split(",").filter((key) => key !== xID);
        if (lockList.length) {
          htmlElem.setAttribute(lockScrollAttrKey, lockList.join(","));
        } else {
          htmlElem.removeAttribute(lockScrollAttrKey);
          htmlElem.style.removeProperty(lockScrollCssWidthKey);
        }
      }
    };
    const addBodyLockScroll = () => {
      const { lockScroll } = props;
      const isMsg = computeIsMsg.value;
      if (lockScroll && !isMsg) {
        const htmlElem = document.documentElement;
        const clientWidth = document.body.clientWidth;
        const lockData = htmlElem.getAttribute(lockScrollAttrKey);
        const lockList = lockData ? lockData.split(",") : [];
        if (!lockList.includes(xID)) {
          lockList.push(xID);
          htmlElem.setAttribute(lockScrollAttrKey, lockList.join(","));
        }
        htmlElem.style.setProperty(lockScrollCssWidthKey, `${clientWidth}px`);
      }
    };
    const openModal2 = () => {
      const { remember, showFooter } = props;
      const { initialized, visible } = reactData;
      const isMsg = computeIsMsg.value;
      if (!initialized) {
        reactData.initialized = true;
      }
      if (!visible) {
        addBodyLockScroll();
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveModals.push($xeModal);
        setTimeout(() => {
          reactData.contentVisible = true;
          nextTick(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = "";
            const params = { type };
            emitModel(true);
            dispatchEvent("show", params, null);
          });
        }, 10);
        if (isMsg) {
          addMsgQueue();
          handleMsgAutoClose();
        } else {
          nextTick(() => {
            const { fullscreen } = props;
            const { firstOpen } = reactData;
            if (firstOpen) {
              reactData.firstOpen = false;
              if (hasPosStorage()) {
                restorePosStorage();
              } else {
                if (fullscreen) {
                  nextTick(() => handleMaximize());
                } else {
                  recalculate();
                  updatePosition().then(() => {
                    setTimeout(() => updatePosition(), 20);
                  });
                }
              }
            } else {
              if (!remember) {
                recalculate();
                updatePosition().then(() => {
                  setTimeout(() => updatePosition(), 20);
                });
              }
            }
          });
        }
      }
      return nextTick();
    };
    const selfClickEvent = (evnt) => {
      const el = refElem.value;
      if (props.maskClosable && evnt.target === el) {
        const type = "mask";
        closeModal2(type);
      }
    };
    const selfMouseoverEvent = () => {
      const { msgTimeout } = internalData;
      if (!msgTimeout) {
        return;
      }
      const isMsg = computeIsMsg.value;
      if (isMsg) {
        clearTimeout(msgTimeout);
        internalData.msgTimeout = void 0;
      }
    };
    const selfMouseoutEvent = () => {
      const { msgTimeout } = internalData;
      if (!msgTimeout) {
        const isMsg = computeIsMsg.value;
        if (isMsg) {
          handleMsgAutoClose();
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastModal = import_xe_utils64.default.max(allActiveModals, (item) => item.reactData.modalZindex);
        if (lastModal) {
          setTimeout(() => {
            if (lastModal === $xeModal && lastModal.props.escClosable) {
              const type = "exit";
              dispatchEvent("close", { type }, evnt);
              closeModal2(type);
            }
          }, 10);
        }
      }
    };
    const isMinimized = () => {
      return reactData.zoomStatus === "minimize";
    };
    const isMaximized = () => {
      return reactData.zoomStatus === "maximize";
    };
    const handleRevert = () => {
      reactData.prevZoomStatus = reactData.zoomStatus;
      reactData.zoomStatus = "";
      return nextTick().then(() => {
        const { revertLocat } = reactData;
        if (revertLocat) {
          const boxElem = getBox();
          reactData.revertLocat = null;
          if (boxElem) {
            Object.assign(boxElem.style, {
              top: `${revertLocat.top}px`,
              left: `${revertLocat.left}px`,
              width: `${revertLocat.width}px`,
              height: `${revertLocat.height}px`
            });
          }
          savePosStorage();
          return nextTick().then(() => {
            return {
              status: true
            };
          });
        }
        return {
          status: false
        };
      });
    };
    const handleZoom = (type) => {
      const { zoomStatus } = reactData;
      return new Promise((resolve) => {
        if (type) {
          if (type === "maximize") {
            resolve(handleMaximize());
            return;
          }
          if (type === "minimize") {
            resolve(handleMinimize());
            return;
          }
          resolve(handleRevert());
          return;
        }
        resolve(zoomStatus ? handleRevert() : handleMaximize());
      }).then(() => {
        return reactData.zoomStatus || "revert";
      });
    };
    const toggleZoomMinEvent = (evnt) => {
      const { zoomStatus, prevZoomStatus } = reactData;
      return handleZoom(zoomStatus === "minimize" ? prevZoomStatus || "revert" : "minimize").then((type) => {
        const params = { type };
        dispatchEvent("zoom", params, evnt);
      });
    };
    const toggleZoomMaxEvent = (evnt) => {
      return handleZoom().then((type) => {
        const params = { type };
        dispatchEvent("zoom", params, evnt);
      });
    };
    const getPosition = () => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (boxElem) {
          return {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft
          };
        }
      }
      return null;
    };
    const setPosition = (top, left) => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (boxElem) {
          if (import_xe_utils64.default.isNumber(top)) {
            boxElem.style.top = `${top}px`;
          }
          if (import_xe_utils64.default.isNumber(left)) {
            boxElem.style.left = `${left}px`;
          }
        }
      }
      return nextTick();
    };
    const boxMousedownEvent = () => {
      const { modalZindex } = reactData;
      if (allActiveModals.some((comp) => comp.reactData.visible && comp.reactData.modalZindex > modalZindex)) {
        updateZindex();
      }
    };
    const mousedownEvent = (evnt) => {
      const { storage } = props;
      const { zoomStatus } = reactData;
      const marginSize = import_xe_utils64.default.toNumber(props.marginSize);
      const boxElem = getBox();
      if (!boxElem) {
        return;
      }
      if (zoomStatus !== "maximize" && evnt.button === 0 && !getEventTargetNode(evnt, boxElem, "trigger--btn").flag) {
        evnt.preventDefault();
        const disX = evnt.clientX - boxElem.offsetLeft;
        const disY = evnt.clientY - boxElem.offsetTop;
        const { visibleHeight, visibleWidth } = getDomNode();
        document.onmousemove = (evnt2) => {
          evnt2.preventDefault();
          const offsetWidth = boxElem.offsetWidth;
          const offsetHeight = boxElem.offsetHeight;
          const minX = marginSize;
          const maxX = visibleWidth - offsetWidth - marginSize - 1;
          const minY = marginSize;
          const maxY = visibleHeight - offsetHeight - marginSize - 1;
          let left = evnt2.clientX - disX;
          let top = evnt2.clientY - disY;
          if (left > maxX) {
            left = maxX;
          }
          if (left < minX) {
            left = minX;
          }
          if (top > maxY) {
            top = maxY;
          }
          if (top < minY) {
            top = minY;
          }
          boxElem.style.left = `${left}px`;
          boxElem.style.top = `${top}px`;
          boxElem.className = boxElem.className.replace(/\s?is--drag/, "") + " is--drag";
          dispatchEvent("move", { type: "move" }, evnt2);
          reactData.resizeFlag++;
        };
        document.onmouseup = () => {
          document.onmousemove = null;
          document.onmouseup = null;
          if (storage) {
            nextTick(() => {
              savePosStorage();
            });
          }
          reactData.resizeFlag++;
          setTimeout(() => {
            boxElem.className = boxElem.className.replace(/\s?is--drag/, "");
          }, 50);
        };
      }
    };
    const dragEvent = (evnt) => {
      evnt.preventDefault();
      const { storage } = props;
      const { visibleHeight, visibleWidth } = getDomNode();
      const marginSize = import_xe_utils64.default.toNumber(props.marginSize);
      const targetElem = evnt.target;
      const type = targetElem.getAttribute("type");
      const minWidth = import_xe_utils64.default.toNumber(props.minWidth);
      const minHeight = import_xe_utils64.default.toNumber(props.minHeight);
      const maxWidth = visibleWidth;
      const maxHeight = visibleHeight;
      const boxElem = getBox();
      const clientWidth = boxElem.clientWidth;
      const clientHeight = boxElem.clientHeight;
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      const offsetTop = boxElem.offsetTop;
      const offsetLeft = boxElem.offsetLeft;
      const params = { type: "resize" };
      document.onmousemove = (evnt2) => {
        evnt2.preventDefault();
        let dragLeft;
        let dragTop;
        let width;
        let height;
        switch (type) {
          case "wl":
            dragLeft = disX - evnt2.clientX;
            width = dragLeft + clientWidth;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            break;
          case "swst":
            dragLeft = disX - evnt2.clientX;
            dragTop = disY - evnt2.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case "swlb":
            dragLeft = disX - evnt2.clientX;
            dragTop = evnt2.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case "st":
            dragTop = disY - evnt2.clientY;
            height = clientHeight + dragTop;
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case "wr":
            dragLeft = evnt2.clientX - disX;
            width = dragLeft + clientWidth;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case "sest":
            dragLeft = evnt2.clientX - disX;
            dragTop = disY - evnt2.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case "selb":
            dragLeft = evnt2.clientX - disX;
            dragTop = evnt2.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case "sb":
            dragTop = evnt2.clientY - disY;
            height = dragTop + clientHeight;
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
        }
        boxElem.className = boxElem.className.replace(/\s?is--drag/, "") + " is--drag";
        if (storage) {
          savePosStorage();
        }
        dispatchEvent("resize", params, evnt2);
      };
      document.onmouseup = () => {
        reactData.revertLocat = null;
        document.onmousemove = null;
        document.onmouseup = null;
        setTimeout(() => {
          boxElem.className = boxElem.className.replace(/\s?is--drag/, "");
        }, 50);
      };
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $modal: $xeModal }, params));
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    modalMethods = {
      dispatchEvent,
      open: openModal2,
      close() {
        return closeModal2("close");
      },
      getBox,
      getPosition,
      setPosition,
      isMinimized,
      isMaximized,
      zoom() {
        return handleZoom();
      },
      minimize() {
        if (!reactData.visible) {
          return Promise.resolve({
            status: false
          });
        }
        return handleMinimize();
      },
      maximize() {
        if (!reactData.visible) {
          return Promise.resolve({
            status: false
          });
        }
        return handleMaximize();
      },
      revert() {
        if (!reactData.visible) {
          return Promise.resolve({
            status: false
          });
        }
        return handleRevert();
      }
    };
    Object.assign($xeModal, modalMethods);
    const renderTitles = () => {
      const { slots: propSlots = {}, showClose, showZoom, showMaximize, showMinimize, title } = props;
      const { zoomStatus } = reactData;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      const isMinimizeStatus = computeIsMinimizeStatus.value;
      const isMaximizeStatus = computeIsMaximizeStatus.value;
      return [
        h("div", {
          class: "vxe-modal--header-title"
        }, titleSlot ? getSlotVNs2(titleSlot({
          $modal: $xeModal,
          minimized: isMinimizeStatus,
          maximized: isMaximizeStatus
        })) : title ? getFuncText(title) : getI18n("vxe.alert.title")),
        h("div", {
          class: "vxe-modal--header-right"
        }, [
          cornerSlot && !isMinimizeStatus ? h("div", {
            class: "vxe-modal--corner-wrapper"
          }, getSlotVNs2(cornerSlot({ $modal: $xeModal }))) : renderEmptyElement($xeModal),
          (import_xe_utils64.default.isBoolean(showMinimize) ? showMinimize : showZoom) ? h("div", {
            class: ["vxe-modal--zoom-btn", "trigger--btn"],
            title: getI18n(`vxe.modal.zoom${zoomStatus === "minimize" ? "Out" : "Min"}`),
            onClick: toggleZoomMinEvent
          }, [
            h("i", {
              class: zoomStatus === "minimize" ? getIcon().MODAL_ZOOM_REVERT : getIcon().MODAL_ZOOM_MIN
            })
          ]) : renderEmptyElement($xeModal),
          (import_xe_utils64.default.isBoolean(showMaximize) ? showMaximize : showZoom) && zoomStatus !== "minimize" ? h("div", {
            class: ["vxe-modal--zoom-btn", "trigger--btn"],
            title: getI18n(`vxe.modal.zoom${zoomStatus === "maximize" ? "Out" : "In"}`),
            onClick: toggleZoomMaxEvent
          }, [
            h("i", {
              class: zoomStatus === "maximize" ? getIcon().MODAL_ZOOM_OUT : getIcon().MODAL_ZOOM_IN
            })
          ]) : renderEmptyElement($xeModal),
          showClose ? h("div", {
            class: ["vxe-modal--close-btn", "trigger--btn"],
            title: getI18n("vxe.modal.close"),
            onClick: closeEvent
          }, [
            h("i", {
              class: getIcon().MODAL_CLOSE
            })
          ]) : renderEmptyElement($xeModal)
        ])
      ];
    };
    const renderHeader = () => {
      const { slots: propSlots = {}, showZoom, showMaximize, draggable } = props;
      const headerSlot = slots.header || propSlots.header;
      if (props.showHeader) {
        const headerOns = {};
        if (draggable) {
          headerOns.onMousedown = mousedownEvent;
        }
        if ((import_xe_utils64.default.isBoolean(showMaximize) ? showMaximize : showZoom) && props.dblclickZoom && props.type === "modal") {
          headerOns.onDblclick = toggleZoomMaxEvent;
        }
        return h("div", Object.assign({ ref: refHeaderElem, class: ["vxe-modal--header", {
          "is--ellipsis": props.showTitleOverflow
        }] }, headerOns), headerSlot ? getSlotVNs2(headerSlot({ $modal: $xeModal })) : renderTitles());
      }
      return renderEmptyElement($xeModal);
    };
    const renderBody = () => {
      const { slots: propSlots = {}, status, message, iconStatus } = props;
      const content = props.content || message;
      const isMsg = computeIsMsg.value;
      const defaultSlot = slots.default || propSlots.default;
      const leftSlot = slots.left || propSlots.left;
      const rightSlot = slots.right || propSlots.right;
      const contVNs = [];
      if (!isMsg && (status || iconStatus)) {
        contVNs.push(h("div", {
          class: "vxe-modal--status-wrapper"
        }, [
          h("i", {
            class: ["vxe-modal--status-icon", iconStatus || getIcon()[`MODAL_${status}`.toLocaleUpperCase()]]
          })
        ]));
      }
      contVNs.push(h("div", {
        class: "vxe-modal--content"
      }, defaultSlot ? getSlotVNs2(defaultSlot({ $modal: $xeModal })) : getFuncText(content)));
      return h("div", {
        class: "vxe-modal--body"
      }, [
        leftSlot ? h("div", {
          class: "vxe-modal--body-left"
        }, getSlotVNs2(leftSlot({ $modal: $xeModal }))) : renderEmptyElement($xeModal),
        h("div", {
          class: "vxe-modal--body-default"
        }, contVNs),
        rightSlot ? h("div", {
          class: "vxe-modal--body-right"
        }, getSlotVNs2(rightSlot({ $modal: $xeModal }))) : renderEmptyElement($xeModal),
        isMsg ? renderEmptyElement($xeModal) : h(loading_default2, {
          class: "vxe-modal--loading",
          modelValue: props.loading
        })
      ]);
    };
    const renderDefaultFooter = () => {
      const { slots: propSlots = {}, showCancelButton, showConfirmButton, type, loading: loading2 } = props;
      const lfSlot = slots.leftfoot || propSlots.leftfoot;
      const rfSlot = slots.rightfoot || propSlots.rightfoot;
      const btnVNs = [];
      if (import_xe_utils64.default.isBoolean(showCancelButton) ? showCancelButton : type === "confirm") {
        btnVNs.push(h(button_default, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || getI18n("vxe.button.cancel"),
          onClick: cancelEvent
        }));
      }
      if (import_xe_utils64.default.isBoolean(showConfirmButton) ? showConfirmButton : type === "confirm" || type === "alert") {
        btnVNs.push(h(button_default, {
          key: 2,
          ref: refConfirmBtn,
          loading: loading2,
          status: "primary",
          content: props.confirmButtonText || getI18n("vxe.button.confirm"),
          onClick: confirmEvent
        }));
      }
      return h("div", {
        class: "vxe-modal--footer-wrapper"
      }, [
        h("div", {
          class: "vxe-modal--footer-left"
        }, lfSlot ? getSlotVNs2(lfSlot({ $modal: $xeModal })) : []),
        h("div", {
          class: "vxe-modal--footer-right"
        }, rfSlot ? getSlotVNs2(rfSlot({ $modal: $xeModal })) : btnVNs)
      ]);
    };
    const renderFooter = () => {
      const { slots: propSlots = {} } = props;
      const footerSlot = slots.footer || propSlots.footer;
      if (props.showFooter) {
        return h("div", {
          class: "vxe-modal--footer"
        }, footerSlot ? getSlotVNs2(footerSlot({ $modal: $xeModal })) : [renderDefaultFooter()]);
      }
      return renderEmptyElement($xeModal);
    };
    const renderVN = () => {
      const { slots: propSlots = {}, className, type, animat, draggable, iconStatus, position, loading: loading2, destroyOnClose, status, lockScroll, padding, lockView, mask, resize } = props;
      const { initialized, modalTop, contentVisible, visible, zoomStatus } = reactData;
      const asideSlot = slots.aside || propSlots.aside;
      const vSize = computeSize.value;
      const isMsg = computeIsMsg.value;
      const isMinimizeStatus = computeIsMinimizeStatus.value;
      const btnTransfer = computeBtnTransfer.value;
      const ons = {};
      if (isMsg) {
        ons.onMouseover = selfMouseoverEvent;
        ons.onMouseout = selfMouseoutEvent;
      }
      return h(Teleport, {
        to: "body",
        disabled: btnTransfer ? !initialized : true
      }, [
        h("div", Object.assign({ ref: refElem, class: ["vxe-modal--wrapper", `type--${type}`, `zoom--${zoomStatus || "revert"}`, className || "", position ? `pos--${position}` : "", {
          [`size--${vSize}`]: vSize,
          [`status--${status}`]: status,
          "is--padding": padding,
          "is--animat": animat,
          "lock--scroll": lockScroll,
          "lock--view": lockView,
          "is--draggable": draggable,
          "is--resize": resize,
          "is--mask": mask,
          "is--visible": contentVisible,
          "is--active": visible,
          "is--loading": loading2
        }], style: {
          zIndex: reactData.modalZindex,
          top: modalTop ? `${modalTop}px` : null
        }, onClick: selfClickEvent }, ons), [
          h("div", {
            ref: refModalBox,
            class: "vxe-modal--box",
            onMousedown: boxMousedownEvent
          }, [
            (isMsg || asideSlot) && !isMinimizeStatus ? h("div", {
              class: "vxe-modal--aside"
            }, asideSlot ? getSlotVNs2(asideSlot({ $modal: $xeModal })) : [
              status || iconStatus ? h("div", {
                class: "vxe-modal--status-wrapper"
              }, [
                h("i", {
                  class: ["vxe-modal--status-icon", iconStatus || getIcon()[`MODAL_${status}`.toLocaleUpperCase()]]
                })
              ]) : renderEmptyElement($xeModal)
            ]) : renderEmptyElement($xeModal),
            h("div", {
              class: "vxe-modal--container"
            }, !reactData.initialized || destroyOnClose && !reactData.visible ? [] : [
              renderHeader(),
              renderBody(),
              renderFooter(),
              !isMsg && resize ? h("span", {
                class: "vxe-modal--resize"
              }, ["wl", "wr", "swst", "sest", "st", "swlb", "selb", "sb"].map((type2) => {
                return h("span", {
                  class: `${type2}-resize`,
                  type: type2,
                  onMousedown: dragEvent
                });
              })) : renderEmptyElement($xeModal)
            ])
          ])
        ])
      ]);
    };
    $xeModal.renderVN = renderVN;
    watch(() => props.width, recalculate);
    watch(() => props.height, recalculate);
    watch(() => props.modelValue, (value) => {
      if (value) {
        openModal2();
      } else {
        closeModal2("model");
      }
    });
    onMounted(() => {
      if (props.type === "modal" && props.showFooter && !(props.showConfirmButton || props.showCancelButton || slots.footer)) {
        warnLog("vxe.modal.footPropErr");
      }
      nextTick(() => {
        if (props.storage && !props.id) {
          errLog("vxe.error.reqProp", ["[modal] id"]);
        }
        if (props.modelValue) {
          openModal2();
        }
        recalculate();
      });
      if (props.escClosable) {
        globalEvents.on($xeModal, "keydown", handleGlobalKeydownEvent);
      }
    });
    onUnmounted(() => {
      globalEvents.off($xeModal, "keydown");
      removeMsgQueue();
      removeBodyLockScroll();
    });
    provide("$xeModal", $xeModal);
    return $xeModal;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/modal/index.js
function handleModal(options) {
  checkDynamic();
  return new Promise((resolve) => {
    const opts = Object.assign({}, options);
    if (opts.id && allActiveModals.some((comp) => comp.props.id === opts.id)) {
      resolve("exist");
    } else {
      const _onHide = opts.onHide;
      const modalOpts = Object.assign(opts, {
        key: import_xe_utils65.default.uniqueId(),
        modelValue: true,
        onHide(params) {
          const modalList = dynamicStore.modals;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.modals = modalList.filter((item) => item.key !== modalOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.modals.push(modalOpts);
    }
  });
}
function getModal(id) {
  return import_xe_utils65.default.find(allActiveModals, ($modal) => $modal.props.id === id);
}
function closeModal(id) {
  const modals = id ? [getModal(id)] : allActiveModals;
  const restPromises = [];
  modals.forEach(($modal) => {
    if ($modal) {
      restPromises.push($modal.close());
    }
  });
  return Promise.all(restPromises);
}
function handleOpen(defOpts, content, title, options) {
  let opts;
  if (import_xe_utils65.default.isObject(content)) {
    opts = content;
  } else {
    opts = { content: import_xe_utils65.default.toValueString(content), title };
  }
  return handleModal(Object.assign(Object.assign(Object.assign({}, defOpts), options), opts));
}
function openModal(options) {
  return handleOpen({
    type: "modal"
  }, options);
}
function openAlert(content, title, options) {
  return handleOpen({
    type: "alert",
    lockScroll: true,
    showHeader: true,
    showFooter: true
  }, content, title, options);
}
function openConfirm(content, title, options) {
  return handleOpen({
    type: "confirm",
    status: "question",
    lockScroll: true,
    showHeader: true,
    showFooter: true
  }, content, title, options);
}
function openMessage(content, options) {
  return handleOpen({
    type: "message",
    mask: false,
    lockView: false,
    lockScroll: false,
    showHeader: false
  }, content, "", options);
}
function openNotification(content, title, options) {
  return handleOpen({
    type: "notification",
    mask: false,
    lockView: false,
    lockScroll: false,
    showHeader: true,
    draggable: false,
    position: "top-right",
    width: 320
  }, content, title, options);
}
var ModalController = {
  get: getModal,
  close: closeModal,
  open: openModal,
  alert: openAlert,
  confirm: openConfirm,
  message: openMessage,
  notification: openNotification
};
var VxeModal = Object.assign(modal_default, {
  install: function(app) {
    app.component(modal_default.name, modal_default);
  }
});
VxeUI.modal = ModalController;
dynamicApp.use(VxeModal);
VxeUI.component(modal_default);
var Modal = VxeModal;
var modal_default2 = VxeModal;

// node_modules/vxe-pc-ui/es/notice-bar/src/notice-bar.js
var import_xe_utils66 = __toESM(require_xe_utils());
var notice_bar_default = defineVxeComponent({
  name: "VxeNoticeBar",
  props: {
    duration: [String, Number],
    direction: {
      type: String,
      default: () => getConfig().noticeBar.direction
    },
    speed: {
      type: String,
      default: () => getConfig().noticeBar.speed
    },
    content: String,
    vertical: Boolean,
    loop: {
      type: Boolean
    },
    size: {
      type: String,
      default: () => getConfig().noticeBar.size || getConfig().size
    }
  },
  emits: [
    "start",
    "end"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeTabs = inject("$xeTabs", null);
    const xID = import_xe_utils66.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refContentElem = ref();
    const reactData = reactive({
      animationStatus: false,
      animationDuration: 0
    });
    const refMaps = {
      refElem
    };
    const computeNoticeText = computed(() => {
      const { content } = props;
      return `${content || ""}`;
    });
    const computeTabsResizeFlag = computed(() => {
      return $xeTabs ? $xeTabs.reactData.resizeFlag : null;
    });
    const computeMaps = {};
    const $xeNoticeBar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $noticeBar: $xeNoticeBar }, params));
    };
    const noticeBarMethods = {
      dispatchEvent
    };
    const noticeBarPrivateMethods = {};
    const updateAnimationStyle = () => {
      const { speed } = props;
      const contEl = refContentElem.value;
      if (contEl) {
        let sRate = 46;
        if (speed === "fast") {
          sRate = 118;
        } else if (speed === "slow") {
          sRate = 18;
        }
        reactData.animationDuration = Math.ceil(contEl.scrollWidth / sRate);
      }
    };
    const animationStartEvent = (evnt) => {
      reactData.animationStatus = true;
      dispatchEvent("start", { status: true }, evnt);
    };
    const animationEndEvent = (evnt) => {
      reactData.animationStatus = false;
      dispatchEvent("end", { status: false }, evnt);
    };
    Object.assign($xeNoticeBar, noticeBarMethods, noticeBarPrivateMethods);
    const renderVN = () => {
      const { vertical, duration, direction, loop } = props;
      const { animationDuration, animationStatus } = reactData;
      const vSize = computeSize.value;
      const noticeText = computeNoticeText.value;
      const defaultSlot = slots.default;
      const prefixSlot = slots.prefix;
      const suffixSlot = slots.suffix;
      return h("div", {
        ref: refElem,
        class: ["vxe-notice-bar", `is--${vertical ? "vertical" : "horizontal"}`, `dir--${direction || "left"}`, {
          [`size--${vSize}`]: vSize,
          "is--loop": loop
        }]
      }, [
        prefixSlot ? h("div", {
          class: "vxe-notice-bar--prefix"
        }, prefixSlot({})) : renderEmptyElement($xeNoticeBar),
        h("div", {
          class: "vxe-notice-bar--content"
        }, [
          h("div", {
            ref: refContentElem,
            class: "vxe-notice-bar--inner"
          }, [
            h("div", {
              class: ["vxe-notice-bar--wrapper", `is--${animationStatus ? "progress" : "end"}`],
              style: {
                animationDuration: duration ? toCssUnit(duration, "s") : `${animationDuration}s`
              },
              onAnimationstart: animationStartEvent,
              onAnimationend: animationEndEvent
            }, defaultSlot ? defaultSlot({}) : noticeText)
          ])
        ]),
        suffixSlot ? h("div", {
          class: "vxe-notice-bar--suffix"
        }, suffixSlot({})) : renderEmptyElement($xeNoticeBar)
      ]);
    };
    watch(computeTabsResizeFlag, () => {
      updateAnimationStyle();
    });
    onMounted(() => {
      globalEvents.on($xeNoticeBar, "resize", updateAnimationStyle);
      updateAnimationStyle();
    });
    onBeforeUnmount(() => {
      globalEvents.off($xeNoticeBar, "resize");
    });
    $xeNoticeBar.renderVN = renderVN;
    return $xeNoticeBar;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/notice-bar/index.js
var VxeNoticeBar = Object.assign({}, notice_bar_default, {
  install(app) {
    app.component(notice_bar_default.name, notice_bar_default);
  }
});
dynamicApp.use(VxeNoticeBar);
VxeUI.component(notice_bar_default);
var NoticeBar = VxeNoticeBar;
var notice_bar_default2 = VxeNoticeBar;

// node_modules/vxe-pc-ui/es/number-input/index.js
var VxeNumberInput = Object.assign({}, number_input_default, {
  install(app) {
    app.component(number_input_default.name, number_input_default);
  }
});
dynamicApp.use(VxeNumberInput);
VxeUI.component(number_input_default);
var NumberInput = VxeNumberInput;
var number_input_default2 = VxeNumberInput;

// node_modules/vxe-pc-ui/es/select/src/util.js
var import_xe_utils68 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/select/src/option-info.js
var import_xe_utils67 = __toESM(require_xe_utils());
var OptionInfo = class {
  constructor($xeselect, _vm) {
    Object.assign(this, {
      id: import_xe_utils67.default.uniqueId("option_"),
      value: _vm.value,
      label: _vm.label,
      visible: _vm.visible,
      className: _vm.className,
      disabled: _vm.disabled
    });
  }
  update(name, value) {
    this[name] = value;
  }
};

// node_modules/vxe-pc-ui/es/select/src/util.js
function isOption(option) {
  return option instanceof OptionInfo;
}
function createOption($xeSelect, _vm) {
  return isOption(_vm) ? _vm : new OptionInfo($xeSelect, _vm);
}
function watchOption(props, option) {
  Object.keys(props).forEach((name) => {
    watch(() => props[name], (value) => {
      option.update(name, value);
    });
  });
}
function assembleOption($xeSelect, el, option, $xeOptgroup) {
  const { reactData } = $xeSelect;
  const { staticOptions } = reactData;
  const parentElem = el.parentNode;
  const parentOption = $xeOptgroup ? $xeOptgroup.optionConfig : null;
  const parentCols = parentOption ? parentOption.options : staticOptions;
  if (parentElem && parentCols) {
    parentCols.splice(import_xe_utils68.default.arrayIndexOf(parentElem.children, el), 0, option);
    reactData.staticOptions = staticOptions.slice(0);
  }
}
function destroyOption($xeSelect, option) {
  const { reactData } = $xeSelect;
  const { staticOptions } = reactData;
  const matchObj = import_xe_utils68.default.findTree(staticOptions, (item) => item.id === option.id, { children: "options" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticOptions = staticOptions.slice(0);
}

// node_modules/vxe-pc-ui/es/select/src/optgroup.js
var optgroup_default = defineVxeComponent({
  name: "VxeOptgroup",
  props: {
    label: {
      type: [String, Number, Boolean],
      default: ""
    },
    visible: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    disabled: Boolean
  },
  emits: [],
  setup(props, { slots }) {
    const elem = ref();
    const $xeSelect = inject("$xeSelect", {});
    const optionConfig = createOption($xeSelect, props);
    const $xeOptgroup = { optionConfig };
    optionConfig.options = [];
    provide("$xeOptgroup", $xeOptgroup);
    watchOption(props, optionConfig);
    onMounted(() => {
      const el = elem.value;
      assembleOption($xeSelect, el, optionConfig);
    });
    onUnmounted(() => {
      destroyOption($xeSelect, optionConfig);
    });
    return () => {
      const defaultSlot = slots.default;
      return h("div", {
        ref: elem
      }, defaultSlot ? defaultSlot({}) : []);
    };
  }
});

// node_modules/vxe-pc-ui/es/optgroup/index.js
var VxeOptgroup = Object.assign(optgroup_default, {
  install: function(app) {
    app.component(optgroup_default.name, optgroup_default);
  }
});
dynamicApp.use(VxeOptgroup);
VxeUI.component(optgroup_default);
var Optgroup = VxeOptgroup;
var optgroup_default2 = VxeOptgroup;

// node_modules/vxe-pc-ui/es/select/src/option.js
var option_default = defineVxeComponent({
  name: "VxeOption",
  props: {
    value: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: ""
    },
    visible: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    disabled: Boolean
  },
  emits: [],
  setup(props, { slots }) {
    const elem = ref();
    const $xeSelect = inject("$xeSelect", {});
    const $xeOptgroup = inject("$xeOptgroup", null);
    const optionConfig = createOption($xeSelect, props);
    optionConfig.slots = slots;
    watchOption(props, optionConfig);
    onMounted(() => {
      const el = elem.value;
      assembleOption($xeSelect, el, optionConfig, $xeOptgroup);
    });
    onUnmounted(() => {
      destroyOption($xeSelect, optionConfig);
    });
    return () => {
      return h("div", {
        ref: elem
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/option/index.js
var VxeOption = Object.assign(option_default, {
  install: function(app) {
    app.component(option_default.name, option_default);
  }
});
dynamicApp.use(VxeOption);
VxeUI.component(option_default);
var Option = VxeOption;
var option_default2 = VxeOption;

// node_modules/vxe-pc-ui/es/pager/src/pager.js
var import_xe_utils70 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/select/src/select.js
var import_xe_utils69 = __toESM(require_xe_utils());
function isOptionVisible(option) {
  return option.visible !== false;
}
function getOptUniqueId() {
  return import_xe_utils69.default.uniqueId("opt_");
}
function createInternalData3() {
  return {
    synchData: [],
    fullData: [],
    afterVisibleList: [],
    optAddMaps: {},
    optGroupKeyMaps: {},
    optFullValMaps: {},
    remoteValMaps: {},
    lastScrollLeft: 0,
    lastScrollTop: 0,
    scrollYStore: {
      startIndex: 0,
      endIndex: 0,
      visibleSize: 0,
      offsetSize: 0,
      rowHeight: 0
    },
    lastScrollTime: 0,
    hpTimeout: void 0
  };
}
var select_default = defineVxeComponent({
  name: "VxeSelect",
  props: {
    modelValue: [String, Number, Boolean, Array],
    defaultConfig: Object,
    clearable: Boolean,
    placeholder: String,
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    multiCharOverflow: {
      type: [Number, String],
      default: () => getConfig().select.multiCharOverflow
    },
    prefixIcon: String,
    allowCreate: {
      type: Boolean,
      default: () => getConfig().select.allowCreate
    },
    placement: String,
    lazyOptions: Array,
    options: Array,
    optionProps: Object,
    optionGroups: Array,
    optionGroupProps: Object,
    optionConfig: Object,
    className: [String, Function],
    popupClassName: [String, Function],
    max: {
      type: [String, Number],
      default: null
    },
    zIndex: Number,
    size: {
      type: String,
      default: () => getConfig().select.size || getConfig().size
    },
    filterable: Boolean,
    filterMethod: Function,
    remote: Boolean,
    remoteConfig: Object,
    emptyText: String,
    showTotalButoon: {
      type: Boolean,
      default: () => getConfig().select.showTotalButoon
    },
    showCheckedButoon: {
      type: Boolean,
      default: () => getConfig().select.showCheckedButoon
    },
    showClearButton: {
      type: Boolean,
      default: () => getConfig().select.showClearButton
    },
    transfer: {
      type: Boolean,
      default: null
    },
    virtualYConfig: Object,
    scrollY: Object,
    /**
     * 已废弃，被 remote-config.queryMethod 替换
     * @deprecated
     */
    remoteMethod: Function,
    /**
     * 已废弃，被 option-config.keyField 替换
     * @deprecated
     */
    optionId: {
      type: String,
      default: () => getConfig().select.optionId
    },
    /**
     * 已废弃，被 option-config.useKey 替换
     * @deprecated
     */
    optionKey: Boolean
  },
  emits: [
    "update:modelValue",
    "change",
    "all-change",
    "clear",
    "blur",
    "focus",
    "click",
    "scroll",
    "visible-change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils69.default.uniqueId();
    const refElem = ref();
    const refInput = ref();
    const refInpSearch = ref();
    const refVirtualWrapper = ref();
    const refOptionPanel = ref();
    const refVirtualBody = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      scrollYLoad: false,
      bodyHeight: 0,
      topSpaceHeight: 0,
      optList: [],
      staticOptions: [],
      reactFlag: 0,
      currentOption: null,
      searchValue: "",
      searchLoading: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = createInternalData3();
    const refMaps = {
      refElem
    };
    const $xeSelect = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (import_xe_utils69.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().select.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseSelect");
    });
    const computeDefaultOpts = computed(() => {
      return Object.assign({}, props.defaultConfig);
    });
    const computePropsOpts = computed(() => {
      return Object.assign({}, props.optionProps);
    });
    const computeGroupPropsOpts = computed(() => {
      return Object.assign({}, props.optionGroupProps);
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeGroupLabelField = computed(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.label || "label";
    });
    const computeGroupOptionsField = computed(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.options || "options";
    });
    const computeIsMaximize = computed(() => {
      const selectVals = computeSelectVals.value;
      return checkMaxLimit(selectVals);
    });
    const computeVirtualYOpts = computed(() => {
      return Object.assign({}, getConfig().select.virtualYConfig || getConfig().select.scrollY, props.virtualYConfig || props.scrollY);
    });
    const computeRemoteOpts = computed(() => {
      return Object.assign({}, getConfig().select.remoteConfig, props.remoteConfig);
    });
    const computeOptionOpts = computed(() => {
      return Object.assign({}, getConfig().select.optionConfig, props.optionConfig);
    });
    const computeMultiMaxCharNum = computed(() => {
      return import_xe_utils69.default.toNumber(props.multiCharOverflow);
    });
    const computeSelectVals = computed(() => {
      const { modelValue, multiple } = props;
      let vals = [];
      if (import_xe_utils69.default.isArray(modelValue)) {
        vals = modelValue;
      } else {
        if (multiple) {
          if (!eqEmptyValue(modelValue)) {
            vals = `${modelValue}`.indexOf(",") > -1 ? `${modelValue}`.split(",") : [modelValue];
          }
        } else {
          vals = modelValue === null || modelValue === void 0 ? [] : [modelValue];
        }
      }
      return vals;
    });
    const computeFullLabel = computed(() => {
      const { remote } = props;
      const { reactFlag } = reactData;
      const selectVals = computeSelectVals.value;
      if (remote && reactFlag) {
        return selectVals.map((val) => getRemoteSelectLabel(val)).join(", ");
      }
      return selectVals.map((val) => getSelectLabel(val)).join(", ");
    });
    const computeSelectLabel = computed(() => {
      const { remote, multiple } = props;
      const { reactFlag } = reactData;
      const multiMaxCharNum = computeMultiMaxCharNum.value;
      const selectVals = computeSelectVals.value;
      if (remote && reactFlag) {
        return selectVals.map((val) => getRemoteSelectLabel(val)).join(", ");
      }
      const labels = selectVals.map((val) => getSelectLabel(val));
      if (multiple && multiMaxCharNum > 0 && labels.length > multiMaxCharNum) {
        return `${labels.slice(0, multiMaxCharNum)}...`;
      }
      return labels.join(", ");
    });
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils69.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils69.default.isFunction(slotFunc)) {
          return getSlotVNs2(slotFunc(params));
        }
      }
      return [];
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $select: $xeSelect }, params));
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const getOptKey = () => {
      const optionOpts = computeOptionOpts.value;
      return optionOpts.keyField || props.optionId || "_X_OPTION_KEY";
    };
    const getOptId = (option) => {
      const optid = option[getOptKey()];
      return optid ? encodeURIComponent(optid) : "";
    };
    const checkMaxLimit = (selectVals) => {
      const { multiple, max } = props;
      if (multiple && max) {
        return selectVals.length >= import_xe_utils69.default.toNumber(max);
      }
      return false;
    };
    const getRemoteSelectLabel = (value) => {
      const { lazyOptions } = props;
      const { remoteValMaps, optFullValMaps } = internalData;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const remoteItem = remoteValMaps[value] || optFullValMaps[value];
      const item = remoteItem ? remoteItem.item : null;
      if (item) {
        return import_xe_utils69.default.toValueString(item[labelField]);
      }
      if (lazyOptions) {
        const lazyItem = lazyOptions.find((item2) => item2[valueField] === value);
        if (lazyItem) {
          return lazyItem[labelField];
        }
      }
      return value;
    };
    const getSelectLabel = (value) => {
      const { lazyOptions } = props;
      const { optFullValMaps } = internalData;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const cacheItem = reactData.reactFlag ? optFullValMaps[value] : null;
      if (cacheItem) {
        return cacheItem.item[labelField];
      }
      if (lazyOptions) {
        const lazyItem = lazyOptions.find((item) => item[valueField] === value);
        if (lazyItem) {
          return lazyItem[labelField];
        }
      }
      return value;
    };
    const cacheItemMap = (datas) => {
      const groupOptionsField = computeGroupOptionsField.value;
      const valueField = computeValueField.value;
      const key = getOptKey();
      const groupKeyMaps = {};
      const fullKeyMaps = {};
      const list = [];
      const handleOptItem = (item) => {
        list.push(item);
        let optid = getOptId(item);
        if (!optid) {
          optid = getOptUniqueId();
          item[key] = optid;
        }
        fullKeyMaps[item[valueField]] = {
          key: optid,
          item,
          _index: -1
        };
      };
      datas.forEach((group) => {
        handleOptItem(group);
        if (group[groupOptionsField]) {
          groupKeyMaps[group[key]] = group;
          group[groupOptionsField].forEach(handleOptItem);
        }
      });
      internalData.fullData = list;
      internalData.optGroupKeyMaps = groupKeyMaps;
      internalData.optFullValMaps = fullKeyMaps;
      reactData.reactFlag++;
      handleOption();
    };
    const handleOption = () => {
      const { modelValue, filterable, filterMethod } = props;
      const { searchValue } = reactData;
      const { fullData, optFullValMaps } = internalData;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const searchStr = `${searchValue || ""}`.toLowerCase();
      let avList = [];
      if (filterable && filterMethod) {
        avList = fullData.filter((option) => isOptionVisible(option) && filterMethod({ $select: $xeSelect, group: null, option, searchValue, value: modelValue }));
      } else if (filterable) {
        avList = fullData.filter((option) => isOptionVisible(option) && (!searchStr || `${option[labelField] || option[valueField]}`.toLowerCase().indexOf(searchStr) > -1));
      } else {
        avList = fullData.filter(isOptionVisible);
      }
      avList.forEach((item, index) => {
        const cacheItem = optFullValMaps[item[valueField]];
        if (cacheItem) {
          cacheItem._index = index;
        }
      });
      internalData.afterVisibleList = avList;
      return nextTick();
    };
    const setCurrentOption = (option) => {
      if (option) {
        reactData.currentOption = option;
      }
    };
    const updateZIndex = () => {
      const { zIndex } = props;
      if (zIndex) {
        reactData.panelIndex = zIndex;
      } else if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const { placement } = props;
      const { panelIndex } = reactData;
      const targetElem = refElem.value;
      const panelElem = refOptionPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return nextTick().then(handleStyle);
    };
    const handleScrollSelect = () => {
      nextTick(() => {
        const { isAniVisible, visiblePanel } = reactData;
        const { optFullValMaps } = internalData;
        const selectVals = computeSelectVals.value;
        if (selectVals.length && isAniVisible && visiblePanel) {
          const cacheItem = reactData.reactFlag ? optFullValMaps[`${selectVals[0]}`] : null;
          if (cacheItem) {
            handleScrollToOption(cacheItem.item);
          }
        }
      });
    };
    const showOptionPanel = () => {
      const { loading: loading2, filterable, remote } = props;
      const { fullData, hpTimeout } = internalData;
      const isDisabled = computeIsDisabled.value;
      const remoteOpts = computeRemoteOpts.value;
      if (!loading2 && !isDisabled) {
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = void 0;
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (filterable) {
          if (remote && remoteOpts.enabled && remoteOpts.autoLoad && !fullData.length) {
            handleSearchEvent();
          } else {
            handleOption();
            updateYData();
          }
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
          handleFocusSearch();
          recalculate().then(() => {
            handleScrollSelect();
            refreshScroll();
          });
        }, 10);
        setTimeout(() => {
          recalculate().then(() => refreshScroll());
        }, 100);
        updateZIndex();
        updatePlacement();
        dispatchEvent("visible-change", { visible: true }, null);
      }
    };
    const hideOptionPanel = () => {
      reactData.searchValue = "";
      reactData.searchLoading = false;
      reactData.visiblePanel = false;
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
      dispatchEvent("visible-change", { visible: false }, null);
    };
    const changeEvent = (evnt, selectValue, option) => {
      emitModel(selectValue);
      if (selectValue !== props.modelValue) {
        dispatchEvent("change", { value: selectValue, option }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      internalData.remoteValMaps = {};
      changeEvent(evnt, selectValue, null);
      dispatchEvent("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params) => {
      const { $event } = params;
      clearValueEvent($event, null);
      hideOptionPanel();
    };
    const allCheckedPanelEvent = (params) => {
      const { $event } = params;
      const { multiple, max } = props;
      const { optList } = reactData;
      const valueField = computeValueField.value;
      if (multiple) {
        const selectVals = computeSelectVals.value;
        const currVlas = selectVals.slice(0);
        for (let i = 0; i < optList.length; i++) {
          const option = optList[i];
          const selectValue = option[valueField];
          if (checkMaxLimit(currVlas)) {
            if (VxeUI) {
              VxeUI.modal.message({
                content: getI18n("vxe.select.overSizeErr", [max]),
                status: "warning"
              });
            }
            break;
          }
          if (!currVlas.some((val) => val === selectValue)) {
            currVlas.push(selectValue);
          }
        }
        changeEvent($event, currVlas, optList[0]);
        dispatchEvent("all-change", { value: currVlas }, $event);
      }
    };
    const clearCheckedPanelEvent = (params) => {
      const { $event } = params;
      clearValueEvent($event, null);
      hideOptionPanel();
    };
    const changeOptionEvent = (evnt, option) => {
      const { multiple } = props;
      const { remoteValMaps } = internalData;
      const valueField = computeValueField.value;
      const selectValue = option[valueField];
      const remoteItem = remoteValMaps[selectValue];
      if (!reactData.visiblePanel) {
        return;
      }
      if (remoteItem) {
        remoteItem.item = option;
      } else {
        remoteValMaps[selectValue] = {
          key: getOptId(option),
          item: option,
          _index: -1
        };
      }
      if (multiple) {
        let multipleValue = [];
        const selectVals = computeSelectVals.value;
        const index = import_xe_utils69.default.findIndexOf(selectVals, (val) => val === selectValue);
        if (index === -1) {
          multipleValue = selectVals.concat([selectValue]);
        } else {
          multipleValue = selectVals.filter((val) => val !== selectValue);
        }
        changeEvent(evnt, multipleValue, option);
      } else {
        changeEvent(evnt, selectValue, option);
        hideOptionPanel();
      }
      reactData.reactFlag++;
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const validOffsetOption = (option) => {
      const isDisabled = option.disabled;
      const optid = getOptId(option);
      if (!isDisabled && !hasOptGroupById(optid)) {
        return true;
      }
      return false;
    };
    const findOffsetOption = (option, isDwArrow) => {
      const { allowCreate } = props;
      const { optList } = reactData;
      const { optFullValMaps, optAddMaps, afterVisibleList } = internalData;
      const valueField = computeValueField.value;
      let fullList = afterVisibleList;
      let offsetAddIndex = 0;
      if (allowCreate && optList.length) {
        const firstItem = optList[0];
        const optid = getOptId(firstItem);
        if (optAddMaps[optid]) {
          offsetAddIndex = 1;
          fullList = [optAddMaps[optid]].concat(fullList);
        }
      }
      if (!option) {
        if (isDwArrow) {
          for (let i = 0; i < fullList.length; i++) {
            const item = fullList[i];
            if (validOffsetOption(item)) {
              return item;
            }
          }
        } else {
          for (let len = fullList.length - 1; len >= 0; len--) {
            const item = fullList[len];
            if (validOffsetOption(item)) {
              return item;
            }
          }
        }
      }
      let avIndex = 0;
      const cacheItem = option ? optFullValMaps[option[valueField]] : null;
      if (cacheItem) {
        avIndex = cacheItem._index + offsetAddIndex;
      }
      if (avIndex > -1) {
        if (isDwArrow) {
          for (let i = avIndex + 1; i <= fullList.length - 1; i++) {
            const item = fullList[i];
            if (validOffsetOption(item)) {
              return item;
            }
          }
        } else {
          if (avIndex > 0) {
            for (let len = avIndex - 1; len >= 0; len--) {
              const item = fullList[len];
              if (validOffsetOption(item)) {
                return item;
              }
            }
          }
        }
      }
      return null;
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const { visiblePanel, currentOption } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            if (currentOption) {
              evnt.preventDefault();
              evnt.stopPropagation();
              changeOptionEvent(evnt, currentOption);
            }
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
            let offsetOption = findOffsetOption(currentOption, isDwArrow);
            if (!offsetOption) {
              offsetOption = findOffsetOption(null, isDwArrow);
            }
            if (offsetOption) {
              setCurrentOption(offsetOption);
              handleScrollToOption(offsetOption, isDwArrow);
            }
          }
        } else if ((isUpArrow || isDwArrow || isEnter) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { visiblePanel, isActivated } = reactData;
      if (visiblePanel) {
        hideOptionPanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const { visiblePanel } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    const handleFocusSearch = () => {
      if (props.filterable) {
        nextTick(() => {
          const inpSearch = refInpSearch.value;
          if (inpSearch) {
            inpSearch.focus();
          }
        });
      }
    };
    const focusEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 500);
        }
      }
      dispatchEvent("focus", {}, evnt);
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      dispatchEvent("click", { triggerButton: false, visible: reactData.visiblePanel }, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      dispatchEvent("blur", {}, evnt);
    };
    const suffixClickEvent = (evnt) => {
      togglePanelEvent(evnt);
      dispatchEvent("click", { triggerButton: true, visible: reactData.visiblePanel }, evnt);
    };
    const modelSearchEvent = (value) => {
      reactData.searchValue = value;
    };
    const focusSearchEvent = () => {
      reactData.isActivated = true;
    };
    const handleSearchEvent = () => {
      const { modelValue, remote, remoteMethod } = props;
      const { searchValue } = reactData;
      const remoteOpts = computeRemoteOpts.value;
      const queryMethod = remoteOpts.queryMethod || remoteMethod;
      if (remote && queryMethod && remoteOpts.enabled) {
        reactData.searchLoading = true;
        Promise.resolve(queryMethod({ $select: $xeSelect, searchValue, value: modelValue })).then(() => nextTick()).catch(() => nextTick()).finally(() => {
          reactData.searchLoading = false;
          handleOption();
          updateYData();
        });
      } else {
        handleOption();
        updateYData();
      }
    };
    const triggerSearchEvent = import_xe_utils69.default.debounce(handleSearchEvent, 350, { trailing: true });
    const togglePanelEvent = (params) => {
      const { $event } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const checkOptionDisabled = (isSelected, option) => {
      if (option.disabled) {
        return true;
      }
      const isMaximize = computeIsMaximize.value;
      if (isMaximize && !isSelected) {
        return true;
      }
      return false;
    };
    const updateYSpace = () => {
      const { scrollYLoad } = reactData;
      const { scrollYStore, afterVisibleList } = internalData;
      reactData.bodyHeight = scrollYLoad ? afterVisibleList.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const handleData = () => {
      const { filterable, allowCreate } = props;
      const { scrollYLoad, searchValue } = reactData;
      const { optAddMaps, scrollYStore, afterVisibleList } = internalData;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const restList = scrollYLoad ? afterVisibleList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : afterVisibleList.slice(0);
      if (filterable && allowCreate && searchValue) {
        if (!restList.some((option) => option[labelField] === searchValue)) {
          const addItem = optAddMaps[searchValue] || reactive({
            [getOptKey()]: searchValue,
            [labelField]: searchValue,
            [valueField]: searchValue
          });
          optAddMaps[searchValue] = addItem;
          restList.unshift(addItem);
        }
      }
      reactData.optList = restList;
      return nextTick();
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return nextTick().then(() => {
        const { scrollYLoad } = reactData;
        const { scrollYStore } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const virtualYOpts = computeVirtualYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(20, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, scrollBodyElem ? Math.ceil(scrollBodyElem.clientHeight / rowHeight) : 0);
          const offsetYSize = Math.max(0, Math.min(2, import_xe_utils69.default.toNumber(virtualYOpts.oSize)));
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex, visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
      });
    };
    const handleScrollToOption = (option, isDwArrow) => {
      const { scrollYLoad } = reactData;
      const { optFullValMaps, scrollYStore } = internalData;
      const valueField = computeValueField.value;
      const cacheItem = optFullValMaps[option[valueField]];
      if (cacheItem) {
        const optid = cacheItem.key;
        const avIndex = cacheItem._index;
        if (avIndex > -1) {
          const optWrapperElem = refVirtualWrapper.value;
          const panelElem = refOptionPanel.value;
          if (!panelElem) {
            return;
          }
          const optElem = panelElem.querySelector(`[optid='${optid}']`);
          if (optWrapperElem) {
            if (optElem) {
              const wrapperHeight = optWrapperElem.offsetHeight;
              const offsetPadding = 1;
              if (isDwArrow) {
                if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;
                } else if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;
                }
              } else {
                if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;
                } else if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;
                }
              }
            } else if (scrollYLoad) {
              if (isDwArrow) {
                optWrapperElem.scrollTop = avIndex * scrollYStore.rowHeight - optWrapperElem.clientHeight + scrollYStore.rowHeight;
              } else {
                optWrapperElem.scrollTop = avIndex * scrollYStore.rowHeight;
              }
            }
          }
        }
      }
    };
    const scrollTo2 = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        if (import_xe_utils69.default.isNumber(scrollLeft)) {
          scrollBodyElem.scrollLeft = scrollLeft;
        }
        if (import_xe_utils69.default.isNumber(scrollTop)) {
          scrollBodyElem.scrollTop = scrollTop;
        }
      }
      if (reactData.scrollYLoad) {
        return new Promise((resolve) => {
          setTimeout(() => {
            nextTick(() => {
              resolve();
            });
          }, 50);
        });
      }
      return nextTick();
    };
    const refreshScroll = () => {
      const { lastScrollLeft, lastScrollTop } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo2(lastScrollLeft, lastScrollTop);
        }
      });
    };
    const recalculate = () => {
      const el = refElem.value;
      if (el && el.clientWidth && el.clientHeight) {
        return computeScrollLoad();
      }
      return Promise.resolve();
    };
    const loadYData = (evnt) => {
      const { scrollYStore } = internalData;
      const { startIndex, endIndex, visibleSize, offsetSize, rowHeight } = scrollYStore;
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    const isVMScrollProcess = () => {
      const delayHover = 250;
      const { lastScrollTime } = internalData;
      return !!(lastScrollTime && Date.now() < lastScrollTime + delayHover);
    };
    const scrollEvent = (evnt) => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData(evnt);
      }
      internalData.lastScrollTime = Date.now();
      dispatchEvent("scroll", { scrollLeft, scrollTop, isX, isY }, evnt);
    };
    const loadData = (datas) => {
      cacheItemMap(datas || []);
      const { isLoaded, fullData, scrollYStore } = internalData;
      const defaultOpts = computeDefaultOpts.value;
      const virtualYOpts = computeVirtualYOpts.value;
      const valueField = computeValueField.value;
      Object.assign(scrollYStore, {
        startIndex: 0,
        endIndex: 1,
        visibleSize: 0
      });
      internalData.synchData = datas || [];
      reactData.scrollYLoad = !!virtualYOpts.enabled && virtualYOpts.gt > -1 && (virtualYOpts.gt === 0 || virtualYOpts.gt <= fullData.length);
      handleData();
      if (!isLoaded) {
        const { selectMode } = defaultOpts;
        if (datas.length > 0 && import_xe_utils69.default.eqNull(props.modelValue)) {
          if (selectMode === "first" || selectMode === "last") {
            const selectItem = import_xe_utils69.default[selectMode](datas);
            if (selectItem) {
              nextTick(() => {
                if (import_xe_utils69.default.eqNull(props.modelValue)) {
                  emitModel(selectItem[valueField]);
                }
              });
            }
          }
          internalData.isLoaded = true;
        }
      }
      return computeScrollLoad().then(() => {
        refreshScroll();
      });
    };
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
        scrollBodyElem.scrollLeft = 0;
      }
      internalData.lastScrollTop = 0;
      internalData.lastScrollLeft = 0;
      return nextTick();
    };
    const hasOptGroupById = (optid) => {
      const { optGroupKeyMaps } = internalData;
      return !!optGroupKeyMaps[optid];
    };
    const selectMethods = {
      dispatchEvent,
      loadData,
      reloadData(datas) {
        internalData.isLoaded = false;
        clearScroll();
        return loadData(datas);
      },
      isPanelVisible() {
        return reactData.visiblePanel;
      },
      togglePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return nextTick();
      },
      hidePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return nextTick();
      },
      showPanel() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return nextTick();
      },
      refreshOption() {
        handleOption();
        updateYData();
        return nextTick();
      },
      focus() {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
        reactData.isActivated = true;
        return nextTick();
      },
      blur() {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
        reactData.isActivated = false;
        return nextTick();
      },
      recalculate,
      clearScroll
    };
    Object.assign($xeSelect, selectMethods);
    const renderOption = (list) => {
      const { allowCreate, optionKey } = props;
      const { currentOption } = reactData;
      const { optAddMaps } = internalData;
      const optionOpts = computeOptionOpts.value;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const groupLabelField = computeGroupLabelField.value;
      const selectVals = computeSelectVals.value;
      const { useKey, height } = optionOpts;
      const optionSlot = slots.option;
      return list.map((option, cIndex) => {
        const { slots: slots2, className } = option;
        const optid = getOptId(option);
        const optionValue = option[valueField];
        const isOptGroup = hasOptGroupById(optid);
        const isAdd = !!(allowCreate && optAddMaps[optid]);
        const isSelected = !isAdd && selectVals.indexOf(optionValue) > -1;
        const isVisible = isAdd || (!isOptGroup || isOptionVisible(option));
        const isDisabled = !isAdd && checkOptionDisabled(isSelected, option);
        const defaultSlot = slots2 ? slots2.default : null;
        const optParams = { option, group: isOptGroup ? option : null, $select: $xeSelect };
        let optLabel = "";
        let optVNs = [];
        if (optionSlot) {
          optVNs = callSlot(optionSlot, optParams);
        } else if (defaultSlot) {
          optVNs = callSlot(defaultSlot, optParams);
        } else {
          optLabel = getFuncText(option[isOptGroup ? groupLabelField : labelField] || optionValue);
          optVNs = optLabel;
        }
        return isVisible ? h("div", {
          key: useKey || optionKey ? optid : cIndex,
          class: ["vxe-select-option", className ? import_xe_utils69.default.isFunction(className) ? className(optParams) : className : "", {
            "vxe-select-optgroup": isOptGroup,
            "is--disabled": isDisabled,
            "is--selected": isSelected,
            "is--add": isAdd,
            "is--hover": currentOption && getOptId(currentOption) === optid
          }],
          optid,
          title: optLabel || null,
          style: height ? {
            height: toCssUnit(height)
          } : void 0,
          onMousedown: (evnt) => {
            const isLeftBtn = evnt.button === 0;
            if (isLeftBtn) {
              evnt.stopPropagation();
            }
          },
          onClick: (evnt) => {
            if (!isDisabled && !isOptGroup) {
              changeOptionEvent(evnt, option);
            }
          },
          onMouseenter: () => {
            if (!isDisabled && !isOptGroup && !isVMScrollProcess()) {
              setCurrentOption(option);
            }
          }
        }, allowCreate ? [
          h("span", {
            key: 1,
            class: "vxe-select-option--label"
          }, optVNs),
          isAdd ? h("span", {
            key: 2,
            class: "vxe-select-option--add-icon"
          }, [
            h("i", {
              class: getIcon().SELECT_ADD_OPTION
            })
          ]) : renderEmptyElement($xeSelect)
        ] : optVNs) : renderEmptyElement($xeSelect);
      });
    };
    const renderOpts = () => {
      const { optList, searchLoading } = reactData;
      if (searchLoading) {
        return [
          h("div", {
            class: "vxe-select--search-loading"
          }, [
            h("i", {
              class: ["vxe-select--search-icon", getIcon().SELECT_LOADED]
            }),
            h("span", {
              class: "vxe-select--search-text"
            }, getI18n("vxe.select.loadingText"))
          ])
        ];
      }
      if (optList.length) {
        return renderOption(optList);
      }
      return [
        h("div", {
          class: "vxe-select--empty-placeholder"
        }, props.emptyText || getI18n("vxe.select.emptyText"))
      ];
    };
    const renderVN = () => {
      const { className, popupClassName, multiple, loading: loading2, filterable, showTotalButoon, showCheckedButoon, showClearButton } = props;
      const { initialized, isActivated, isAniVisible, optList, visiblePanel, bodyHeight, topSpaceHeight } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const fullLabel = computeFullLabel.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-select--readonly", className]
        }, [
          h("div", {
            class: "vxe-select-slots",
            ref: "hideOption"
          }, defaultSlot ? defaultSlot({}) : []),
          h("span", {
            class: "vxe-select-label",
            title: fullLabel
          }, selectLabel)
        ]);
      }
      const selectVals = computeSelectVals.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-select", className ? import_xe_utils69.default.isFunction(className) ? className({ $select: $xeSelect }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--filter": filterable,
          "is--loading": loading2,
          "is--active": isActivated
        }]
      }, [
        h("div", {
          class: "vxe-select-slots",
          ref: "hideOption"
        }, defaultSlot ? defaultSlot({}) : []),
        h(input_default, {
          ref: refInput,
          clearable: props.clearable,
          placeholder: inpPlaceholder,
          readonly: true,
          disabled: isDisabled,
          type: "text",
          prefixIcon: props.prefixIcon,
          suffixIcon: loading2 ? getIcon().SELECT_LOADED : visiblePanel ? getIcon().SELECT_OPEN : getIcon().SELECT_CLOSE,
          autoFocus: false,
          title: fullLabel,
          modelValue: selectLabel,
          onClear: clearEvent,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent,
          onSuffixClick: suffixClickEvent
        }, prefixSlot ? {
          prefix: () => prefixSlot({})
        } : {}),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-select--panel", popupClassName ? import_xe_utils69.default.isFunction(popupClassName) ? popupClassName({ $select: $xeSelect }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": !loading2 && isAniVisible,
              "ani--enter": !loading2 && visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, initialized && (visiblePanel || isAniVisible) ? [
            h("div", {
              class: "vxe-select--panel-wrapper"
            }, [
              filterable ? h("div", {
                class: "vxe-select--panel-search"
              }, [
                h(input_default, {
                  ref: refInpSearch,
                  class: "vxe-select-search--input",
                  modelValue: reactData.searchValue,
                  type: "text",
                  clearable: true,
                  disabled: false,
                  readonly: false,
                  placeholder: getI18n("vxe.select.search"),
                  prefixIcon: getIcon().INPUT_SEARCH,
                  "onUpdate:modelValue": modelSearchEvent,
                  onFocus: focusSearchEvent,
                  onChange: triggerSearchEvent,
                  onSearch: triggerSearchEvent
                })
              ]) : renderEmptyElement($xeSelect),
              showTotalButoon || showCheckedButoon && multiple || showClearButton || headerSlot ? h("div", {
                class: "vxe-select--panel-header"
              }, headerSlot ? callSlot(headerSlot, {}) : [
                h("div", {
                  class: "vxe-select--header-button"
                }, [
                  showTotalButoon ? h("div", {
                    class: "vxe-select--header-total"
                  }, getI18n("vxe.select.total", [selectVals.length, optList.length])) : renderEmptyElement($xeSelect),
                  h("div", {
                    class: "vxe-select--header-btns"
                  }, [
                    showCheckedButoon && multiple ? h(button_default, {
                      content: getI18n("vxe.select.allChecked"),
                      mode: "text",
                      onClick: allCheckedPanelEvent
                    }) : renderEmptyElement($xeSelect),
                    showClearButton ? h(button_default, {
                      content: getI18n("vxe.select.clear"),
                      mode: "text",
                      onClick: clearCheckedPanelEvent
                    }) : renderEmptyElement($xeSelect)
                  ])
                ])
              ]) : renderEmptyElement($xeSelect),
              h("div", {
                class: "vxe-select--panel-body"
              }, [
                h("div", {
                  ref: refVirtualWrapper,
                  class: "vxe-select-option--wrapper",
                  onScroll: scrollEvent
                }, [
                  h("div", {
                    class: "vxe-select--y-space",
                    style: {
                      height: bodyHeight ? `${bodyHeight}px` : ""
                    }
                  }),
                  h("div", {
                    ref: refVirtualBody,
                    class: "vxe-select--body",
                    style: {
                      transform: `translateY(${topSpaceHeight}px)`
                    }
                  }, renderOpts())
                ])
              ]),
              footerSlot ? h("div", {
                class: "vxe-select--panel-footer"
              }, callSlot(footerSlot, {})) : renderEmptyElement($xeSelect)
            ])
          ] : [])
        ])
      ]);
    };
    watch(() => reactData.staticOptions, (val) => {
      loadData(val);
    });
    watch(() => props.options, (val) => {
      loadData(val || []);
    });
    watch(() => props.optionGroups, (val) => {
      loadData(val || []);
    });
    onMounted(() => {
      nextTick(() => {
        const { options, optionGroups } = props;
        if (optionGroups) {
          loadData(optionGroups);
        } else if (options) {
          loadData(options);
        }
      });
      globalEvents.on($xeSelect, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeSelect, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeSelect, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeSelect, "blur", handleGlobalBlurEvent);
      globalEvents.on($xeSelect, "resize", handleGlobalResizeEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeSelect, "mousewheel");
      globalEvents.off($xeSelect, "mousedown");
      globalEvents.off($xeSelect, "keydown");
      globalEvents.off($xeSelect, "blur");
      globalEvents.off($xeSelect, "resize");
      import_xe_utils69.default.assign(internalData, createInternalData3());
    });
    provide("$xeSelect", $xeSelect);
    $xeSelect.renderVN = renderVN;
    return $xeSelect;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/pager/src/pager.js
var pager_default = defineVxeComponent({
  name: "VxePager",
  props: {
    size: {
      type: String,
      default: () => getConfig().pager.size || getConfig().size
    },
    // 自定义布局
    layouts: {
      type: Array,
      default: () => getConfig().pager.layouts || ["PrevJump", "PrevPage", "Jump", "PageCount", "NextPage", "NextJump", "Sizes", "Total"]
    },
    // 当前页
    currentPage: {
      type: Number,
      default: 1
    },
    // 加载中
    loading: Boolean,
    // 每页大小
    pageSize: {
      type: Number,
      default: () => getConfig().pager.pageSize || 10
    },
    // 总条数
    total: { type: Number, default: 0 },
    // 显示页码按钮的数量
    pagerCount: {
      type: Number,
      default: () => getConfig().pager.pagerCount || 7
    },
    // 每页大小选项列表
    pageSizes: {
      type: Array,
      default: () => getConfig().pager.pageSizes || [10, 15, 20, 50, 100]
    },
    // 列对齐方式
    align: {
      type: String,
      default: () => getConfig().pager.align
    },
    // 带边框
    border: {
      type: Boolean,
      default: () => getConfig().pager.border
    },
    // 带背景颜色
    background: {
      type: Boolean,
      default: () => getConfig().pager.background
    },
    // 配套的样式
    perfect: {
      type: Boolean,
      default: () => getConfig().pager.perfect
    },
    // 当只有一页时隐藏
    autoHidden: {
      type: Boolean,
      default: () => getConfig().pager.autoHidden
    },
    transfer: {
      type: Boolean,
      default: () => getConfig().pager.transfer
    },
    className: [String, Function],
    pageSizePlacement: {
      type: String,
      default: () => getConfig().pager.pageSizePlacement
    },
    // 自定义图标
    iconPrevPage: String,
    iconJumpPrev: String,
    iconJumpNext: String,
    iconNextPage: String,
    iconJumpMore: String,
    iconHomePage: String,
    iconEndPage: String
  },
  emits: [
    "update:pageSize",
    "update:currentPage",
    "page-change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils70.default.uniqueId();
    const { computeSize } = useSize(props);
    const $xeGrid = inject("$xeGrid", null);
    const reactData = reactive({
      inpCurrPage: props.currentPage
    });
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const computePageCount = computed(() => {
      return getPageCount(props.total, props.pageSize);
    });
    const computeNumList = computed(() => {
      const { pagerCount } = props;
      const pageCount = computePageCount.value;
      const len = pageCount > pagerCount ? pagerCount - 2 : pagerCount;
      const rest = [];
      for (let index = 0; index < len; index++) {
        rest.push(index);
      }
      return rest;
    });
    const computeOffsetNumber = computed(() => {
      return Math.floor((props.pagerCount - 2) / 2);
    });
    const computeSizeList = computed(() => {
      return props.pageSizes.map((item) => {
        if (import_xe_utils70.default.isNumber(item)) {
          return {
            value: item,
            label: `${getI18n("vxe.pager.pagesize", [item])}`
          };
        }
        return Object.assign({ value: "", label: "" }, item);
      });
    });
    const $xePager = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $pager: $xePager }, params));
    };
    const getPageCount = (total, size) => {
      return Math.max(Math.ceil(total / size), 1);
    };
    const handleJumpPageEvent = (evnt, currentPage) => {
      emit("update:currentPage", currentPage);
      if (evnt && currentPage !== props.currentPage) {
        dispatchEvent("page-change", { type: "current", pageSize: props.pageSize, currentPage }, evnt);
      }
    };
    const handleChangeCurrentPage = (currentPage, evnt) => {
      emit("update:currentPage", currentPage);
      if (evnt && currentPage !== props.currentPage) {
        dispatchEvent("page-change", { type: "current", pageSize: props.pageSize, currentPage }, evnt);
      }
    };
    const triggerJumpEvent = (params) => {
      const { $event } = params;
      const inputElem = $event.target;
      const inpValue = import_xe_utils70.default.toInteger(inputElem.value);
      const pageCount = computePageCount.value;
      const current = inpValue <= 0 ? 1 : inpValue >= pageCount ? pageCount : inpValue;
      const currPage = import_xe_utils70.default.toValueString(current);
      inputElem.value = currPage;
      reactData.inpCurrPage = currPage;
      handleChangeCurrentPage(current, $event);
    };
    const handleHomePage = (evnt) => {
      const { currentPage } = props;
      if (currentPage > 1) {
        handleChangeCurrentPage(1, evnt);
      }
    };
    const handleEndPage = (evnt) => {
      const { currentPage } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        handleChangeCurrentPage(pageCount, evnt);
      }
    };
    const handlePrevPage = (evnt) => {
      const { currentPage } = props;
      const pageCount = computePageCount.value;
      if (currentPage > 1) {
        handleChangeCurrentPage(Math.min(pageCount, Math.max(currentPage - 1, 1)), evnt);
      }
    };
    const handleNextPage = (evnt) => {
      const { currentPage } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        handleChangeCurrentPage(Math.min(pageCount, currentPage + 1), evnt);
      }
    };
    const handlePrevJump = (evnt) => {
      const numList = computeNumList.value;
      handleChangeCurrentPage(Math.max(props.currentPage - numList.length, 1), evnt);
    };
    const handleNextJump = (evnt) => {
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      handleChangeCurrentPage(Math.min(props.currentPage + numList.length, pageCount), evnt);
    };
    const pageSizeEvent = (params) => {
      const { value, $event } = params;
      const pageSize = import_xe_utils70.default.toNumber(value);
      const pageCount = getPageCount(props.total, pageSize);
      let currentPage = props.currentPage;
      if (currentPage > pageCount) {
        currentPage = pageCount;
        emit("update:currentPage", pageCount);
      }
      emit("update:pageSize", pageSize);
      if ($event) {
        dispatchEvent("page-change", { type: "size", pageSize, currentPage }, $event);
      }
    };
    const jumpKeydownEvent = (params) => {
      const { $event } = params;
      if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ENTER)) {
        triggerJumpEvent(params);
      } else if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ARROW_UP)) {
        $event.preventDefault();
        handleNextPage($event);
      } else if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ARROW_DOWN)) {
        $event.preventDefault();
        handlePrevPage($event);
      }
    };
    const renderHomePage = () => {
      const { currentPage, total } = props;
      const homeSlot = slots.home;
      const pageCount = computePageCount.value;
      if (homeSlot) {
        return h("span", {
          class: "vxe-pager--custom-home-btn"
        }, homeSlot({ $pager: $xePager, total, currentPage, pageCount }));
      }
      return h("button", {
        class: ["vxe-pager--home-btn", {
          "is--disabled": currentPage <= 1
        }],
        type: "button",
        title: getI18n("vxe.pager.homePageTitle"),
        onClick: handleHomePage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconHomePage || getIcon().PAGER_HOME]
        })
      ]);
    };
    const renderPrevPage = () => {
      const { currentPage, total } = props;
      const prevPageSlot = slots.prevPage || slots["prev-page"];
      const pageCount = computePageCount.value;
      if (prevPageSlot) {
        return h("span", {
          class: "vxe-pager--custom-prev-btn"
        }, prevPageSlot({ $pager: $xePager, total, currentPage, pageCount }));
      }
      return h("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": currentPage <= 1
        }],
        type: "button",
        title: getI18n("vxe.pager.prevPageTitle"),
        onClick: handlePrevPage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconPrevPage || getIcon().PAGER_PREV_PAGE]
        })
      ]);
    };
    const renderPrevJump = (tagName) => {
      const { currentPage, total } = props;
      const prevJumpSlot = slots.prevJump || slots["prev-jump"];
      const pageCount = computePageCount.value;
      if (prevJumpSlot) {
        return h("span", {
          class: "vxe-pager--custom-jump-prev"
        }, prevJumpSlot({ $pager: $xePager, total, currentPage, pageCount }));
      }
      return h(tagName || "button", {
        class: ["vxe-pager--jump-prev", {
          "is--fixed": !tagName,
          "is--disabled": currentPage <= 1
        }],
        type: "button",
        title: getI18n("vxe.pager.prevJumpTitle"),
        onClick: handlePrevJump
      }, [
        tagName ? h("i", {
          class: ["vxe-pager--jump-more-icon", props.iconJumpMore || getIcon().PAGER_JUMP_MORE]
        }) : null,
        h("i", {
          class: ["vxe-pager--jump-icon", props.iconJumpPrev || getIcon().PAGER_JUMP_PREV]
        })
      ]);
    };
    const renderNextJump = (tagName) => {
      const { currentPage, total } = props;
      const nextJumpSlot = slots.nextJump || slots["next-jump"];
      const pageCount = computePageCount.value;
      if (nextJumpSlot) {
        return h("span", {
          class: "vxe-pager--custom-jump-next"
        }, nextJumpSlot({ $pager: $xePager, total, currentPage, pageCount }));
      }
      return h(tagName || "button", {
        class: ["vxe-pager--jump-next", {
          "is--fixed": !tagName,
          "is--disabled": currentPage >= pageCount
        }],
        type: "button",
        title: getI18n("vxe.pager.nextJumpTitle"),
        onClick: handleNextJump
      }, [
        tagName ? h("i", {
          class: ["vxe-pager--jump-more-icon", props.iconJumpMore || getIcon().PAGER_JUMP_MORE]
        }) : null,
        h("i", {
          class: ["vxe-pager--jump-icon", props.iconJumpNext || getIcon().PAGER_JUMP_NEXT]
        })
      ]);
    };
    const renderNextPage = () => {
      const { currentPage, total } = props;
      const nextPageSlot = slots.nextPage || slots["next-page"];
      const pageCount = computePageCount.value;
      if (nextPageSlot) {
        return h("span", {
          class: "vxe-pager--custom-next-btn"
        }, nextPageSlot({ $pager: $xePager, total, currentPage, pageCount }));
      }
      return h("button", {
        class: ["vxe-pager--next-btn", {
          "is--disabled": currentPage >= pageCount
        }],
        type: "button",
        title: getI18n("vxe.pager.nextPageTitle"),
        onClick: handleNextPage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconNextPage || getIcon().PAGER_NEXT_PAGE]
        })
      ]);
    };
    const renderEndPage = () => {
      const { currentPage, total } = props;
      const endSlot = slots.end;
      const pageCount = computePageCount.value;
      if (endSlot) {
        return h("span", {
          class: "vxe-pager--custom-end-btn"
        }, endSlot({ $pager: $xePager, total, currentPage, pageCount }));
      }
      return h("button", {
        class: ["vxe-pager--end-btn", {
          "is--disabled": currentPage >= pageCount
        }],
        type: "button",
        title: getI18n("vxe.pager.endPageTitle"),
        onClick: handleEndPage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconEndPage || getIcon().PAGER_END]
        })
      ]);
    };
    const renderNumber = (showJump) => {
      const { currentPage, total, pagerCount } = props;
      const numberSlot = showJump ? slots.numberJump || slots["number-jump"] : slots.number;
      const nums = [];
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      const offsetNumber = computeOffsetNumber.value;
      const isOv = pageCount > pagerCount;
      const isLt = isOv && currentPage > offsetNumber + 1;
      const isGt = isOv && currentPage < pageCount - offsetNumber;
      const restList = [];
      let startNumber = 1;
      if (isOv) {
        if (currentPage >= pageCount - offsetNumber) {
          startNumber = Math.max(pageCount - numList.length + 1, 1);
        } else {
          startNumber = Math.max(currentPage - offsetNumber, 1);
        }
      }
      if (showJump && isLt) {
        restList.push(1);
        nums.push(h("button", {
          class: "vxe-pager--num-btn",
          type: "button",
          onClick: (evnt) => handleJumpPageEvent(evnt, 1)
        }, "1"), renderPrevJump("span"));
      }
      numList.forEach((item, index) => {
        const number = startNumber + index;
        if (number <= pageCount) {
          restList.push(number);
          nums.push(h("button", {
            key: number,
            class: ["vxe-pager--num-btn", {
              "is--active": currentPage === number
            }],
            type: "button",
            onClick: (evnt) => handleJumpPageEvent(evnt, number)
          }, `${number}`));
        }
      });
      if (showJump && isGt) {
        restList.push(pageCount);
        nums.push(renderNextJump("button"), h("button", {
          class: "vxe-pager--num-btn",
          type: "button",
          onClick: (evnt) => handleJumpPageEvent(evnt, pageCount)
        }, pageCount));
      }
      if (numberSlot) {
        return h("span", {
          class: "vxe-pager--custom-btn-wrapper"
        }, numberSlot({ $pager: $xePager, total, numList: restList, currentPage, pageCount }));
      }
      return h("span", {
        class: "vxe-pager--btn-wrapper"
      }, nums);
    };
    const renderJumpNumber = () => {
      return renderNumber(true);
    };
    const renderSizes = () => {
      const { total, currentPage, pageSize, pageSizePlacement, transfer } = props;
      const sizesSlot = slots.sizes;
      const sizeList = computeSizeList.value;
      const pageCount = computePageCount.value;
      if (sizesSlot) {
        return h("span", {
          class: "vxe-pager--custom-sizes"
        }, sizesSlot({ $pager: $xePager, total, currentPage, pageCount, pageSize, options: sizeList }));
      }
      return h(select_default, {
        class: "vxe-pager--sizes",
        modelValue: pageSize,
        placement: pageSizePlacement,
        transfer,
        options: sizeList,
        onChange: pageSizeEvent
      });
    };
    const renderJump = (isFull) => {
      const { total } = props;
      const { inpCurrPage } = reactData;
      const jumpSlot = isFull ? slots.fullJump || slots["full-jump"] : slots.jump;
      const pageCount = computePageCount.value;
      if (jumpSlot) {
        return h("span", {
          class: "vxe-pager--custom-jump"
        }, jumpSlot({ $pager: $xePager, total, currentPage: inpCurrPage, pageCount }));
      }
      return h("span", {
        class: "vxe-pager--jump"
      }, [
        isFull ? h("span", {
          class: "vxe-pager--goto-text"
        }, getI18n("vxe.pager.goto")) : null,
        h(number_input_default, {
          class: "vxe-pager--goto",
          modelValue: reactData.inpCurrPage,
          placeholder: getI18n("vxe.pager.gotoTitle"),
          align: "center",
          type: "integer",
          max: pageCount,
          min: 1,
          controls: false,
          onKeydown: jumpKeydownEvent,
          onBlur: triggerJumpEvent,
          "onUpdate:modelValue"(val) {
            reactData.inpCurrPage = val;
          }
        }),
        isFull ? h("span", {
          class: "vxe-pager--classifier-text"
        }, getI18n("vxe.pager.pageClassifier")) : null
      ]);
    };
    const renderFullJump = () => {
      return renderJump(true);
    };
    const renderPageCount = () => {
      const { currentPage, total } = props;
      const pageCountSlot = slots.pageCount || slots["page-count"];
      const pageCount = computePageCount.value;
      if (pageCountSlot) {
        return h("span", {
          class: "vxe-pager--custom-count"
        }, pageCountSlot({ $pager: $xePager, total, currentPage, pageCount }));
      }
      return h("span", {
        class: "vxe-pager--count"
      }, [
        h("span", {
          class: "vxe-pager--separator"
        }),
        h("span", pageCount)
      ]);
    };
    const renderTotal = () => {
      const { currentPage, total } = props;
      const totalSlot = slots.total;
      const pageCount = computePageCount.value;
      if (totalSlot) {
        return h("span", {
          class: "vxe-pager--custom-total"
        }, totalSlot({ $pager: $xePager, total, currentPage, pageCount }));
      }
      return h("span", {
        class: "vxe-pager--total"
      }, getI18n("vxe.pager.total", [total]));
    };
    const pagerMethods = {
      dispatchEvent,
      setPageSize(num) {
        pageSizeEvent({ value: num });
        return nextTick();
      },
      setPageSizeByEvent(evnt, num) {
        pageSizeEvent({ value: num, $event: evnt });
      },
      homePage() {
        handleHomePage();
        return nextTick();
      },
      homePageByEvent(evnt) {
        handleHomePage(evnt);
      },
      endPage() {
        handleEndPage();
        return nextTick();
      },
      endPageByEvent(evnt) {
        handleEndPage(evnt);
      },
      prevPage() {
        handlePrevPage();
        return nextTick();
      },
      prevPageByEvent(evnt) {
        handlePrevPage(evnt);
      },
      nextPage() {
        handleNextPage();
        return nextTick();
      },
      nextPageByEvent(evnt) {
        handleNextPage(evnt);
      },
      prevJump() {
        handlePrevJump();
        return nextTick();
      },
      prevJumpByEvent(evnt) {
        handlePrevJump(evnt);
      },
      nextJump() {
        handleNextJump();
        return nextTick();
      },
      nextJumpByEvent(evnt) {
        handleNextJump(evnt);
      },
      setCurrentPage(currentPage) {
        const current = import_xe_utils70.default.toNumber(currentPage) || 1;
        reactData.inpCurrPage = current;
        handleChangeCurrentPage(current);
        return nextTick();
      },
      setCurrentPageByEvent(evnt, currentPage) {
        const current = import_xe_utils70.default.toNumber(currentPage) || 1;
        reactData.inpCurrPage = current;
        handleChangeCurrentPage(current, evnt);
      },
      /**
       * 已废弃，被 setCurrentPage 替换
       * @deprecated
       */
      jumpPage(currentPage) {
        warnLog("vxe.error.delFunc", ["[pager] jumpPage", "setCurrentPage"]);
        return $xePager.setCurrentPage(currentPage);
      }
    };
    const pagerPrivateMethods = {
      handlePrevPage,
      handleNextPage,
      handlePrevJump,
      handleNextJump
    };
    Object.assign($xePager, pagerMethods, pagerPrivateMethods);
    watch(() => props.currentPage, (value) => {
      reactData.inpCurrPage = value;
    });
    const renderVN = () => {
      const { align, layouts, className } = props;
      const childNodes = [];
      const vSize = computeSize.value;
      const pageCount = computePageCount.value;
      if (slots.left) {
        childNodes.push(h("span", {
          class: "vxe-pager--left-wrapper"
        }, slots.left({ $grid: $xeGrid })));
      }
      layouts.forEach((name) => {
        let renderFn;
        switch (name) {
          case "Home":
            renderFn = renderHomePage;
            break;
          case "PrevJump":
            renderFn = renderPrevJump;
            break;
          case "PrevPage":
            renderFn = renderPrevPage;
            break;
          case "Number":
            renderFn = renderNumber;
            break;
          case "JumpNumber":
            renderFn = renderJumpNumber;
            break;
          case "NextPage":
            renderFn = renderNextPage;
            break;
          case "NextJump":
            renderFn = renderNextJump;
            break;
          case "End":
            renderFn = renderEndPage;
            break;
          case "Sizes":
            renderFn = renderSizes;
            break;
          case "FullJump":
            renderFn = renderFullJump;
            break;
          case "Jump":
            renderFn = renderJump;
            break;
          case "PageCount":
            renderFn = renderPageCount;
            break;
          case "Total":
            renderFn = renderTotal;
            break;
        }
        if (renderFn) {
          childNodes.push(renderFn());
        } else {
          errLog("vxe.error.notProp", [`[pager] layouts -> ${name}`]);
        }
      });
      if (slots.right) {
        childNodes.push(h("span", {
          class: "vxe-pager--right-wrapper"
        }, slots.right({ $grid: $xeGrid })));
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-pager", className ? import_xe_utils70.default.isFunction(className) ? className({ $pager: $xePager }) : className : "", {
          [`size--${vSize}`]: vSize,
          [`align--${align}`]: align,
          "is--border": props.border,
          "is--background": props.background,
          "is--perfect": props.perfect,
          "is--hidden": props.autoHidden && pageCount === 1,
          "is--loading": props.loading
        }]
      }, [
        h("div", {
          class: "vxe-pager--wrapper"
        }, childNodes)
      ]);
    };
    $xePager.renderVN = renderVN;
    return $xePager;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/pager/index.js
var VxePager = Object.assign(pager_default, {
  install: function(app) {
    app.component(pager_default.name, pager_default);
  }
});
dynamicApp.use(VxePager);
VxeUI.component(pager_default);
var Pager = VxePager;
var pager_default2 = VxePager;

// node_modules/vxe-pc-ui/es/password-input/src/password-input.js
var import_xe_utils71 = __toESM(require_xe_utils());
var password_input_default = defineVxeComponent({
  name: "VxePasswordInput",
  props: {
    modelValue: String,
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    clearable: {
      type: Boolean,
      default: () => getConfig().passwordInput.clearable
    },
    readonly: Boolean,
    disabled: Boolean,
    maxLength: [String, Number],
    placeholder: String,
    autoComplete: {
      type: String,
      default: "off"
    },
    className: String,
    size: {
      type: String,
      default: () => getConfig().passwordInput.size || getConfig().size
    },
    prefixIcon: String,
    suffixIcon: String,
    controls: {
      type: Boolean,
      default: () => getConfig().passwordInput.controls
    },
    // 已废弃
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "click",
    "focus",
    "blur",
    "clear",
    "lazy-change",
    "toggle-visible",
    "prefix-click",
    "suffix-click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils71.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      showPwd: false,
      isActivated: false,
      inputValue: props.modelValue
    });
    const refElem = ref();
    const refInputTarget = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xePasswordInput = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let passwordInputMethods = {};
    const computeIsClearable = computed(() => {
      return props.clearable;
    });
    const computeInpReadonly = computed(() => {
      const { readonly } = props;
      return readonly;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().passwordInput.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseInput");
    });
    const computeInputType = computed(() => {
      const { showPwd } = reactData;
      if (showPwd) {
        return "text";
      }
      return "password";
    });
    const computeInpImmediate = computed(() => {
      const { immediate } = props;
      return immediate;
    });
    const triggerEvent = (evnt) => {
      const { inputValue } = reactData;
      passwordInputMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const emitInputEvent = (value, evnt) => {
      const inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (inpImmediate) {
        handleChange(value, evnt);
      } else {
        passwordInputMethods.dispatchEvent("input", { value }, evnt);
      }
    };
    const inputEvent = (evnt) => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      passwordInputMethods.dispatchEvent("input", { value }, evnt);
      if (import_xe_utils71.default.toValueString(props.modelValue) !== value) {
        passwordInputMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const changeEvent = (evnt) => {
      triggerEvent(evnt);
      $xePasswordInput.dispatchEvent("lazy-change", { value: reactData.inputValue }, evnt);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, reactData.inputValue);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      triggerEvent(evnt);
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      const value = inputValue;
      $xePasswordInput.dispatchEvent("blur", { value }, evnt);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const passwordToggleEvent = (evnt) => {
      const { readonly, disabled } = props;
      const { showPwd } = reactData;
      if (!disabled && !readonly) {
        reactData.showPwd = !showPwd;
      }
      $xePasswordInput.dispatchEvent("toggle-visible", { visible: reactData.showPwd }, evnt);
    };
    const clickEvent = (evnt) => {
      triggerEvent(evnt);
    };
    const clearValueEvent = (evnt, value) => {
      focus();
      handleChange("", evnt);
      $xePasswordInput.dispatchEvent("clear", { value }, evnt);
      $xePasswordInput.dispatchEvent("lazy-change", { value: reactData.inputValue }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const { disabled } = props;
      if (!disabled) {
        const { inputValue } = reactData;
        $xePasswordInput.dispatchEvent("suffix-click", { value: inputValue }, evnt);
      }
    };
    const clickPrefixEvent = (evnt) => {
      const { disabled } = props;
      if (!disabled) {
        const { inputValue } = reactData;
        $xePasswordInput.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    const renderPasswordIcon = () => {
      const { showPwd } = reactData;
      return h("div", {
        class: "vxe-password-input--control-icon",
        onClick: passwordToggleEvent
      }, [
        h("i", {
          class: ["vxe-password-input--password-icon", showPwd ? getIcon().PASSWORD_INPUT_SHOW_PWD : getIcon().PASSWORD_INPUT_HIDE_PWD]
        })
      ]);
    };
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "vxe-password-input--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "vxe-password-input--prefix-icon"
        }, prefixSlot ? getSlotVNs2(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : null;
    };
    const renderSuffixIcon2 = () => {
      const { disabled, suffixIcon, controls } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isClearable = computeIsClearable.value;
      return isClearable || controls || suffixSlot || suffixIcon ? h("div", {
        class: ["vxe-password-input--suffix", {
          "is--clear": isClearable && !disabled && !(inputValue === "" || import_xe_utils71.default.eqNull(inputValue))
        }]
      }, [
        isClearable ? h("div", {
          class: "vxe-password-input--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : renderEmptyElement($xePasswordInput),
        controls ? renderPasswordIcon() : renderEmptyElement($xePasswordInput),
        suffixSlot || suffixIcon ? h("div", {
          class: "vxe-password-input--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs2(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : renderEmptyElement($xePasswordInput)
      ]) : null;
    };
    passwordInputMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $passwordInput: $xePasswordInput }, params));
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xePasswordInput, passwordInputMethods);
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
    });
    const renderVN = () => {
      const { className, name, disabled, readonly, autocomplete, autoComplete, maxLength } = props;
      const { inputValue, isActivated } = reactData;
      const vSize = computeSize.value;
      const inpReadonly = computeInpReadonly.value;
      const inputType = computeInputType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon2();
      const suffix = renderSuffixIcon2();
      return h("div", {
        ref: refElem,
        class: ["vxe-password-input", className, {
          [`size--${vSize}`]: vSize,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--readonly": readonly,
          "is--disabled": disabled,
          "is--active": isActivated,
          "show--clear": isClearable && !disabled && !(inputValue === "" || import_xe_utils71.default.eqNull(inputValue))
        }],
        spellcheck: false
      }, [
        prefix || renderEmptyElement($xePasswordInput),
        h("div", {
          class: "vxe-password-input--wrapper"
        }, [
          h("input", {
            ref: refInputTarget,
            class: "vxe-password-input--inner",
            value: inputValue,
            name,
            type: inputType,
            placeholder: inpPlaceholder,
            readonly: inpReadonly,
            disabled,
            autocomplete: autocomplete || autoComplete,
            maxlength: maxLength,
            onClick: clickEvent,
            onInput: inputEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        suffix || renderEmptyElement($xePasswordInput)
      ]);
    };
    $xePasswordInput.renderVN = renderVN;
    return $xePasswordInput;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/password-input/index.js
var VxePasswordInput = Object.assign({}, password_input_default, {
  install(app) {
    app.component(password_input_default.name, password_input_default);
  }
});
dynamicApp.use(VxePasswordInput);
VxeUI.component(password_input_default);
var PasswordInput = VxePasswordInput;
var password_input_default2 = VxePasswordInput;

// node_modules/vxe-pc-ui/es/print/src/page-break.js
var import_xe_utils73 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/print/src/util.js
var import_xe_utils72 = __toESM(require_xe_utils());
var browseObj = import_xe_utils72.default.browse();
var printFrame;
var defaultHtmlStyle = 'body{padding:0;font-family:"Microsoft YaHei",微软雅黑,"MicrosoftJhengHei",华文细黑,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function trimHtml(html) {
  return `${html}`.replace(/(<!---->)/, "");
}
function createPrintFrame() {
  const frame = document.createElement("iframe");
  frame.className = "vxe-table--print-frame";
  return frame;
}
function appendPrintFrame() {
  if (!printFrame.parentNode) {
    document.body.appendChild(printFrame);
  }
}
function afterPrintEvent() {
  requestAnimationFrame(removeFrame);
}
function removeFrame() {
  if (printFrame) {
    if (printFrame.parentNode) {
      try {
        printFrame.contentDocument.write("");
      } catch (e) {
      }
      printFrame.parentNode.removeChild(printFrame);
    }
    printFrame = null;
  }
}
function getExportBlobByString(str, type) {
  return new Blob([str], { type: `text/${type};charset=utf-8;` });
}
var defaultPrintMargin = 50;
var defaultFontColor = "#000000";
function parsePageStyle(val) {
  const styOpts = Object.assign({}, val);
  const headStyOpts = Object.assign({}, styOpts.header);
  const titStyOpts = Object.assign({}, styOpts.title);
  const footStyOpts = Object.assign({}, styOpts.footer);
  const pnStyOpts = Object.assign({}, styOpts.pageNumber);
  let mVal = defaultPrintMargin;
  let marginTop = mVal;
  let marginBottom = mVal;
  let marginLeft = mVal;
  let marginRight = mVal;
  if (import_xe_utils72.default.isNumber(styOpts.margin) || import_xe_utils72.default.isString(styOpts.margin)) {
    mVal = styOpts.margin;
    marginTop = mVal;
    marginBottom = mVal;
    marginLeft = mVal;
    marginRight = mVal;
  }
  return {
    marginTop: toCssUnit(styOpts.marginTop || marginTop),
    marginBottom: toCssUnit(styOpts.marginBottom || marginBottom),
    marginLeft: toCssUnit(styOpts.marginLeft || marginLeft),
    marginRight: toCssUnit(styOpts.marginRight || marginRight),
    fontSize: toCssUnit(styOpts.fontSize),
    color: styOpts.color,
    textAlign: styOpts.textAlign,
    header: {
      height: toCssUnit(headStyOpts.height),
      textAlign: headStyOpts.textAlign
    },
    title: {
      color: titStyOpts.color,
      fontSize: toCssUnit(titStyOpts.fontSize),
      textAlign: titStyOpts.textAlign
    },
    footer: {
      height: toCssUnit(footStyOpts.height),
      textAlign: footStyOpts.textAlign
    },
    pageNumber: {
      color: pnStyOpts.color,
      fontSize: toCssUnit(pnStyOpts.fontSize),
      textAlign: pnStyOpts.textAlign
    }
  };
}
function createHtmlPage(opts, printHtml2) {
  const { pageStyle, customStyle } = opts;
  const pageStyObj = parsePageStyle(pageStyle);
  const headStyOpts = pageStyObj.header;
  const titStyOpts = pageStyObj.title;
  const footStyOpts = pageStyObj.header;
  const pnStyOpts = pageStyObj.pageNumber;
  const isPbMode = opts._pageBreaks || opts.pageBreaks && opts.pageBreaks.length;
  return [
    "<!DOCTYPE html><html>",
    "<head>",
    '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">',
    `<title>${opts.title || ""}</title>`,
    `<style media="print">@page{size:auto;${isPbMode ? "margin: 0mm;" : ""}}</style>`,
    `<style>body{font-size:${pageStyObj.fontSize || "14px"};color:${pageStyObj.color || defaultFontColor};text-align:${pageStyObj.textAlign || "left"};}</style>`,
    "<style>",
    ".vxe-print-slots{display:none;}",
    ".vxe-print-page-break.align--center{text-align:center;}",
    ".vxe-print-page-break.align--left{text-align:left;}",
    ".vxe-print-page-break.align--right{text-align:right;}",
    ".vxe-print-page-break{break-before:always;page-break-before:always;display:flex;flex-direction:column;height:100vh;overflow:hidden;}",
    ".vxe-print-page-break--body{display:flex;flex-direction:row;flex-grow:1;overflow:hidden;}",
    ".vxe-print-page-break--left,.vxe-print-page-break--right{flex-shrink:0;height:100%;}",
    `.vxe-print-page-break--left{width:${pageStyObj.marginLeft};}`,
    `.vxe-print-page-break--right{width:${pageStyObj.marginRight};}`,
    ".vxe-print-page-break--header,.vxe-print-page-break--footer{display:flex;justify-content:center;flex-direction:column;flex-shrink:0;width:100%;}",
    `.vxe-print-page-break--header{height:${headStyOpts.height || pageStyObj.marginTop};padding:0 ${pageStyObj.marginLeft} 0 ${pageStyObj.marginRight};text-align:${headStyOpts.textAlign || "left"};}`,
    `.vxe-print-page-break--header-title{font-size:${titStyOpts.fontSize || "1.6em"};color:${titStyOpts.color || defaultFontColor};text-align:${opts.headerAlign || pnStyOpts.textAlign || "center"};}`,
    `.vxe-print-page-break--footer{height:${footStyOpts.height || pageStyObj.marginBottom};padding:0 ${pageStyObj.marginLeft} 0 ${pageStyObj.marginRight};text-align:${footStyOpts.textAlign || "left"};}`,
    ".vxe-print-page-break--content{flex-grow:1;overflow:hidden;}",
    `.vxe-print-page-break--footer-page-number{font-size:${pnStyOpts.fontSize || "1.2em"};color:${pnStyOpts.color || defaultFontColor};text-align:${opts.footerAlign || pnStyOpts.textAlign || "center"};}`,
    "</style>",
    "<style>.vxe-table{white-space:pre;}</style>",
    `<style>${defaultHtmlStyle}</style>`,
    isPbMode ? "<style>body{margin:0;}</style>" : "",
    customStyle ? `<style>${customStyle}</style>` : "",
    "</head>",
    "<body>",
    `${printHtml2}`,
    "</body>",
    "</html>"
  ].join("");
}
function handlePrint(opts, printHtml2 = "") {
  const { beforeMethod } = opts;
  if (beforeMethod) {
    printHtml2 = beforeMethod({ content: printHtml2, html: printHtml2, options: opts }) || "";
  }
  printHtml2 = createHtmlPage(opts, printHtml2);
  const blob = getExportBlobByString(printHtml2, "html");
  return new Promise((resolve) => {
    if (browseObj.msie) {
      removeFrame();
      printFrame = createPrintFrame();
      appendPrintFrame();
      const contentDocument = printFrame.contentDocument;
      if (contentDocument) {
        contentDocument.write(printHtml2);
        contentDocument.execCommand("print");
      }
      setTimeout(() => {
        resolve({
          status: true
        });
      }, 300);
    } else {
      if (!printFrame) {
        printFrame = createPrintFrame();
        printFrame.onload = (evnt) => {
          const frameEl = evnt.target;
          if (frameEl.src) {
            try {
              const contentWindow = frameEl.contentWindow;
              if (contentWindow) {
                contentWindow.onafterprint = afterPrintEvent;
                contentWindow.print();
              }
            } catch (e) {
            }
          }
          resolve({
            status: true
          });
        };
        printFrame.onerror = () => {
          resolve({
            status: false
          });
        };
      }
      appendPrintFrame();
      printFrame.src = URL.createObjectURL(blob);
    }
  });
}
function createPageBreak(opts) {
  const { title, showPageNumber, align, headerAlign, footerAlign, showAllPageTitle } = opts;
  const pageBreaks = opts.pageBreaks || [];
  const pageCount = pageBreaks.length;
  return pageBreaks.map((item, index) => {
    const bodyHtml = item.bodyHtml;
    const headerHtml = item.headerHtml || opts.headerHtml;
    const footerHtml = item.footerHtml || opts.footerHtml;
    const leftHtml = item.leftHtml || opts.leftHtml;
    const rightHtml = item.rightHtml || opts.rightHtml;
    const currentPage = index + 1;
    const params = {
      currentPage,
      pageCount
    };
    return [
      `<div class="${["vxe-print-page-break", align ? `align--${align}` : ""].join(" ")}">`,
      `<div class="${["vxe-print-page-break--header", headerAlign ? `align--${headerAlign}` : ""].join(" ")}">`,
      headerHtml ? `${import_xe_utils72.default.isFunction(headerHtml) ? headerHtml(params) : headerHtml || ""}` : title && (showAllPageTitle || !index) ? `<div class="vxe-print-page-break--header-title">${title || ""}</div>` : "",
      "</div>",
      '<div class="vxe-print-page-break--body">',
      `<div class="vxe-print-page-break--left">${import_xe_utils72.default.isFunction(leftHtml) ? leftHtml(params) : leftHtml || ""}</div>`,
      `<div class="vxe-print-page-break--content">${import_xe_utils72.default.isFunction(bodyHtml) ? bodyHtml(params) : bodyHtml || ""}</div>`,
      `<div class="vxe-print-page-break--right">${import_xe_utils72.default.isFunction(rightHtml) ? rightHtml(params) : rightHtml || ""}</div>`,
      "</div>",
      `<div class="${["vxe-print-page-break--footer", footerAlign ? `align--${footerAlign}` : ""].join(" ")}">`,
      footerHtml ? `${import_xe_utils72.default.isFunction(footerHtml) ? footerHtml(params) : footerHtml || ""}` : showPageNumber ? `<div class="vxe-print-page-break--footer-page-number">${currentPage}/${pageCount}</div>` : "",
      "</div>",
      "</div>"
    ].join("");
  }).join("");
}
var printHtml = (options) => {
  const opts = Object.assign({ _pageBreaks: false, customLayout: true }, options);
  if (opts.sheetName) {
    opts.title = opts.title || opts.sheetName;
  }
  if (opts.style) {
    opts.customStyle = opts.customStyle || opts.style;
  }
  if (opts.beforePrintMethod) {
    opts.beforeMethod = opts.beforeMethod || opts.beforePrintMethod;
  }
  if (opts.pageBreaks && opts.pageBreaks.length) {
    return handlePrint(opts, createPageBreak(opts));
  }
  const printHtml2 = opts.html || opts.content;
  return handlePrint(opts, printHtml2);
};
function assemblePageBreak($xePageBreak, elem, pageBreakConfig) {
  const staticPageBreaks = $xePageBreak.reactData.staticPageBreaks;
  const parentElem = elem.parentNode;
  if (parentElem && staticPageBreaks) {
    staticPageBreaks.splice(import_xe_utils72.default.arrayIndexOf(parentElem.children, elem), 0, pageBreakConfig);
    $xePageBreak.reactData.staticPageBreaks = staticPageBreaks.slice(0);
  }
}
function destroyPageBreak($xePageBreak, pageBreakConfig) {
  $xePageBreak.reactData.staticPageBreaks = $xePageBreak.reactData.staticPageBreaks.filter((item) => item.id !== pageBreakConfig.id);
}

// node_modules/vxe-pc-ui/es/print/src/page-break.js
var page_break_default = defineVxeComponent({
  name: "VxePrintPageBreak",
  props: {},
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils73.default.uniqueId();
    const $xePrint = inject("$xePrint", null);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const pageBreakConfig = reactive({
      id: xID,
      slots
    });
    const $xePrintPageBreak = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $print: $xePrint }, params));
    };
    const printPageBreakMethods = {
      dispatchEvent
    };
    const printPageBreakPrivateMethods = {};
    Object.assign($xePrintPageBreak, printPageBreakMethods, printPageBreakPrivateMethods);
    if (!$xePrint) {
      $xePrintPageBreak.renderVN = () => {
        return createCommentVNode();
      };
      return $xePrintPageBreak;
    }
    const renderVN = () => {
      return h("div", {
        ref: refElem
      });
    };
    onMounted(() => {
      const elem = refElem.value;
      if ($xePrint && elem) {
        assemblePageBreak($xePrint, elem, pageBreakConfig);
      }
    });
    onUnmounted(() => {
      if ($xePrint) {
        destroyPageBreak($xePrint, pageBreakConfig);
      }
    });
    $xePrintPageBreak.renderVN = renderVN;
    return $xePrintPageBreak;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/print-page-break/index.js
var VxePrintPageBreak = Object.assign({}, page_break_default, {
  install(app) {
    app.component(page_break_default.name, page_break_default);
  }
});
dynamicApp.use(VxePrintPageBreak);
VxeUI.component(page_break_default);
var PrintPageBreak = VxePrintPageBreak;
var print_page_break_default = VxePrintPageBreak;

// node_modules/vxe-pc-ui/es/print/src/print.js
var import_xe_utils74 = __toESM(require_xe_utils());
var print_default = defineVxeComponent({
  name: "VxePrint",
  props: {
    align: {
      type: String,
      default: () => getConfig().print.align
    },
    title: String,
    headerAlign: {
      type: String,
      default: () => getConfig().print.headerAlign
    },
    footerAlign: {
      type: String,
      default: () => getConfig().print.footerAlign
    },
    showPageNumber: {
      type: Boolean,
      default: () => getConfig().print.showPageNumber
    },
    customLayout: Boolean,
    pageBreaks: Array,
    content: String,
    html: String,
    headerHtml: String,
    footerHtml: String,
    leftHtml: String,
    rightHtml: String,
    showAllPageTitle: {
      type: Boolean,
      default: () => getConfig().print.showAllPageTitle
    },
    pageStyle: {
      type: Object,
      default: () => getConfig().print.pageStyle
    },
    customStyle: {
      type: String,
      default: () => getConfig().print.customStyle
    },
    beforeMethod: Function
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils74.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({
      staticPageBreaks: []
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xePrint = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $print: $xePrint }, params));
    };
    const printMethods = {
      dispatchEvent,
      print() {
        const elem = refElem.value;
        return printHtml(Object.assign({}, props, {
          _pageBreaks: !!reactData.staticPageBreaks.length,
          html: trimHtml(elem ? elem.outerHTML : "") || props.html || props.content || ""
        }));
      }
    };
    const printPrivateMethods = {};
    Object.assign($xePrint, printMethods, printPrivateMethods);
    const renderPageConfigLayouts = () => {
      const { title, showPageNumber, showAllPageTitle, align, headerAlign, footerAlign } = props;
      const pageBreaks = props.pageBreaks || [];
      const pageCount = pageBreaks.length;
      return pageBreaks.map((item, index) => {
        const bodyHtml = item.bodyHtml;
        const headerHtml = item.headerHtml || props.headerHtml;
        const footerHtml = item.footerHtml || props.footerHtml;
        const leftHtml = item.leftHtml || props.leftHtml;
        const rightHtml = item.rightHtml || props.rightHtml;
        const currentPage = index + 1;
        const params = {
          currentPage,
          pageCount
        };
        return h("div", {
          class: ["vxe-print-page-break", align ? `align--${align}` : ""]
        }, [
          h("div", {
            class: ["vxe-print-page-break--header", headerAlign ? `align--${headerAlign}` : ""]
          }, headerHtml ? `${import_xe_utils74.default.isFunction(headerHtml) ? headerHtml(params) : headerHtml || ""}` : [
            title && (showAllPageTitle || !index) ? h("div", {
              class: "vxe-print-page-break--header-title"
            }, `${title || ""}`) : renderEmptyElement($xePrint)
          ]),
          h("div", {
            class: "vxe-print-page-break--body"
          }, [
            h("div", {
              class: "vxe-print-page-break--left"
            }, `${import_xe_utils74.default.isFunction(leftHtml) ? leftHtml(params) : leftHtml || ""}`),
            h("div", {
              class: "vxe-print-page-break--content"
            }, `${import_xe_utils74.default.isFunction(bodyHtml) ? bodyHtml(params) : bodyHtml || ""}`),
            h("div", {
              class: "vxe-print-page-break--right"
            }, `${import_xe_utils74.default.isFunction(rightHtml) ? rightHtml(params) : rightHtml || ""}`)
          ]),
          h("div", {
            class: ["vxe-print-page-break--footer", footerAlign ? `align--${footerAlign}` : ""]
          }, footerHtml ? `${import_xe_utils74.default.isFunction(footerHtml) ? footerHtml(params) : footerHtml || ""}` : [
            showPageNumber ? h("div", {
              class: "vxe-print-page-break--footer-page-number"
            }, `${currentPage}/${pageCount}`) : renderEmptyElement($xePrint)
          ])
        ]);
      });
    };
    const renderPageStaticLayouts = () => {
      const { title, showPageNumber, showAllPageTitle, align, headerAlign, footerAlign } = props;
      const { staticPageBreaks } = reactData;
      const pageCount = staticPageBreaks.length;
      return staticPageBreaks.map((item, index) => {
        const itemSlots = item.slots || {};
        const currentPage = index + 1;
        const defaultSlot = itemSlots.default;
        const headerSlot = itemSlots.header || slots.header;
        const footerSlot = itemSlots.footer || slots.footer;
        const leftSlot = itemSlots.left || slots.left;
        const rightSlot = itemSlots.right || slots.right;
        const params = {
          currentPage,
          pageCount
        };
        return h("div", {
          class: ["vxe-print-page-break", align ? `align--${align}` : ""]
        }, [
          h("div", {
            class: ["vxe-print-page-break--header", headerAlign ? `align--${headerAlign}` : ""]
          }, headerSlot ? getSlotVNs2(headerSlot(params)) : [
            title && (showAllPageTitle || !index) ? h("div", {
              class: "vxe-print-page-break--header-title"
            }, `${title || ""}`) : renderEmptyElement($xePrint)
          ]),
          h("div", {
            class: "vxe-print-page-break--body"
          }, [
            h("div", {
              class: "vxe-print-page-break--left"
            }, leftSlot ? getSlotVNs2(leftSlot(params)) : []),
            h("div", {
              class: "vxe-print-page-break--content"
            }, defaultSlot ? getSlotVNs2(defaultSlot(params)) : []),
            h("div", {
              class: "vxe-print-page-break--right"
            }, rightSlot ? getSlotVNs2(rightSlot(params)) : [])
          ]),
          h("div", {
            class: ["vxe-print-page-break--footer", footerAlign ? `align--${footerAlign}` : ""]
          }, footerSlot ? getSlotVNs2(footerSlot(params)) : [
            showPageNumber ? h("div", {
              class: "vxe-print-page-break--footer-page-number"
            }, `${currentPage}/${pageCount}`) : renderEmptyElement($xePrint)
          ])
        ]);
      });
    };
    const renderVN = () => {
      const { customLayout } = props;
      const { staticPageBreaks } = reactData;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-print"]
      }, customLayout ? defaultSlot ? getSlotVNs2(defaultSlot({})) : [] : [
        h("div", {
          key: "slot",
          class: "vxe-print-slots"
        }, defaultSlot ? getSlotVNs2(defaultSlot({})) : [])
      ].concat(staticPageBreaks.length ? renderPageStaticLayouts() : renderPageConfigLayouts()));
    };
    $xePrint.renderVN = renderVN;
    provide("$xePrint", $xePrint);
    return $xePrint;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/print/index.js
var VxePrint = Object.assign({}, print_default, {
  install(app) {
    app.component(print_default.name, print_default);
  }
});
dynamicApp.use(VxePrint);
VxeUI.component(print_default);
VxeUI.print = printHtml;
var Print = VxePrint;
var print_default2 = VxePrint;

// node_modules/vxe-pc-ui/es/pulldown/src/pulldown.js
var import_xe_utils75 = __toESM(require_xe_utils());
var pulldown_default = defineVxeComponent({
  name: "VxePulldown",
  props: {
    modelValue: Boolean,
    disabled: Boolean,
    placement: String,
    trigger: {
      type: String,
      default: getConfig().pulldown.trigger
    },
    zIndex: Number,
    size: {
      type: String,
      default: () => getConfig().pulldown.size || getConfig().size
    },
    options: Array,
    className: {
      type: [String, Function],
      default: getConfig().pulldown.className
    },
    popupClassName: [String, Function],
    showPopupShadow: Boolean,
    destroyOnClose: {
      type: Boolean,
      default: getConfig().pulldown.destroyOnClose
    },
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "click",
    "option-click",
    "show-panel",
    "hide-panel",
    "visible-change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const xID = import_xe_utils75.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      hpTimeout: void 0
    };
    const refElem = ref();
    const refPulldownContent = ref();
    const refPulldownPanel = ref();
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().pulldown.transfer;
        if (import_xe_utils75.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const refMaps = {
      refElem
    };
    const $xePulldown = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let pulldownMethods = {};
    const updateZindex = () => {
      const { zIndex } = props;
      if (zIndex) {
        reactData.panelIndex = zIndex;
      } else if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const isPanelVisible = () => {
      return reactData.visiblePanel;
    };
    const updatePlacement = () => {
      const { placement } = props;
      const { panelIndex } = reactData;
      const targetElem = refPulldownContent.value;
      const panelElem = refPulldownPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return nextTick().then(handleStyle);
    };
    const showPanel = () => {
      if (!reactData.initialized) {
        reactData.initialized = true;
      }
      return new Promise((resolve) => {
        if (!props.disabled) {
          if (internalData.hpTimeout) {
            clearTimeout(internalData.hpTimeout);
          }
          reactData.isActivated = true;
          reactData.isAniVisible = true;
          setTimeout(() => {
            reactData.visiblePanel = true;
            emit("update:modelValue", true);
            updatePlacement();
            setTimeout(() => {
              resolve(updatePlacement());
            }, 40);
          }, 10);
          updateZindex();
          dispatchEvent("visible-change", { visible: true }, null);
        } else {
          nextTick(() => {
            resolve();
          });
        }
      });
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      dispatchEvent("visible-change", { visible: false }, null);
      emit("update:modelValue", false);
      return new Promise((resolve) => {
        if (reactData.isAniVisible) {
          internalData.hpTimeout = setTimeout(() => {
            reactData.isAniVisible = false;
            nextTick(() => {
              resolve();
            });
          }, 350);
        } else {
          nextTick(() => {
            resolve();
          });
        }
      });
    };
    const togglePanel = () => {
      if (reactData.visiblePanel) {
        return hideOptionPanel();
      }
      return showPanel();
    };
    const handleOptionEvent = (evnt, option) => {
      if (!option.disabled) {
        if (reactData.visiblePanel) {
          hideOptionPanel();
          dispatchEvent("hide-panel", {}, evnt);
        }
        dispatchEvent("option-click", { option }, evnt);
      }
    };
    const clickTargetEvent = (evnt) => {
      const { trigger } = props;
      if (trigger === "click") {
        if (reactData.visiblePanel) {
          hideOptionPanel();
          dispatchEvent("hide-panel", {}, evnt);
        } else {
          showPanel();
          dispatchEvent("show-panel", {}, evnt);
        }
      }
      dispatchEvent("click", { $pulldown: $xePulldown }, evnt);
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      const panelElem = refPulldownPanel.value;
      if (!disabled) {
        if (visiblePanel) {
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
            dispatchEvent("hide-panel", {}, evnt);
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      const el = refElem.value;
      const panelElem = refPulldownPanel.value;
      if (!disabled) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
          dispatchEvent("hide-panel", {}, evnt);
        }
      }
    };
    const handleGlobalBlurEvent = (evnt) => {
      const { visiblePanel, isActivated } = reactData;
      if (visiblePanel) {
        hideOptionPanel();
        dispatchEvent("hide-panel", {}, evnt);
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
    };
    const handleGlobalResizeEvent = () => {
      const { visiblePanel } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $pulldown: $xePulldown }, params));
    };
    pulldownMethods = {
      dispatchEvent,
      isPanelVisible,
      togglePanel,
      showPanel,
      hidePanel: hideOptionPanel
    };
    Object.assign($xePulldown, pulldownMethods);
    watch(() => props.modelValue, (value) => {
      reactData.isActivated = !!value;
      if (value) {
        showPanel();
      } else {
        hideOptionPanel();
      }
    });
    nextTick(() => {
      if (props.modelValue) {
        showPanel();
      }
      globalEvents.on($xePulldown, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xePulldown, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xePulldown, "blur", handleGlobalBlurEvent);
      globalEvents.on($xePulldown, "resize", handleGlobalResizeEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xePulldown, "mousewheel");
      globalEvents.off($xePulldown, "mousedown");
      globalEvents.off($xePulldown, "blur");
      globalEvents.off($xePulldown, "resize");
    });
    const renderDefaultPanel = (options) => {
      const optionSlot = slots.option;
      return h("div", {
        class: "vxe-pulldown--panel-list"
      }, options ? options.map((item) => {
        return h("div", {
          class: "vxe-pulldown--panel-item",
          onClick(evnt) {
            handleOptionEvent(evnt, item);
          }
        }, optionSlot ? optionSlot({ $pulldown: $xePulldown, option: item }) : `${item.label || ""}`);
      }) : []);
    };
    const renderVN = () => {
      const { className, options, popupClassName, showPopupShadow, destroyOnClose, disabled } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel, panelStyle, panelPlacement } = reactData;
      const btnTransfer = computeBtnTransfer.value;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const dropdownSlot = slots.dropdown;
      return h("div", {
        ref: refElem,
        class: ["vxe-pulldown", className ? import_xe_utils75.default.isFunction(className) ? className({ $pulldown: $xePulldown }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visible": visiblePanel,
          "is--disabled": disabled,
          "is--active": isActivated
        }]
      }, [
        h("div", {
          ref: refPulldownContent,
          class: "vxe-pulldown--content",
          onClick: clickTargetEvent
        }, defaultSlot ? defaultSlot({ $pulldown: $xePulldown }) : []),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refPulldownPanel,
            class: ["vxe-table--ignore-clear vxe-pulldown--panel", popupClassName ? import_xe_utils75.default.isFunction(popupClassName) ? popupClassName({ $pulldown: $xePulldown }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }],
            placement: panelPlacement,
            style: panelStyle
          }, [
            h("div", {
              class: ["vxe-pulldown--panel-wrapper", {
                "is--shadow": showPopupShadow
              }]
            }, initialized && (destroyOnClose ? visiblePanel || isAniVisible : true) ? [
              headerSlot ? h("div", {
                class: "vxe-pulldown--panel-header"
              }, headerSlot({ $pulldown: $xePulldown })) : renderEmptyElement($xePulldown),
              h("div", {
                class: "vxe-pulldown--panel-body"
              }, dropdownSlot ? dropdownSlot({ $pulldown: $xePulldown }) : [
                renderDefaultPanel(options)
              ]),
              footerSlot ? h("div", {
                class: "vxe-pulldown--panel-footer"
              }, footerSlot({ $pulldown: $xePulldown })) : renderEmptyElement($xePulldown)
            ] : [])
          ])
        ])
      ]);
    };
    $xePulldown.renderVN = renderVN;
    return $xePulldown;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/pulldown/index.js
var VxePulldown = Object.assign(pulldown_default, {
  install: function(app) {
    app.component(pulldown_default.name, pulldown_default);
  }
});
dynamicApp.use(VxePulldown);
VxeUI.component(pulldown_default);
var Pulldown = VxePulldown;
var pulldown_default2 = VxePulldown;

// node_modules/vxe-pc-ui/es/radio/src/radio.js
var import_xe_utils76 = __toESM(require_xe_utils());
var radio_default = defineVxeComponent({
  name: "VxeRadio",
  props: {
    modelValue: [String, Number, Boolean],
    checkedValue: {
      type: [String, Number, Boolean],
      default: void 0
    },
    title: [String, Number],
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    name: String,
    strict: {
      type: Boolean,
      default: () => getConfig().radio.strict
    },
    size: {
      type: String,
      default: () => getConfig().radio.size || getConfig().size
    },
    /**
     * 已废弃，被 checkedValue 替换
     */
    label: {
      type: [String, Number, Boolean],
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const $xeRadioGroup = inject("$xeRadioGroup", null);
    const xID = import_xe_utils76.default.uniqueId();
    const reactData = reactive({});
    const $xeRadio = {
      xID,
      props,
      context,
      reactData
    };
    const { computeSize } = useSize(props);
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeRadioGroup) {
          const { computeIsDisabled: computeIsDisabled2 } = $xeRadioGroup.getComputeMaps();
          return computeIsDisabled2.value;
        }
      }
      return disabled;
    });
    const computeName = computed(() => {
      return $xeRadioGroup ? $xeRadioGroup.name : props.name;
    });
    const computeStrict = computed(() => {
      return $xeRadioGroup ? $xeRadioGroup.props.strict : props.strict;
    });
    const computeChecked = computed(() => {
      const { label, checkedValue } = props;
      const radioValue = import_xe_utils76.default.isUndefined(checkedValue) ? label : checkedValue;
      return $xeRadioGroup ? $xeRadioGroup.props.modelValue === radioValue : props.modelValue === radioValue;
    });
    const handleValue = (checkedValue, evnt) => {
      if ($xeRadioGroup) {
        $xeRadioGroup.handleChecked({ label: checkedValue, checkedValue }, evnt);
      } else {
        emit("update:modelValue", checkedValue);
        dispatchEvent("change", { value: checkedValue, label: checkedValue, checkedValue }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, checkedValue);
        }
      }
    };
    const changeEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { label, checkedValue } = props;
        const radioValue = import_xe_utils76.default.isUndefined(checkedValue) ? label : checkedValue;
        handleValue(radioValue, evnt);
      }
    };
    const clickEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        const { label, checkedValue } = props;
        const radioValue = import_xe_utils76.default.isUndefined(checkedValue) ? label : checkedValue;
        if (radioValue === ($xeRadioGroup ? $xeRadioGroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $radio: $xeRadio }, params));
    };
    const radioMethods = {
      dispatchEvent
    };
    const radioPrivateMethods = {};
    Object.assign($xeRadio, radioMethods, radioPrivateMethods);
    const renderVN = () => {
      const { label, checkedValue } = props;
      const radioValue = import_xe_utils76.default.isUndefined(checkedValue) ? label : checkedValue;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const name = computeName.value;
      const isChecked = computeChecked.value;
      return h("label", {
        key: radioValue,
        class: ["vxe-radio vxe-radio--default", {
          [`size--${vSize}`]: vSize,
          "is--checked": isChecked,
          "is--disabled": isDisabled
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-radio--input",
          type: "radio",
          name,
          checked: isChecked,
          disabled: isDisabled,
          onChange: changeEvent,
          onClick: clickEvent
        }),
        h("span", {
          class: ["vxe-radio--icon", isChecked ? getIcon().RADIO_CHECKED : isDisabled ? getIcon().RADIO_DISABLED_UNCHECKED : getIcon().RADIO_UNCHECKED]
        }),
        h("span", {
          class: "vxe-radio--label"
        }, slots.default ? slots.default({}) : getFuncText(props.content))
      ]);
    };
    $xeRadio.renderVN = renderVN;
    return $xeRadio;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/radio/index.js
var VxeRadio = Object.assign(radio_default, {
  install: function(app) {
    app.component(radio_default.name, radio_default);
  }
});
dynamicApp.use(VxeRadio);
VxeUI.component(radio_default);
var Radio = VxeRadio;
var radio_default2 = VxeRadio;

// node_modules/vxe-pc-ui/es/radio/src/button.js
var import_xe_utils77 = __toESM(require_xe_utils());
var button_default4 = defineVxeComponent({
  name: "VxeRadioButton",
  props: {
    modelValue: [String, Number, Boolean],
    checkedValue: {
      type: [String, Number, Boolean],
      default: void 0
    },
    title: [String, Number],
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    strict: {
      type: Boolean,
      default: () => getConfig().radioButton.strict
    },
    size: {
      type: String,
      default: () => getConfig().radioButton.size || getConfig().size
    },
    /**
     * 已废弃，被 checkedValue 替换
     */
    label: {
      type: [String, Number, Boolean],
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const $xeRadioGroup = inject("$xeRadioGroup", null);
    const xID = import_xe_utils77.default.uniqueId();
    const reactData = reactive({});
    const { computeSize } = useSize(props);
    const $xeRadioButton = {
      xID,
      props,
      context,
      reactData
    };
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeRadioGroup) {
          const { computeIsDisabled: computeIsDisabled2 } = $xeRadioGroup.getComputeMaps();
          return computeIsDisabled2.value;
        }
      }
      return disabled;
    });
    const computeName = computed(() => {
      return $xeRadioGroup ? $xeRadioGroup.name : null;
    });
    const computeStrict = computed(() => {
      return $xeRadioGroup ? $xeRadioGroup.props.strict : props.strict;
    });
    const computeChecked = computed(() => {
      const { label, checkedValue } = props;
      const radioValue = import_xe_utils77.default.isUndefined(checkedValue) ? label : checkedValue;
      return $xeRadioGroup ? $xeRadioGroup.props.modelValue === radioValue : props.modelValue === radioValue;
    });
    const radioButtonMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $radioButton: $xeRadioButton }, params));
      }
    };
    const radioButtonPrivateMethods = {};
    Object.assign($xeRadioButton, radioButtonMethods, radioButtonPrivateMethods);
    const handleValue = (checkedValue, evnt) => {
      if ($xeRadioGroup) {
        $xeRadioGroup.handleChecked({ label: checkedValue, checkedValue }, evnt);
      } else {
        emit("update:modelValue", checkedValue);
        radioButtonMethods.dispatchEvent("change", { value: checkedValue, label: checkedValue }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, checkedValue);
        }
      }
    };
    const changeEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { label, checkedValue } = props;
        const radioValue = import_xe_utils77.default.isUndefined(checkedValue) ? label : checkedValue;
        handleValue(radioValue, evnt);
      }
    };
    const clickEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        const { label, checkedValue } = props;
        const radioValue = import_xe_utils77.default.isUndefined(checkedValue) ? label : checkedValue;
        if (radioValue === ($xeRadioGroup ? $xeRadioGroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    const renderVN = () => {
      const { label, checkedValue } = props;
      const radioValue = import_xe_utils77.default.isUndefined(checkedValue) ? label : checkedValue;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const name = computeName.value;
      const isChecked = computeChecked.value;
      return h("label", {
        key: radioValue,
        class: ["vxe-radio vxe-radio--button", {
          [`size--${vSize}`]: vSize,
          "is--disabled": isDisabled
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-radio--input",
          type: "radio",
          name,
          checked: isChecked,
          disabled: isDisabled,
          onChange: changeEvent,
          onClick: clickEvent
        }),
        h("span", {
          class: "vxe-radio--label"
        }, slots.default ? slots.default({}) : getFuncText(props.content))
      ]);
    };
    $xeRadioButton.renderVN = renderVN;
    return renderVN;
  }
});

// node_modules/vxe-pc-ui/es/radio-button/index.js
var VxeRadioButton = Object.assign(button_default4, {
  install: function(app) {
    app.component(button_default4.name, button_default4);
  }
});
dynamicApp.use(VxeRadioButton);
VxeUI.component(button_default4);
var RadioButton = VxeRadioButton;
var radio_button_default = VxeRadioButton;

// node_modules/vxe-pc-ui/es/radio/src/group.js
var import_xe_utils78 = __toESM(require_xe_utils());
var group_default3 = defineVxeComponent({
  name: "VxeRadioGroup",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: {
      type: Boolean,
      default: null
    },
    type: String,
    options: Array,
    optionProps: Object,
    strict: {
      type: Boolean,
      default: () => getConfig().radioGroup.strict
    },
    size: {
      type: String,
      default: () => getConfig().radioGroup.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils78.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeMaps = {
      computeIsDisabled
    };
    const $xeRadioGroup = {
      xID,
      props,
      context,
      reactData,
      name: import_xe_utils78.default.uniqueId("xe_group_"),
      getComputeMaps: () => computeMaps
    };
    const computePropsOpts = computed(() => {
      return Object.assign({}, props.optionProps);
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeDisabledField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || "disabled";
    });
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $radioGroup: $xeRadioGroup }, params));
    };
    const radioGroupMethods = {
      dispatchEvent
    };
    const radioGroupPrivateMethods = {
      handleChecked(params, evnt) {
        const value = params.checkedValue;
        emit("update:modelValue", value);
        dispatchEvent("change", { value, label: value, checkedValue: value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    Object.assign($xeRadioGroup, radioGroupMethods, radioGroupPrivateMethods);
    const renderVN = () => {
      const { options, type } = props;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      const btnComp = type === "button" ? button_default4 : radio_default;
      return h("div", {
        class: ["vxe-radio-group", {
          [`size--${vSize}`]: vSize
        }]
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item) => {
        return h(btnComp, {
          key: item[valueField],
          checkedValue: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    provide("$xeRadioGroup", $xeRadioGroup);
    $xeRadioGroup.renderVN = renderVN;
    return $xeRadioGroup;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/radio-group/index.js
var VxeRadioGroup = Object.assign(group_default3, {
  install: function(app) {
    app.component(group_default3.name, group_default3);
  }
});
dynamicApp.use(VxeRadioGroup);
VxeUI.component(group_default3);
var RadioGroup = VxeRadioGroup;
var radio_group_default = VxeRadioGroup;

// node_modules/vxe-pc-ui/es/rate/src/rate.js
var import_xe_utils79 = __toESM(require_xe_utils());
var rate_default = defineVxeComponent({
  name: "VxeRate",
  props: {
    modelValue: [Number, String],
    disabled: {
      type: Boolean,
      default: null
    },
    readonly: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().rate.size || getConfig().size
    },
    status: String
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils79.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({
      activeValue: null
    });
    const refMaps = {
      refElem
    };
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return readonly;
    });
    const computeNumVal = computed(() => {
      const { modelValue } = props;
      const { activeValue } = reactData;
      return import_xe_utils79.default.toNumber(activeValue === null ? modelValue : activeValue);
    });
    const computeItemList = computed(() => {
      return [1, 2, 3, 4, 5].map((num) => {
        return {
          value: num,
          label: num
        };
      });
    });
    const computeMaps = {};
    const $xeRate = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $rate: $xeRate }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const mouseenterEvent = (evnt, item) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!(isDisabled || isReadonly)) {
        const value = item.value;
        reactData.activeValue = value;
      }
    };
    const mouseleaveEvent = () => {
      reactData.activeValue = null;
    };
    const clickEvent = (evnt, item) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!(isDisabled || isReadonly)) {
        const value = item.value;
        emitModel(value);
        dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    Object.assign($xeRate, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { status } = props;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const itemList = computeItemList.value;
      const vSize = computeSize.value;
      const numVal = computeNumVal.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-rate", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--disabled": isDisabled,
          "is--readonly": isReadonly
        }]
      }, itemList.map((item) => {
        const isChecked = numVal >= item.value;
        return h("div", {
          class: ["vxe-rte--item", {
            "is--checked": isChecked
          }],
          onMouseenter(evnt) {
            if (!(isDisabled || isReadonly)) {
              mouseenterEvent(evnt, item);
            }
          },
          onMouseleave: mouseleaveEvent,
          onClick(evnt) {
            if (!(isDisabled || isReadonly)) {
              clickEvent(evnt, item);
            }
          }
        }, [
          h("i", {
            class: isChecked ? getIcon().RATE_CHECKED : getIcon().RATE_UNCHECKED
          })
        ]);
      }));
    };
    $xeRate.renderVN = renderVN;
    return $xeRate;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/rate/index.js
var VxeRate = Object.assign({}, rate_default, {
  install(app) {
    app.component(rate_default.name, rate_default);
  }
});
dynamicApp.use(VxeRate);
VxeUI.component(rate_default);
var Rate = VxeRate;
var rate_default2 = VxeRate;

// node_modules/vxe-pc-ui/es/result/src/result.js
var import_xe_utils80 = __toESM(require_xe_utils());
var result_default = defineVxeComponent({
  name: "VxeResult",
  props: {
    imageUrl: String,
    imageStyle: Object,
    icon: String,
    type: [String, Number],
    status: [String, Number],
    title: [String, Number],
    content: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils80.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeResult = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $result: $xeResult }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeResult, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { imageUrl, imageStyle, icon, title, type, content } = props;
      const status = props.status || type;
      const slotExtra = slots.extra;
      return h("div", {
        ref: "refElem",
        class: ["vxe-result", {
          [`theme--${status}`]: status
        }]
      }, [
        h("div", {
          class: "vxe-result--inner"
        }, [
          imageUrl ? h("div", {
            class: "vxe-result--img-wrapper"
          }, [
            h("img", {
              src: imageUrl,
              style: imageStyle
            })
          ]) : h("div", {
            class: "vxe-result--icon-wrapper"
          }, [
            h("i", {
              class: [icon, type ? getIcon()[`RESULT_${type}`.toLocaleUpperCase()] : ""]
            })
          ]),
          h("div", {
            class: "vxe-result--title-wrapper"
          }, `${title || ""}`),
          h("div", {
            class: "vxe-result--content-wrapper"
          }, `${content || ""}`),
          slotExtra ? h("div", {
            class: "vxe-result--extra-wrapper"
          }, slotExtra({})) : renderEmptyElement($xeResult)
        ])
      ]);
    };
    $xeResult.renderVN = renderVN;
    return $xeResult;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/result/index.js
var VxeResult = Object.assign({}, result_default, {
  install(app) {
    app.component(result_default.name, result_default);
  }
});
dynamicApp.use(VxeResult);
VxeUI.component(result_default);
var Result = VxeResult;
var result_default2 = VxeResult;

// node_modules/vxe-pc-ui/es/row/src/row.js
var import_xe_utils81 = __toESM(require_xe_utils());
var row_default = defineVxeComponent({
  name: "VxeRow",
  props: {
    gutter: [Number, String, Array],
    wrap: {
      type: Boolean,
      default: () => getConfig().row.wrap
    },
    vertical: Boolean,
    size: {
      type: String,
      default: () => getConfig().row.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils81.default.uniqueId();
    useSize(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeRowStyle = computed(() => {
      const { gutter, vertical } = props;
      const style = {};
      if (gutter) {
        let [lrGutter, tbGutter] = import_xe_utils81.default.isArray(gutter) ? gutter : [gutter];
        if (vertical) {
          tbGutter = lrGutter;
          lrGutter = "";
        }
        if (lrGutter) {
          const offsetSize = import_xe_utils81.default.isNumber(lrGutter) ? toCssUnit(-(lrGutter / 2)) : `calc(${toCssUnit(lrGutter)} / 2 * -1)`;
          style.marginLeft = offsetSize;
          style.marginRight = offsetSize;
        }
        if (tbGutter) {
          const offsetSize = import_xe_utils81.default.isNumber(tbGutter) ? toCssUnit(-(tbGutter / 2)) : `calc(${toCssUnit(tbGutter)} / 2 * -1)`;
          style.marginTop = offsetSize;
          style.marginBottom = offsetSize;
        }
      }
      return style;
    });
    const computeMaps = {};
    const $xeRow = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clickEvent = (evnt) => {
      dispatchEvent("click", {}, evnt);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $row: $xeRow }, params));
    };
    const rowMethods = {
      dispatchEvent
    };
    const rowPrivateMethods = {};
    Object.assign($xeRow, rowMethods, rowPrivateMethods);
    const renderVN = () => {
      const { vertical, wrap } = props;
      const rowStyle = computeRowStyle.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-row", {
          "is--vertical": vertical,
          "is--wrap": wrap
        }],
        style: rowStyle,
        onClick: clickEvent
      }, defaultSlot ? defaultSlot({}) : []);
    };
    provide("$xeRow", $xeRow);
    $xeRow.renderVN = renderVN;
    return $xeRow;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/row/index.js
var VxeRow = Object.assign({}, row_default, {
  install(app) {
    app.component(row_default.name, row_default);
  }
});
dynamicApp.use(VxeRow);
VxeUI.component(row_default);
var Row = VxeRow;
var row_default2 = VxeRow;

// node_modules/vxe-pc-ui/es/select/index.js
var VxeSelect = Object.assign(select_default, {
  install: function(app) {
    app.component(select_default.name, select_default);
  }
});
dynamicApp.use(VxeSelect);
VxeUI.component(select_default);
var Select = VxeSelect;
var select_default2 = VxeSelect;

// node_modules/vxe-pc-ui/es/splitter/src/splitter.js
var import_xe_utils82 = __toESM(require_xe_utils());
var splitter_default = defineVxeComponent({
  name: "VxeSplitter",
  props: {
    width: [Number, String],
    height: [Number, String],
    vertical: {
      type: Boolean,
      default: () => getConfig().splitter.vertical
    },
    border: {
      type: Boolean,
      default: () => getConfig().splitter.border
    },
    padding: {
      type: Boolean,
      default: () => getConfig().splitter.padding
    },
    resize: {
      type: Boolean,
      default: () => getConfig().splitter.resize
    },
    items: Array,
    itemConfig: Object,
    barConfig: Object,
    resizeConfig: Object,
    actionConfig: Object,
    size: {
      type: String,
      default: () => getConfig().splitter.size || getConfig().size
    }
  },
  emits: [
    "action-dblclick",
    "action-click",
    "toggle-expand",
    "resize-start",
    "resize-drag",
    "resize-end"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils82.default.uniqueId();
    const refElem = ref();
    const refBarInfoElem = ref();
    const refResizableSplitterTip = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      staticItems: [],
      itemList: [],
      barWidth: 0,
      barHeight: 0
    });
    const internalData = {
      wrapperWidth: 0,
      wrapperHeight: 0
    };
    const computeItemOpts = computed(() => {
      return Object.assign({}, getConfig().splitter.itemConfig, props.itemConfig);
    });
    const computeBarOpts = computed(() => {
      return Object.assign({}, getConfig().splitter.barConfig, props.barConfig);
    });
    const computeResizeOpts = computed(() => {
      return Object.assign({}, getConfig().splitter.resizeConfig, props.resizeConfig);
    });
    const computeActionOpts = computed(() => {
      return Object.assign({}, getConfig().splitter.actionConfig, props.actionConfig);
    });
    const computeVisibleItems = computed(() => {
      return reactData.itemList.filter((item) => item.isExpand);
    });
    const computeAutoItems = computed(() => {
      const { vertical } = props;
      const autoItems = [];
      let heightCount = 0;
      let widthCount = 0;
      reactData.itemList.forEach(vertical ? (item) => {
        const { renderHeight, resizeHeight, foldHeight, isExpand, height } = item;
        const itemHeight = isExpand ? foldHeight || resizeHeight || renderHeight : 0;
        if (!height) {
          autoItems.push(item);
        }
        heightCount += itemHeight;
      } : (item) => {
        const { renderWidth, resizeWidth, foldWidth, isExpand, width } = item;
        const itemWidth = isExpand ? foldWidth || resizeWidth || renderWidth : 0;
        if (!width) {
          autoItems.push(item);
        }
        widthCount += itemWidth;
      });
      return {
        autoItems,
        heightCount,
        heightRatio: heightCount / 100,
        widthCount,
        widthRatio: widthCount / 100
      };
    });
    const computeBarStyle = computed(() => {
      const barOpts = computeBarOpts.value;
      const { width, height } = barOpts;
      const stys = {};
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (width) {
        stys.width = toCssUnit(width);
      }
      return stys;
    });
    const computeMaps = {
      computeItemOpts,
      computeBarOpts,
      computeActionOpts
    };
    const refMaps = {
      refElem
    };
    const $xeSplitter = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $splitter: $xeSplitter }, params));
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils82.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils82.default.isFunction(slotFunc)) {
          return getSlotVNs2(slotFunc(params));
        }
      }
      return [];
    };
    const getActionIcon = (prevItem, nextItem, isNext) => {
      const { vertical } = props;
      const topIcon = "SPLIT_TOP_ACTION";
      const bottomIcon = "SPLIT_BOTTOM_ACTION";
      const leftIcon = "SPLIT_LEFT_ACTION";
      const rightIcon = "SPLIT_RIGHT_ACTION";
      let iconName = "";
      if (vertical) {
        if (isNext) {
          iconName = nextItem.isExpand ? bottomIcon : topIcon;
        } else {
          iconName = prevItem.isExpand ? topIcon : bottomIcon;
        }
      } else {
        if (isNext) {
          iconName = nextItem.isExpand ? rightIcon : leftIcon;
        } else {
          iconName = prevItem.isExpand ? leftIcon : rightIcon;
        }
      }
      if (iconName) {
        return getIcon()[iconName];
      }
      return "";
    };
    const reset = () => {
      const { itemList } = reactData;
      itemList.forEach((item) => {
        item.isExpand = true;
        item.foldHeight = 0;
        item.foldWidth = 0;
        item.resizeHeight = 0;
        item.resizeWidth = 0;
      });
      return nextTick();
    };
    const handleLoadItem = (list, isReset) => {
      const { staticItems } = reactData;
      const actionOpts = computeActionOpts.value;
      const { showPrevButton, showNextButton } = actionOpts;
      const itemDef = {
        isExpand: true,
        renderWidth: 0,
        resizeWidth: 0,
        foldWidth: 0,
        renderHeight: 0,
        resizeHeight: 0,
        foldHeight: 0
      };
      reactData.itemList = list.map((item) => {
        if (item.showAction) {
          warnLog("vxe.error.removeProp", ["[splitter] show-action"]);
        }
        if (item.slots) {
          import_xe_utils82.default.each(item.slots, (func) => {
            if (!import_xe_utils82.default.isFunction(func)) {
              if (!slots[func]) {
                errLog("vxe.error.notSlot", [`[splitter] ${func}`]);
              }
            }
          });
        }
        return Object.assign({}, isReset ? null : itemDef, item, isReset ? itemDef : null, {
          id: import_xe_utils82.default.uniqueId()
        });
      });
      if (staticItems.length) {
        errLog("vxe.error.errConflicts", ["<vxe-splitter-panel ...>", "items"]);
      }
      if ((showPrevButton || showNextButton) && reactData.itemList.length > 2) {
        errLog("vxe.error.errConflicts", ["action-config.showPrevButton | action-config.showNextButton", "Only supports 2 item"]);
      }
      return recalculate();
    };
    const loadItem = (list) => {
      return handleLoadItem(list || [], false);
    };
    const reloadItem = (list) => {
      return handleLoadItem(list || [], true);
    };
    const handleItemByName = (name) => {
      const { itemList } = reactData;
      let index = -1;
      let currItem = null;
      let prevItem = null;
      let nextItem = null;
      for (let i = 0; i < itemList.length; i++) {
        const item = itemList[i];
        if (item.name === name) {
          index = i;
          currItem = item;
          prevItem = itemList[i - 1] || null;
          nextItem = itemList[i + 1] || null;
          break;
        }
      }
      return {
        index,
        currItem,
        prevItem,
        nextItem
      };
    };
    const setItemExpand = (name, expanded) => {
      const restItem = handleItemByName(name);
      if (restItem) {
        const { currItem, prevItem, nextItem } = restItem;
        if (currItem) {
          if (expanded ? !currItem.isExpand : currItem.isExpand) {
            if (nextItem) {
              if (nextItem.isExpand) {
                handleItemActionEvent(null, currItem, nextItem, false);
              }
            } else if (prevItem) {
              if (prevItem.isExpand) {
                handleItemActionEvent(null, prevItem, currItem, true);
              }
            }
          }
        }
      }
      return nextTick();
    };
    const toggleItemExpand = (name) => {
      const restItem = handleItemByName(name);
      if (restItem) {
        const { currItem } = restItem;
        if (currItem) {
          return setItemExpand(name, !currItem.isExpand);
        }
      }
      return nextTick();
    };
    const getItemExpand = (name) => {
      const restItem = handleItemByName(name);
      if (restItem) {
        const { currItem } = restItem;
        if (currItem) {
          return currItem.isExpand;
        }
      }
      return false;
    };
    const recalculate = () => {
      return nextTick().then(() => {
        const { vertical } = props;
        const { itemList } = reactData;
        const el = refElem.value;
        const barInfoElem = refBarInfoElem.value;
        if (!el) {
          return;
        }
        const wWidth = el.clientWidth;
        const wHeight = el.clientHeight;
        if (!wWidth || !wHeight) {
          return;
        }
        if (barInfoElem) {
          reactData.barWidth = barInfoElem.offsetWidth;
          reactData.barHeight = barInfoElem.offsetHeight;
        }
        const contentWidth = wWidth - (vertical ? 0 : reactData.barWidth * (itemList.length - 1));
        const contentHeight = wHeight - (vertical ? reactData.barHeight * (itemList.length - 1) : 0);
        const itemOpts = computeItemOpts.value;
        const allMinWidth = import_xe_utils82.default.toNumber(itemOpts.minWidth);
        const allMinHeight = import_xe_utils82.default.toNumber(itemOpts.minHeight);
        const residueItems = [];
        if (vertical) {
          let countHeight = 0;
          itemList.forEach((item) => {
            const { height } = item;
            let itemHeight = 0;
            if (height) {
              if (isScale(height)) {
                itemHeight = contentHeight * import_xe_utils82.default.toNumber(height) / 100;
              } else {
                itemHeight = import_xe_utils82.default.toNumber(height);
              }
              item.renderHeight = itemHeight;
            } else {
              residueItems.push(item);
            }
            countHeight += itemHeight;
          });
          if (residueItems.length) {
            const reMeanHeight = (contentHeight - countHeight) / residueItems.length;
            residueItems.forEach((item) => {
              item.renderHeight = Math.max(import_xe_utils82.default.toNumber(getGlobalDefaultConfig(item.minHeight, allMinHeight)), reMeanHeight);
            });
          }
        } else {
          let countWidth = 0;
          itemList.forEach((item) => {
            const { width } = item;
            let itemWidth = 0;
            if (width) {
              if (isScale(width)) {
                itemWidth = contentWidth * import_xe_utils82.default.toNumber(width) / 100;
              } else {
                itemWidth = import_xe_utils82.default.toNumber(width);
              }
              item.renderWidth = itemWidth;
            } else {
              residueItems.push(item);
            }
            countWidth += itemWidth;
          });
          if (residueItems.length) {
            const reMeanWidth = (contentWidth - countWidth) / residueItems.length;
            residueItems.forEach((item) => {
              item.renderWidth = Math.max(import_xe_utils82.default.toNumber(getGlobalDefaultConfig(item.minWidth, allMinWidth)), reMeanWidth);
            });
          }
        }
        internalData.wrapperWidth = contentWidth;
        internalData.wrapperHeight = contentHeight;
      });
    };
    const dragEvent = (evnt) => {
      const { resize, vertical } = props;
      const { itemList } = reactData;
      if (!resize) {
        return;
      }
      evnt.preventDefault();
      const barEl = evnt.currentTarget;
      const handleEl = barEl.parentElement;
      const el = refElem.value;
      if (!el) {
        return;
      }
      const prevEl = handleEl.previousElementSibling;
      const nextEl = handleEl.nextElementSibling;
      if (!prevEl || !nextEl) {
        return;
      }
      const prevId = prevEl.getAttribute("itemid");
      const nextId = nextEl.getAttribute("itemid");
      const prevItem = itemList.find((item) => item.id === prevId);
      const nextItem = itemList.find((item) => item.id === nextId);
      if (!prevItem || !nextItem) {
        return;
      }
      const containerRect = el.getBoundingClientRect();
      const barRect = barEl.getBoundingClientRect();
      const rsSplitterLineEl = refResizableSplitterTip.value;
      const rsSplitterTipEl = rsSplitterLineEl ? rsSplitterLineEl.children[0] : null;
      const itemOpts = computeItemOpts.value;
      const resizeOpts = computeResizeOpts.value;
      const { immediate } = resizeOpts;
      const allMinWidth = import_xe_utils82.default.toNumber(itemOpts.minWidth);
      const allMinHeight = import_xe_utils82.default.toNumber(itemOpts.minHeight);
      const barOffsetX = Math.ceil(barRect.width - (evnt.clientX - barRect.left));
      const barOffsetY = Math.ceil(evnt.clientY - barRect.top);
      const prevWidth = prevEl.offsetWidth;
      const nextWidth = nextEl.offsetWidth;
      const prevMinWidth = import_xe_utils82.default.toNumber(prevItem ? getGlobalDefaultConfig(prevItem.minWidth, allMinWidth) : allMinWidth);
      const nextMinWidth = import_xe_utils82.default.toNumber(nextItem ? getGlobalDefaultConfig(nextItem.minWidth, allMinWidth) : allMinWidth);
      const minOffsetLeft = prevEl.offsetLeft + prevMinWidth - barOffsetX;
      const maxOffsetLeft = nextEl.offsetLeft + nextEl.offsetWidth - nextMinWidth - barOffsetX;
      const startOffsetLeft = evnt.clientX - containerRect.left;
      let targetOffsetWidth = -1;
      let prevResizeWidth = 0;
      let nextResizeWidth = 0;
      let offsetLeft = startOffsetLeft;
      const prevHeight = prevEl.offsetHeight;
      const nextHeight = nextEl.offsetHeight;
      const prevMinHeight = import_xe_utils82.default.toNumber(prevItem ? getGlobalDefaultConfig(prevItem.minHeight, allMinHeight) : allMinHeight);
      const nextMinHeight = import_xe_utils82.default.toNumber(nextItem ? getGlobalDefaultConfig(nextItem.minHeight, allMinHeight) : allMinHeight);
      const minOffsetTop = prevEl.offsetTop + prevMinHeight + barOffsetY;
      const maxOffsetTop = nextEl.offsetTop + nextEl.offsetHeight - nextMinHeight + barOffsetY;
      const startOffsetTop = evnt.clientY - containerRect.top;
      let targetOffsetHeight = -1;
      let prevResizeHeight = 0;
      let nextResizeHeight = 0;
      let offsetTop = startOffsetTop;
      const handleReStyle = (evnt2) => {
        if (!rsSplitterLineEl) {
          return;
        }
        const rsNumPrevEl = rsSplitterTipEl ? rsSplitterTipEl.children[0] : null;
        const rsNumNextEl = rsSplitterTipEl ? rsSplitterTipEl.children[1] : null;
        if (vertical) {
          let tipWidth = 0;
          if (rsNumPrevEl) {
            if (targetOffsetHeight < 0) {
              rsNumPrevEl.style.display = "none";
            } else {
              rsNumPrevEl.textContent = `${Math.floor(prevResizeHeight)}px`;
              rsNumPrevEl.style.display = "block";
              tipWidth = rsNumPrevEl.offsetWidth;
            }
          }
          if (rsNumNextEl) {
            if (targetOffsetHeight < 0) {
              rsNumNextEl.textContent = `${Math.floor(nextResizeHeight)}px`;
              rsNumNextEl.style.display = "block";
              tipWidth = rsNumNextEl.offsetWidth;
            } else {
              rsNumNextEl.style.display = "none";
            }
          }
          let rsLeft = Math.max(1, evnt2.clientX - containerRect.left - tipWidth / 2);
          if (rsLeft > containerRect.width - tipWidth - 1) {
            rsLeft = containerRect.width - tipWidth - 1;
          }
          rsSplitterLineEl.style.left = "0";
          rsSplitterLineEl.style.top = `${offsetTop}px`;
          if (rsSplitterTipEl) {
            rsSplitterTipEl.style.left = `${rsLeft}px`;
          }
        } else {
          let tipHeight = 0;
          if (rsNumPrevEl) {
            if (targetOffsetWidth < 0) {
              rsNumPrevEl.style.display = "none";
            } else {
              rsNumPrevEl.textContent = `${Math.floor(prevResizeWidth)}px`;
              rsNumPrevEl.style.display = "block";
              tipHeight = rsNumPrevEl.offsetHeight;
            }
          }
          if (rsNumNextEl) {
            if (targetOffsetWidth < 0) {
              rsNumNextEl.textContent = `${Math.floor(nextResizeWidth)}px`;
              rsNumNextEl.style.display = "block";
              tipHeight = rsNumNextEl.offsetHeight;
            } else {
              rsNumNextEl.style.display = "none";
            }
          }
          let rsTop = Math.max(1, evnt2.clientY - containerRect.top - tipHeight / 2);
          if (rsTop > containerRect.height - tipHeight - 1) {
            rsTop = containerRect.height - tipHeight - 1;
          }
          rsSplitterLineEl.style.top = "0";
          rsSplitterLineEl.style.left = `${offsetLeft}px`;
          if (rsSplitterTipEl) {
            rsSplitterTipEl.style.top = `${rsTop}px`;
          }
        }
      };
      const handleUpdate = () => {
        if (vertical) {
          prevItem.resizeHeight = prevResizeHeight;
          nextItem.resizeHeight = nextResizeHeight;
        } else {
          prevItem.resizeWidth = prevResizeWidth;
          nextItem.resizeWidth = nextResizeWidth;
        }
      };
      const handleDrag = (evnt2) => {
        if (vertical) {
          offsetTop = evnt2.clientY - containerRect.top;
          if (offsetTop < minOffsetTop) {
            offsetTop = minOffsetTop;
          }
          if (offsetTop > maxOffsetTop) {
            offsetTop = maxOffsetTop;
          }
          targetOffsetHeight = offsetTop - startOffsetTop;
          prevResizeHeight = prevHeight + targetOffsetHeight;
          nextResizeHeight = nextHeight - targetOffsetHeight;
        } else {
          offsetLeft = evnt2.clientX - containerRect.left;
          if (offsetLeft < minOffsetLeft) {
            offsetLeft = minOffsetLeft;
          }
          if (offsetLeft > maxOffsetLeft) {
            offsetLeft = maxOffsetLeft;
          }
          targetOffsetWidth = offsetLeft - startOffsetLeft;
          prevResizeWidth = prevWidth + targetOffsetWidth;
          nextResizeWidth = nextWidth - targetOffsetWidth;
        }
        if (immediate) {
          if (vertical) {
            prevEl.style.height = toCssUnit(prevResizeHeight);
            nextEl.style.height = toCssUnit(nextResizeHeight);
          } else {
            prevEl.style.width = toCssUnit(prevResizeWidth);
            nextEl.style.width = toCssUnit(nextResizeWidth);
          }
        }
        if (rsSplitterLineEl) {
          handleReStyle(evnt2);
        }
        dispatchEvent("resize-drag", { prevItem, nextItem, offsetHeight: targetOffsetHeight, offsetWidth: targetOffsetWidth }, evnt2);
      };
      document.onmousemove = (evnt2) => {
        evnt2.preventDefault();
        handleDrag(evnt2);
      };
      document.onmouseup = (evnt2) => {
        document.onmousemove = null;
        document.onmouseup = null;
        if (rsSplitterLineEl) {
          rsSplitterLineEl.style.display = "";
        }
        handleUpdate();
        removeClass(el, "is--drag");
        dispatchEvent("resize-end", { prevItem, nextItem, offsetHeight: targetOffsetHeight, offsetWidth: targetOffsetWidth }, evnt2);
        recalculate();
      };
      if (rsSplitterLineEl) {
        rsSplitterLineEl.style.display = "block";
        handleReStyle(evnt);
      }
      handleDrag(evnt);
      addClass(el, "is--drag");
      dispatchEvent("resize-start", { prevItem, nextItem }, evnt);
    };
    const handleItemActionEvent = (evnt, prevItem, nextItem, isNext) => {
      const { vertical } = props;
      let expanded = false;
      let item = prevItem;
      if (isNext) {
        item = nextItem;
        expanded = !nextItem.isExpand;
        nextItem.isExpand = expanded;
      } else {
        expanded = !prevItem.isExpand;
        prevItem.isExpand = expanded;
      }
      if (vertical) {
        if (prevItem.isExpand && nextItem.isExpand) {
          prevItem.foldHeight = 0;
          nextItem.foldHeight = 0;
        } else if (prevItem.isExpand) {
          nextItem.foldHeight = 0;
          prevItem.foldHeight = (prevItem.resizeHeight || prevItem.renderHeight) + (nextItem.resizeHeight || nextItem.renderHeight);
        } else {
          prevItem.foldHeight = 0;
          nextItem.foldHeight = (prevItem.resizeHeight || prevItem.renderHeight) + (nextItem.resizeHeight || nextItem.renderHeight);
        }
      } else {
        if (prevItem.isExpand && nextItem.isExpand) {
          prevItem.foldWidth = 0;
          nextItem.foldWidth = 0;
        } else if (prevItem.isExpand) {
          nextItem.foldWidth = 0;
          prevItem.foldWidth = (prevItem.resizeWidth || prevItem.renderWidth) + (nextItem.resizeWidth || nextItem.renderWidth);
        } else {
          prevItem.foldWidth = 0;
          nextItem.foldWidth = (prevItem.resizeWidth || prevItem.renderWidth) + (nextItem.resizeWidth || nextItem.renderWidth);
        }
      }
      if (evnt) {
        dispatchEvent("toggle-expand", { prevItem, nextItem, expanded, item }, evnt);
      }
      recalculate();
    };
    const handlePrevActionDblclickEvent = (evnt) => {
      const { itemList } = reactData;
      const actionOpts = computeActionOpts.value;
      const btnEl = evnt.currentTarget;
      const btnWrapperEl = btnEl.parentElement;
      const handleEl = btnWrapperEl.parentElement;
      const prevEl = handleEl.previousElementSibling;
      const prevId = prevEl.getAttribute("itemid");
      const prevItem = itemList.find((item) => item.id === prevId);
      const nextEl = handleEl.nextElementSibling;
      const nextId = nextEl.getAttribute("itemid");
      const nextItem = itemList.find((item) => item.id === nextId);
      if (actionOpts.trigger === "dblclick") {
        if (prevItem && nextItem && nextItem.isExpand) {
          handleItemActionEvent(evnt, prevItem, nextItem, false);
        }
      }
      dispatchEvent("action-dblclick", { prevItem, nextItem }, evnt);
    };
    const handlePrevActionClickEvent = (evnt) => {
      const { itemList } = reactData;
      const actionOpts = computeActionOpts.value;
      const btnEl = evnt.currentTarget;
      const btnWrapperEl = btnEl.parentElement;
      const handleEl = btnWrapperEl.parentElement;
      const prevEl = handleEl.previousElementSibling;
      const prevId = prevEl.getAttribute("itemid");
      const prevItem = itemList.find((item) => item.id === prevId);
      const nextEl = handleEl.nextElementSibling;
      const nextId = nextEl.getAttribute("itemid");
      const nextItem = itemList.find((item) => item.id === nextId);
      if (actionOpts.trigger !== "dblclick") {
        if (prevItem && nextItem && nextItem.isExpand) {
          handleItemActionEvent(evnt, prevItem, nextItem, false);
        }
      }
      dispatchEvent("action-click", { prevItem, nextItem }, evnt);
    };
    const handleNextActionDblclickEvent = (evnt) => {
      const { itemList } = reactData;
      const actionOpts = computeActionOpts.value;
      const btnEl = evnt.currentTarget;
      const btnWrapperEl = btnEl.parentElement;
      const handleEl = btnWrapperEl.parentElement;
      const prevEl = handleEl.previousElementSibling;
      const prevId = prevEl.getAttribute("itemid");
      const prevItem = itemList.find((item) => item.id === prevId);
      const nextEl = handleEl.nextElementSibling;
      const nextId = nextEl.getAttribute("itemid");
      const nextItem = itemList.find((item) => item.id === nextId);
      if (actionOpts.trigger === "dblclick") {
        if (prevItem && nextItem && prevItem.isExpand) {
          handleItemActionEvent(evnt, prevItem, nextItem, true);
        }
      }
      dispatchEvent("action-dblclick", { prevItem, nextItem }, evnt);
    };
    const handleNextActionClickEvent = (evnt) => {
      const { itemList } = reactData;
      const actionOpts = computeActionOpts.value;
      const btnEl = evnt.currentTarget;
      const btnWrapperEl = btnEl.parentElement;
      const handleEl = btnWrapperEl.parentElement;
      const prevEl = handleEl.previousElementSibling;
      const prevId = prevEl.getAttribute("itemid");
      const prevItem = itemList.find((item) => item.id === prevId);
      const nextEl = handleEl.nextElementSibling;
      const nextId = nextEl.getAttribute("itemid");
      const nextItem = itemList.find((item) => item.id === nextId);
      if (actionOpts.trigger !== "dblclick") {
        if (prevItem && nextItem && prevItem.isExpand) {
          handleItemActionEvent(evnt, prevItem, nextItem, true);
        }
      }
      dispatchEvent("action-click", { prevItem, nextItem }, evnt);
    };
    const handleGlobalResizeEvent = () => {
      recalculate();
    };
    const splitterMethods = {
      dispatchEvent,
      setItemExpand,
      toggleItemExpand,
      getItemExpand,
      recalculate,
      reset,
      loadItem,
      reloadItem
    };
    const splitterPrivateMethods = {};
    Object.assign($xeSplitter, splitterMethods, splitterPrivateMethods);
    const renderHandleBar = (prevItem, nextItem) => {
      const { border, resize, vertical } = props;
      const { itemList } = reactData;
      const barStyle = computeBarStyle.value;
      const actionOpts = computeActionOpts.value;
      const { direction } = actionOpts;
      const showPrevButton = import_xe_utils82.default.isBoolean(actionOpts.showPrevButton) ? actionOpts.showPrevButton : itemList.some((item) => item.showAction);
      const showNextButton = import_xe_utils82.default.isBoolean(actionOpts.showNextButton) ? actionOpts.showNextButton : direction === "next" && itemList.some((item) => item.showAction);
      const resizeOpts = computeResizeOpts.value;
      const { immediate } = resizeOpts;
      return h("div", {
        class: ["vxe-splitter-panel-handle", vertical ? "is--vertical" : "is--horizontal", immediate ? "is-resize--immediate" : "is-resize--lazy", {
          "is--resize": resize,
          "is--border": border
        }]
      }, [
        h("div", {
          class: "vxe-splitter-panel-handle-bar",
          style: barStyle,
          onMousedown: dragEvent
        }),
        itemList.length === 2 ? h("div", {
          class: "vxe-splitter-panel-action-btn-wrapper"
        }, [
          showPrevButton && nextItem.isExpand ? h("div", {
            class: "vxe-splitter-panel-action-btn",
            onDblclick: handlePrevActionDblclickEvent,
            onClick: handlePrevActionClickEvent
          }, [
            h("i", {
              class: getActionIcon(prevItem, nextItem, false)
            })
          ]) : renderEmptyElement($xeSplitter),
          showNextButton && prevItem.isExpand ? h("div", {
            class: "vxe-splitter-panel-action-btn",
            onDblclick: handleNextActionDblclickEvent,
            onClick: handleNextActionClickEvent
          }, [
            h("i", {
              class: getActionIcon(prevItem, nextItem, true)
            })
          ]) : renderEmptyElement($xeSplitter)
        ]) : renderEmptyElement($xeSplitter)
      ]);
    };
    const renderItems = () => {
      const { border, padding, resize, vertical } = props;
      const { itemList } = reactData;
      const vSize = computeSize.value;
      const resizeOpts = computeResizeOpts.value;
      const { immediate } = resizeOpts;
      const visibleItems = computeVisibleItems.value;
      const { autoItems } = computeAutoItems.value;
      const itemVNs = [];
      itemList.forEach((prevItem, index) => {
        const { id, name, slots: slots2, renderHeight, resizeHeight, foldHeight, renderWidth, resizeWidth, foldWidth, isExpand } = prevItem;
        const nextItem = itemList[index + 1];
        const defaultSlot = slots2 ? slots2.default : null;
        const stys = {};
        let itemWidth = isExpand ? foldWidth || resizeWidth || renderWidth : 0;
        let itemHeight = isExpand ? foldHeight || resizeHeight || renderHeight : 0;
        if (autoItems.length === 1) {
          if (vertical) {
            if (!prevItem.height) {
              itemHeight = 0;
            }
          } else {
            if (!prevItem.width) {
              itemWidth = 0;
            }
          }
        }
        let isFill = true;
        if (vertical) {
          if (itemHeight && visibleItems.length > 1) {
            isFill = false;
            stys.height = toCssUnit(itemHeight);
          }
        } else {
          if (itemWidth && visibleItems.length > 1) {
            isFill = false;
            stys.width = toCssUnit(itemWidth);
          }
        }
        itemVNs.push(h("div", {
          itemid: id,
          class: ["vxe-splitter-panel", vertical ? "is--vertical" : "is--horizontal", immediate ? "is-resize--immediate" : "is-resize--lazy", {
            [`size--${vSize}`]: vSize,
            "is--resize": resize,
            "is--padding": padding,
            "is--border": border,
            "is--height": itemHeight,
            "is--width": itemWidth,
            "is--visible": isExpand,
            "is--hidden": !isExpand,
            "is--fill": isExpand && isFill
          }],
          style: stys
        }, [
          h("div", {
            itemid: id,
            class: "vxe-splitter-panel--wrapper"
          }, [
            h("div", {
              class: "vxe-splitter-panel--inner"
            }, defaultSlot ? callSlot(defaultSlot, { name, isExpand }) : [])
          ])
        ]));
        if (nextItem) {
          itemVNs.push(renderHandleBar(prevItem, nextItem));
        }
      });
      return h("div", {
        class: "vxe-splitter-wrapper"
      }, itemVNs);
    };
    const renderVN = () => {
      const { vertical, width, height } = props;
      const vSize = computeSize.value;
      const resizeOpts = computeResizeOpts.value;
      const { immediate, showTip } = resizeOpts;
      const defaultSlot = slots.default;
      const stys = {};
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (width) {
        stys.width = toCssUnit(width);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-splitter", vertical ? "is--vertical" : "is--horizontal", immediate ? "is-resize--immediate" : "is-resize--lazy", {
          [`size--${vSize}`]: vSize
        }],
        style: stys
      }, [
        h("div", {
          class: "vxe-splitter-slots"
        }, defaultSlot ? defaultSlot({}) : []),
        renderItems(),
        h("div", {
          ref: refResizableSplitterTip,
          class: ["vxe-splitter--resizable-splitter-tip", vertical ? "is--vertical" : "is--horizontal", immediate ? "is-resize--immediate" : "is-resize--lazy"]
        }, showTip ? [
          h("div", {
            class: "vxe-splitter--resizable-splitter-tip-number"
          }, [
            h("div", {
              class: "vxe-splitter--resizable-splitter-number-prev"
            }),
            h("div", {
              class: "vxe-splitter--resizable-splitter-number-next"
            })
          ])
        ] : []),
        h("div", {
          class: "vxe-splitter--render-vars"
        }, [
          h("div", {
            ref: refBarInfoElem,
            class: "vxe-splitter--handle-bar-info"
          })
        ])
      ]);
    };
    const itemFlag = ref(0);
    watch(() => props.items ? props.items.length : -1, () => {
      itemFlag.value++;
    });
    watch(() => props.items, () => {
      itemFlag.value++;
    });
    watch(itemFlag, () => {
      loadItem(props.items || []);
    });
    watch(() => reactData.staticItems, (val) => {
      const actionOpts = computeActionOpts.value;
      const { showPrevButton, showNextButton } = actionOpts;
      if (props.items && props.items.length) {
        errLog("vxe.error.errConflicts", ["<vxe-splitter-panel ...>", "items"]);
      }
      reactData.itemList = val || [];
      if ((showPrevButton || showNextButton) && reactData.itemList.length > 2) {
        errLog("vxe.error.modelConflicts", ["[splitter] action-config.showPrevButton | action-config.showNextButton", "<vxe-splitter-panel ...> Only supports 2 panel"]);
      }
      reactData.itemList.forEach((item) => {
        if (item.showAction) {
          warnLog("vxe.error.removeProp", ["[splitter] showAction"]);
        }
      });
      recalculate();
    });
    let resizeObserver;
    onMounted(() => {
      nextTick(() => {
        recalculate();
      });
      const el = refElem.value;
      if (el) {
        resizeObserver = globalResize.create(() => {
          recalculate();
        });
        resizeObserver.observe(el);
      }
      const actionOpts = computeActionOpts.value;
      if (actionOpts.direction) {
        errLog("vxe.error.delProp", ["[splitter] action-config.direction", "action-config.showPrevButton | action-config.showNextButton"]);
      }
      globalEvents.on($xeSplitter, "resize", handleGlobalResizeEvent);
    });
    onUnmounted(() => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      globalEvents.off($xeSplitter, "resize");
    });
    onActivated(() => {
      recalculate();
    });
    if (props.items) {
      loadItem(props.items);
    }
    provide("$xeSplitter", $xeSplitter);
    $xeSplitter.renderVN = renderVN;
    return $xeSplitter;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/splitter/index.js
var VxeSplitter = Object.assign({}, splitter_default, {
  install(app) {
    app.component(splitter_default.name, splitter_default);
  }
});
dynamicApp.use(VxeSplitter);
VxeUI.component(splitter_default);
var Splitter = VxeSplitter;
var splitter_default2 = VxeSplitter;

// node_modules/vxe-pc-ui/es/splitter/src/util.js
var import_xe_utils83 = __toESM(require_xe_utils());
function assembleSplitterItem($xeSplitter, elem, paneConfig) {
  const staticItems = $xeSplitter.reactData.staticItems;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticItems.splice(import_xe_utils83.default.arrayIndexOf(parentElem.children, elem), 0, paneConfig);
    $xeSplitter.reactData.staticItems = staticItems.slice(0);
  }
}
function destroySplitterItem($xeSplitter, paneConfig) {
  const staticItems = $xeSplitter.reactData.staticItems;
  const index = import_xe_utils83.default.findIndexOf(staticItems, (item) => item.id === paneConfig.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  $xeSplitter.reactData.staticItems = staticItems.slice(0);
}

// node_modules/vxe-pc-ui/es/splitter/src/splitter-panel.js
var import_xe_utils84 = __toESM(require_xe_utils());
var splitter_panel_default = defineVxeComponent({
  name: "VxeSplitterPanel",
  props: {
    name: [Number, String],
    width: [Number, String],
    height: [Number, String],
    minWidth: {
      type: [Number, String],
      default: () => null
    },
    minHeight: {
      type: [Number, String],
      default: () => null
    },
    // 已废弃
    showAction: Boolean
  },
  emits: [],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils84.default.uniqueId();
    const $xeSplitter = inject("$xeSplitter", null);
    const refElem = ref();
    const paneConfig = reactive({
      id: xID,
      name: props.name,
      width: props.width,
      height: props.height,
      minWidth: props.minWidth,
      minHeight: props.minHeight,
      showAction: props.showAction,
      isExpand: true,
      renderWidth: 0,
      resizeWidth: 0,
      foldWidth: 0,
      renderHeight: 0,
      resizeHeight: 0,
      foldHeight: 0,
      slots
    });
    const reactData = reactive({});
    const internalData = {};
    const computeMaps = {};
    const refMaps = {
      refElem
    };
    const $xeSplitterItem = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $splitterPanel: $xeSplitterItem }, params));
    };
    const splitterPanelMethods = {
      dispatchEvent
    };
    const splitterPanelPrivateMethods = {};
    Object.assign($xeSplitterItem, splitterPanelMethods, splitterPanelPrivateMethods);
    const renderVN = () => {
      return h("div", {
        ref: refElem
      });
    };
    watch(() => props.name, (val) => {
      paneConfig.name = val;
    });
    watch(() => props.width, (val) => {
      paneConfig.width = val;
    });
    watch(() => props.height, (val) => {
      paneConfig.height = val;
    });
    watch(() => props.minWidth, (val) => {
      paneConfig.minWidth = val;
    });
    watch(() => props.minHeight, (val) => {
      paneConfig.minHeight = val;
    });
    watch(() => props.showAction, (val) => {
      paneConfig.showAction = val;
    });
    onMounted(() => {
      const elem = refElem.value;
      if ($xeSplitter && elem) {
        assembleSplitterItem($xeSplitter, elem, paneConfig);
      }
    });
    onUnmounted(() => {
      if ($xeSplitter) {
        destroySplitterItem($xeSplitter, paneConfig);
      }
    });
    provide("$xeSplitterItem", $xeSplitterItem);
    $xeSplitterItem.renderVN = renderVN;
    return $xeSplitterItem;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/splitter-panel/index.js
var VxeSplitterPanel = Object.assign({}, splitter_panel_default, {
  install(app) {
    app.component(splitter_panel_default.name, splitter_panel_default);
  }
});
dynamicApp.use(VxeSplitterPanel);
VxeUI.component(splitter_panel_default);
var SplitterPanel = VxeSplitterPanel;
var splitter_panel_default2 = VxeSplitterPanel;

// node_modules/vxe-pc-ui/es/split/index.js
var VxeSplit = Object.assign({}, splitter_default, {
  install(app) {
    app.component("VxeSplit", splitter_default);
  }
});
dynamicApp.use(VxeSplit);
VxeUI.component(splitter_default);
var Split = VxeSplit;
var split_default = VxeSplit;

// node_modules/vxe-pc-ui/es/split-pane/index.js
var VxeSplitPane = Object.assign({}, splitter_panel_default, {
  install(app) {
    app.component("VxeSplitPane", splitter_panel_default);
    app.component("VxeSplitItem", splitter_panel_default);
  }
});
dynamicApp.use(VxeSplitPane);
VxeUI.component(splitter_panel_default);
var SplitPane = VxeSplitPane;
var split_pane_default = VxeSplitPane;

// node_modules/vxe-pc-ui/es/slider/src/slider.js
var import_xe_utils85 = __toESM(require_xe_utils());
var slider_default = defineVxeComponent({
  name: "VxeSlider",
  props: {
    modelValue: [String, Number, Array],
    vertical: Boolean,
    max: {
      type: [String, Number],
      default: () => getConfig().slider.max
    },
    min: {
      type: [String, Number],
      default: () => getConfig().slider.min
    },
    step: {
      type: [String, Number],
      default: () => getConfig().slider.step
    },
    size: {
      type: String,
      default: () => getConfig().slider.size || getConfig().size
    },
    range: {
      type: Boolean,
      default: () => getConfig().slider.range
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "track-dragstart",
    "track-dragover",
    "track-dragend"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils85.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refBarElem = ref();
    const refTrackElem = ref();
    const refStartBtnElem = ref();
    const refEndBtnElem = ref();
    const reactData = reactive({
      startValue: 0,
      endValue: 0
    });
    const refMaps = {
      refElem
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeMaxNum = computed(() => {
      return import_xe_utils85.default.toNumber(props.max || 0);
    });
    const computeMinNum = computed(() => {
      return import_xe_utils85.default.toNumber(props.min || 0);
    });
    const computeMaps = {};
    const $xeSlider = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $slider: $xeSlider }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const getStartPercent = (startValue) => {
      const { range } = props;
      const maxNum = computeMaxNum.value;
      const minNum = computeMinNum.value;
      return range ? import_xe_utils85.default.floor((startValue - minNum) / import_xe_utils85.default.toNumber(maxNum - minNum) * 100) : 0;
    };
    const getEndPercent = (startValue, endValue) => {
      const { range } = props;
      const maxNum = computeMaxNum.value;
      const minNum = computeMinNum.value;
      return import_xe_utils85.default.floor((endValue - (range ? startValue : 0) - minNum) / import_xe_utils85.default.toNumber(maxNum - minNum) * 100);
    };
    const updateModel = () => {
      const { modelValue } = props;
      if (import_xe_utils85.default.isArray(modelValue)) {
        const [sVal, eVal] = import_xe_utils85.default.clone(modelValue, true).sort();
        reactData.startValue = import_xe_utils85.default.floor(import_xe_utils85.default.toNumber(sVal || 0));
        reactData.endValue = import_xe_utils85.default.floor(import_xe_utils85.default.toNumber(eVal || 0));
      } else {
        reactData.startValue = 0;
        reactData.endValue = import_xe_utils85.default.floor(import_xe_utils85.default.toNumber(modelValue || 0));
      }
    };
    const updateBarStyle = () => {
      const { startValue, endValue } = reactData;
      const trackElem = refTrackElem.value;
      const startBtnElem = refStartBtnElem.value;
      const endBtnElem = refEndBtnElem.value;
      let startPercent = 0;
      let endPercent = 0;
      if (startValue > endValue) {
        startPercent = getStartPercent(endValue);
        endPercent = getEndPercent(endValue, startValue);
      } else {
        startPercent = getStartPercent(startValue);
        endPercent = getEndPercent(startValue, endValue);
      }
      if (trackElem) {
        trackElem.style.left = `${startPercent}%`;
        trackElem.style.width = `${endPercent}%`;
      }
      if (startBtnElem) {
        startBtnElem.style.left = `${startPercent}%`;
      }
      if (endBtnElem) {
        endBtnElem.style.left = `${import_xe_utils85.default.floor(startPercent + endPercent)}%`;
      }
    };
    const changeEvent = (evnt) => {
      const { range } = props;
      const { startValue, endValue } = reactData;
      const value = range ? [startValue, endValue].sort() : endValue;
      emitModel(value);
      dispatchEvent("change", { value }, evnt);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const handleMousedownEvent = (evnt, isEnd) => {
      const formReadonly = computeFormReadonly.value;
      const isDisabled = computeIsDisabled.value;
      const maxNum = computeMaxNum.value;
      const minNum = computeMinNum.value;
      if (!(formReadonly || isDisabled)) {
        evnt.preventDefault();
        document.onmousemove = (evnt2) => {
          evnt2.preventDefault();
          const el = refElem.value;
          const barElem = refBarElem.value;
          if (el && barElem) {
            const barRect = barElem.getBoundingClientRect();
            const trackWidth = (evnt2.clientX - barRect.left) / barRect.width;
            if (isEnd) {
              reactData.endValue = import_xe_utils85.default.floor(Math.max(minNum, Math.min(maxNum, trackWidth * (maxNum - minNum) + minNum)));
            } else {
              reactData.startValue = import_xe_utils85.default.floor(Math.max(minNum, Math.min(maxNum, trackWidth * (maxNum - minNum))));
            }
            dispatchEvent("track-dragover", { startValue: reactData.startValue, endValue: reactData.endValue }, evnt2);
          }
          updateBarStyle();
        };
        document.onmouseup = (evnt2) => {
          document.onmousemove = null;
          document.onmouseup = null;
          dispatchEvent("track-dragend", { startValue: reactData.startValue, endValue: reactData.endValue }, evnt2);
          changeEvent(evnt2);
          updateBarStyle();
        };
        dispatchEvent("track-dragstart", { startValue: reactData.startValue, endValue: reactData.endValue }, evnt);
      }
    };
    const handleStartMousedownEvent = (evnt) => {
      const endBtnElem = refEndBtnElem.value;
      const startBtnElem = evnt.currentTarget;
      handleMousedownEvent(evnt, endBtnElem ? endBtnElem.offsetLeft < startBtnElem.offsetLeft : false);
    };
    const handleEndMousedownEvent = (evnt) => {
      const startBtnElem = refStartBtnElem.value;
      const endBtnElem = evnt.currentTarget;
      handleMousedownEvent(evnt, startBtnElem ? endBtnElem.offsetLeft > startBtnElem.offsetLeft : true);
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeSlider, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { vertical, range } = props;
      const vSize = computeSize.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabled = computeIsDisabled.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-slider", {
          [`size--${vSize}`]: vSize,
          "is--vertical": vertical,
          "is--readonly": formReadonly,
          "is--disabled": isDisabled
        }]
      }, [
        h("div", {
          class: "vxe-slider--inner"
        }, [
          h("div", {
            ref: refBarElem,
            class: "vxe-slider--bar-wrapper"
          }),
          h("div", {
            ref: refTrackElem,
            class: "vxe-slider--bar-track"
          }),
          formReadonly || !range ? renderEmptyElement($xeSlider) : h("div", {
            ref: refStartBtnElem,
            class: "vxe-slider--bar-btn vxe-slider--start-btn",
            onMousedown: handleStartMousedownEvent
          }),
          formReadonly ? renderEmptyElement($xeSlider) : h("div", {
            ref: refEndBtnElem,
            class: "vxe-slider--bar-btn vxe-slider--end-btn",
            onMousedown: handleEndMousedownEvent
          })
        ])
      ]);
    };
    watch(() => props.modelValue, () => {
      updateModel();
    });
    onMounted(() => {
      updateBarStyle();
    });
    updateModel();
    $xeSlider.renderVN = renderVN;
    return $xeSlider;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/slider/index.js
var VxeSlider = Object.assign({}, slider_default, {
  install(app) {
    app.component(slider_default.name, slider_default);
  }
});
dynamicApp.use(VxeSlider);
VxeUI.component(slider_default);
var Slider = VxeSlider;
var slider_default2 = VxeSlider;

// node_modules/vxe-pc-ui/es/steps/src/steps.js
var import_xe_utils86 = __toESM(require_xe_utils());
var steps_default = defineVxeComponent({
  name: "VxeSteps",
  props: {},
  emits: [],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils86.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeSteps = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $steps: $xeSteps }, params));
    };
    const stepsMethods = {
      dispatchEvent
    };
    const stepsPrivateMethods = {};
    Object.assign($xeSteps, stepsMethods, stepsPrivateMethods);
    const renderVN = () => {
      return h("div", {
        ref: refElem,
        class: "vxe-steps"
      }, []);
    };
    $xeSteps.renderVN = renderVN;
    return $xeSteps;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/steps/index.js
var VxeSteps = Object.assign({}, steps_default, {
  install(app) {
    app.component(steps_default.name, steps_default);
  }
});
dynamicApp.use(VxeSteps);
VxeUI.component(steps_default);
var Steps = VxeSteps;
var steps_default2 = VxeSteps;

// node_modules/vxe-pc-ui/es/switch/src/switch.js
var import_xe_utils87 = __toESM(require_xe_utils());
var switch_default = defineVxeComponent({
  name: "VxeSwitch",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: {
      type: Boolean,
      default: null
    },
    readonly: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().switch.size || getConfig().size
    },
    openLabel: String,
    closeLabel: String,
    openValue: {
      type: [String, Number, Boolean],
      default: true
    },
    closeValue: {
      type: [String, Number, Boolean],
      default: false
    },
    openIcon: String,
    closeIcon: String,
    openActiveIcon: String,
    closeActiveIcon: String
  },
  emits: [
    "update:modelValue",
    "change",
    "focus",
    "blur"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils87.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      isActivated: false,
      hasAnimat: false,
      offsetLeft: 0
    });
    const internalData = {};
    const $xeSwitch = {
      xID,
      props,
      context,
      reactData,
      internalData
    };
    const refButton = ref();
    let switchMethods = {};
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return readonly;
    });
    const computeOnShowLabel = computed(() => {
      return getFuncText(props.openLabel);
    });
    const computeOffShowLabel = computed(() => {
      return getFuncText(props.closeLabel);
    });
    const computeIsChecked = computed(() => {
      return props.modelValue === props.openValue;
    });
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const clickEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!(isDisabled || isReadonly)) {
        const isChecked = computeIsChecked.value;
        clearTimeout(internalData.atTimeout);
        const value = isChecked ? props.closeValue : props.openValue;
        reactData.hasAnimat = true;
        emitModel(value);
        switchMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
        internalData.atTimeout = setTimeout(() => {
          reactData.hasAnimat = false;
          internalData.atTimeout = void 0;
        }, 400);
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $switch: $xeSwitch }, params));
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      switchMethods.dispatchEvent("focus", { value: props.modelValue }, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      switchMethods.dispatchEvent("blur", { value: props.modelValue }, evnt);
    };
    switchMethods = {
      dispatchEvent,
      focus() {
        const btnElem = refButton.value;
        reactData.isActivated = true;
        if (btnElem) {
          btnElem.focus();
        }
        return nextTick();
      },
      blur() {
        const btnElem = refButton.value;
        if (btnElem) {
          btnElem.blur();
        }
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xeSwitch, switchMethods);
    const renderVN = () => {
      const { openIcon, closeIcon, openActiveIcon, closeActiveIcon } = props;
      const vSize = computeSize.value;
      const isChecked = computeIsChecked.value;
      const onShowLabel = computeOnShowLabel.value;
      const offShowLabel = computeOffShowLabel.value;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      return h("div", {
        class: ["vxe-switch", isChecked ? "is--on" : "is--off", {
          [`size--${vSize}`]: vSize,
          "is--disabled": isDisabled,
          "is--readonly": isReadonly,
          "is--animat": reactData.hasAnimat
        }]
      }, [
        h("button", {
          ref: refButton,
          class: "vxe-switch--button",
          type: "button",
          disabled: isDisabled || isReadonly,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent
        }, [
          h("span", {
            class: "vxe-switch--label vxe-switch--label-on"
          }, [
            openIcon ? h("i", {
              class: ["vxe-switch--label-icon", openIcon]
            }) : renderEmptyElement($xeSwitch),
            onShowLabel
          ]),
          h("span", {
            class: "vxe-switch--label vxe-switch--label-off"
          }, [
            closeIcon ? h("i", {
              class: ["vxe-switch--label-icon", closeIcon]
            }) : renderEmptyElement($xeSwitch),
            offShowLabel
          ]),
          h("span", {
            class: ["vxe-switch--icon"]
          }, openActiveIcon || closeActiveIcon ? [
            h("i", {
              class: isChecked ? openActiveIcon : closeActiveIcon
            })
          ] : [])
        ])
      ]);
    };
    $xeSwitch.renderVN = renderVN;
    return $xeSwitch;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/switch/index.js
var VxeSwitch = Object.assign(switch_default, {
  install: function(app) {
    app.component(switch_default.name, switch_default);
  }
});
dynamicApp.use(VxeSwitch);
VxeUI.component(switch_default);
var Switch = VxeSwitch;
var switch_default2 = VxeSwitch;

// node_modules/vxe-pc-ui/es/tabs/src/tab-pane.js
var import_xe_utils89 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/tabs/src/util.js
var import_xe_utils88 = __toESM(require_xe_utils());
function assembleTabItem($xeTabs, elem, tabConfig) {
  const staticTabs = $xeTabs.reactData.staticTabs;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticTabs.splice(import_xe_utils88.default.arrayIndexOf(parentElem.children, elem), 0, tabConfig);
    $xeTabs.reactData.staticTabs = staticTabs.slice(0);
  }
}
function destroyTabItem($xeTabs, tabConfig) {
  const staticTabs = $xeTabs.reactData.staticTabs;
  const matchObj = import_xe_utils88.default.findTree(staticTabs, (item) => item.id === tabConfig.id, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeTabs.reactData.staticTabs = staticTabs.slice(0);
}

// node_modules/vxe-pc-ui/es/tabs/src/tab-pane.js
var tab_pane_default = defineVxeComponent({
  name: "VxeTabPane",
  props: {
    title: [String, Number],
    name: [String, Number],
    icon: String,
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    preload: Boolean,
    permissionCode: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils89.default.uniqueId();
    const refElem = ref();
    const $xeTabs = inject("$xeTabs", null);
    const reactData = reactive({});
    const tabConfig = reactive({
      id: xID,
      title: props.title,
      name: props.name,
      icon: props.icon,
      titleWidth: props.titleWidth,
      titleAlign: props.titleAlign,
      preload: props.preload,
      permissionCode: props.permissionCode,
      slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTabPane = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tabPane: $xeTabPane }, params));
    };
    const tabPaneMethods = {
      dispatchEvent
    };
    const tabPanePrivateMethods = {};
    Object.assign($xeTabPane, tabPaneMethods, tabPanePrivateMethods);
    watch(() => props.title, (val) => {
      tabConfig.title = val;
    });
    watch(() => props.name, (val) => {
      tabConfig.name = val;
    });
    watch(() => props.icon, (val) => {
      tabConfig.icon = val;
    });
    watch(() => props.permissionCode, (val) => {
      tabConfig.permissionCode = val;
    });
    onMounted(() => {
      const elem = refElem.value;
      if ($xeTabs && elem) {
        assembleTabItem($xeTabs, elem, tabConfig);
      }
    });
    onUnmounted(() => {
      if ($xeTabs) {
        destroyTabItem($xeTabs, tabConfig);
      }
    });
    const renderVN = () => {
      return h("div", {
        ref: refElem
      }, []);
    };
    $xeTabPane.renderVN = renderVN;
    return $xeTabPane;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/tab-pane/index.js
var VxeTabPane = Object.assign({}, tab_pane_default, {
  install(app) {
    app.component(tab_pane_default.name, tab_pane_default);
  }
});
dynamicApp.use(VxeTabPane);
VxeUI.component(tab_pane_default);
var TabPane = VxeTabPane;
var tab_pane_default2 = VxeTabPane;

// node_modules/vxe-pc-ui/es/table-select/src/table-select.js
var import_xe_utils90 = __toESM(require_xe_utils());
function getRowUniqueId() {
  return import_xe_utils90.default.uniqueId("row_");
}
function createInternalData4() {
  return {
    // hpTimeout: undefined,
    // vpTimeout: undefined,
    fullRowMaps: {}
  };
}
var table_select_default = defineVxeComponent({
  name: "VxeTableSelect",
  props: {
    modelValue: [String, Number, Array],
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => import_xe_utils90.default.eqNull(getConfig().tableSelect.placeholder) ? getI18n("vxe.base.pleaseSelect") : getConfig().tableSelect.placeholder
    },
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    className: [String, Function],
    prefixIcon: String,
    placement: String,
    columns: Array,
    options: Array,
    optionProps: Object,
    lazyOptions: Array,
    zIndex: Number,
    size: {
      type: String,
      default: () => getConfig().tableSelect.size || getConfig().size
    },
    popupConfig: Object,
    gridConfig: Object,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "blur",
    "focus",
    "click",
    "form-submit",
    "form-reset",
    "form-collapse",
    "page-change"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const VxeTableGridComponent = VxeUI.getComponent("vxe-grid");
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils90.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refInput = ref();
    const refGridWrapper = ref();
    const refOptionPanel = ref();
    const refGrid = ref();
    const reactData = reactive({
      initialized: false,
      tableColumns: [],
      fullOptionList: [],
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = createInternalData4();
    const refMaps = {
      refElem
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (import_xe_utils90.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computePropsOpts = computed(() => {
      return props.optionProps || {};
    });
    const computeRowOpts = computed(() => {
      const gridOpts = computeGridOpts.value;
      return Object.assign({}, gridOpts.rowConfig, {
        isCurrent: true
      });
    });
    const computeRowKeyField = computed(() => {
      const rowOpts = computeRowOpts.value;
      return rowOpts.keyField || "_X_ROW_KEY";
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computePopupOpts = computed(() => {
      return Object.assign({}, getConfig().tableSelect.popupConfig, props.popupConfig);
    });
    const computeGridOpts = computed(() => {
      return Object.assign({}, getConfig().tableSelect.gridConfig, props.gridConfig, {
        data: void 0
      });
    });
    const computeSelectGridOpts = computed(() => {
      const gridOpts = computeGridOpts.value;
      const { pagerConfig, proxyConfig } = gridOpts;
      if (proxyConfig) {
        const proxyAjax = proxyConfig.ajax;
        if (proxyAjax && proxyAjax.query) {
          const newProxyConfig = import_xe_utils90.default.clone(proxyConfig, true);
          const ajaxMethods = proxyAjax.query;
          if (ajaxMethods) {
            const resConfigs = proxyConfig.response || proxyConfig.props || {};
            Object.assign(newProxyConfig.ajax, {
              query(params, ...args) {
                return Promise.resolve(ajaxMethods(params, ...args)).then((rest) => {
                  let tableData = [];
                  if (pagerConfig) {
                    const resultProp = resConfigs.result;
                    tableData = (import_xe_utils90.default.isFunction(resultProp) ? resultProp({ data: rest, $table: null, $grid: null, $gantt: null }) : import_xe_utils90.default.get(rest, resultProp || "result")) || [];
                  } else {
                    const listProp = resConfigs.list;
                    tableData = (listProp ? import_xe_utils90.default.isFunction(listProp) ? listProp({ data: rest, $table: null, $grid: null, $gantt: null }) : import_xe_utils90.default.get(rest, listProp) : rest) || [];
                  }
                  cacheDataMap(tableData || []);
                  return rest;
                });
              }
            });
          }
          return Object.assign({}, gridOpts, { proxyConfig: newProxyConfig });
        }
      }
      return gridOpts;
    });
    const computeSelectLabel = computed(() => {
      const { modelValue, lazyOptions } = props;
      const { fullOptionList } = reactData;
      const { fullRowMaps } = internalData;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      if (!fullOptionList) {
        return "";
      }
      return (import_xe_utils90.default.isArray(modelValue) ? modelValue : [modelValue]).map((val) => {
        const cacheItem = fullRowMaps[val];
        if (cacheItem) {
          return cacheItem.item[labelField];
        }
        if (lazyOptions) {
          const lazyItem = lazyOptions.find((item) => item[valueField] === val);
          if (lazyItem) {
            return lazyItem[labelField];
          }
        }
        return val;
      }).join(", ");
    });
    const computePopupWrapperStyle = computed(() => {
      const popupOpts = computePopupOpts.value;
      const { height, width } = popupOpts;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {};
    const $xeTableSelect = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const gridEventKeys = [
      "form-submit",
      "form-reset",
      "form-collapse",
      "page-change"
    ];
    const gridEvents = {};
    gridEventKeys.forEach((name) => {
      gridEvents[getOnName(import_xe_utils90.default.camelCase(name))] = (params) => {
        dispatchEvent(name, params, params.$event);
      };
    });
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tableSelect: $xeTableSelect }, params));
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const tableSelectMethods = {
      dispatchEvent
    };
    const tableSelectPrivateMethods = {};
    const getRowid = (option) => {
      const nodeKeyField = computeRowKeyField.value;
      const rowid = option[nodeKeyField];
      return rowid ? encodeURIComponent(rowid) : "";
    };
    const getRowsByValue = (modelValue) => {
      const { fullRowMaps } = internalData;
      const rows = [];
      const vals = import_xe_utils90.default.eqNull(modelValue) ? [] : import_xe_utils90.default.isArray(modelValue) ? modelValue : [modelValue];
      vals.forEach((val) => {
        const cacheItem = fullRowMaps[val];
        if (cacheItem) {
          rows.push(cacheItem.item);
        }
      });
      return rows;
    };
    const updateModel = (modelValue) => {
      const { multiple } = props;
      nextTick(() => {
        const $grid = refGrid.value;
        if ($grid) {
          const selectList = getRowsByValue(modelValue);
          if (selectList.length) {
            if (multiple) {
              $grid.setCheckboxRow(selectList, true);
            } else {
              $grid.setRadioRow(selectList[0]);
            }
          }
        }
      });
    };
    const loadTableColumn = (columns) => {
      if (!columns || !columns.length) {
        return;
      }
      const { multiple } = props;
      const tableCols = [];
      let hasRadioCol = false;
      let hasCheckboxCol = false;
      columns.forEach((column) => {
        if (!hasRadioCol && column.type === "radio") {
          hasRadioCol = true;
        } else if (!hasCheckboxCol && column.type === "checkbox") {
          hasCheckboxCol = true;
        }
        tableCols.push(column);
      });
      if (multiple) {
        if (!hasCheckboxCol) {
          tableCols.unshift({
            type: "checkbox",
            width: 70
          });
        }
      } else {
        if (!hasRadioCol) {
          tableCols.unshift({
            type: "radio",
            width: 70
          });
        }
      }
      reactData.tableColumns = tableCols;
    };
    const cacheDataMap = (dataList) => {
      const { options } = props;
      const rowKeyField = computeRowKeyField.value;
      const valueField = computeValueField.value;
      const gridOpts = computeGridOpts.value;
      const { treeConfig, pagerConfig } = gridOpts;
      const rowMaps = {};
      const keyMaps = {};
      if (treeConfig) {
      } else {
        import_xe_utils90.default.arrayEach(dataList || options || [], (item, index, items) => {
          let rowid = getRowid(item);
          if (!rowid) {
            rowid = getRowUniqueId();
          }
          if (keyMaps[rowid]) {
            errLog("vxe.error.repeatKey", [`[table-select] ${rowKeyField}`, rowid]);
          }
          keyMaps[rowid] = true;
          const value = item[valueField];
          if (rowMaps[value]) {
            errLog("vxe.error.repeatKey", [`[table-select] ${valueField}`, value]);
          }
          rowMaps[value] = { item, index, items, parent: null, nodes: [] };
        });
      }
      reactData.fullOptionList = dataList || options || [];
      internalData.fullRowMaps = pagerConfig ? Object.assign({}, internalData.fullRowMaps, rowMaps) : rowMaps;
      updateModel(props.modelValue);
    };
    const updateZindex = () => {
      const { zIndex } = props;
      if (zIndex) {
        reactData.panelIndex = zIndex;
      } else if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const { placement } = props;
      const { panelIndex } = reactData;
      const targetElem = refElem.value;
      const panelElem = refOptionPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return nextTick().then(handleStyle);
    };
    const showOptionPanel = () => {
      const { loading: loading2 } = props;
      const isDisabled = computeIsDisabled.value;
      if (!loading2 && !isDisabled) {
        if (internalData.vpTimeout) {
          clearTimeout(internalData.vpTimeout);
        }
        if (internalData.hpTimeout) {
          clearTimeout(internalData.hpTimeout);
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        internalData.vpTimeout = setTimeout(() => {
          reactData.visiblePanel = true;
          updateModel(props.modelValue);
          internalData.vpTimeout = void 0;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      if (internalData.vpTimeout) {
        clearTimeout(internalData.vpTimeout);
      }
      if (internalData.hpTimeout) {
        clearTimeout(internalData.hpTimeout);
      }
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
        internalData.hpTimeout = void 0;
      }, 350);
    };
    const changeEvent = (evnt, selectValue, row) => {
      emitModel(selectValue);
      if (selectValue !== props.modelValue) {
        dispatchEvent("change", { value: selectValue, row, option: row }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue, null);
      dispatchEvent("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { visiblePanel, isActivated } = reactData;
      if (visiblePanel) {
        hideOptionPanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const { visiblePanel } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    const focusEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 150);
        }
      }
      dispatchEvent("focus", {}, evnt);
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      dispatchEvent("click", {}, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      dispatchEvent("blur", {}, evnt);
    };
    const togglePanelEvent = (params) => {
      const { $event } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const radioChangeEvent = (params) => {
      const { $event, row } = params;
      const valueField = computeValueField.value;
      const value = row[valueField];
      changeEvent($event, value, row);
      hideOptionPanel();
    };
    const checkboxChangeEvent = (params) => {
      const { $grid, $event, row } = params;
      const valueField = computeValueField.value;
      if ($grid) {
        const checkboxRecords = $grid.getCheckboxRecords();
        const value = checkboxRecords.map((row2) => {
          return row2[valueField];
        });
        changeEvent($event, value, row);
      }
    };
    const checkboxAllEvent = (params) => {
      checkboxChangeEvent(params);
    };
    Object.assign($xeTableSelect, tableSelectMethods, tableSelectPrivateMethods);
    const renderVN = () => {
      const { className, options, loading: loading2 } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel, tableColumns } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const popupOpts = computePopupOpts.value;
      const { className: popupClassName } = popupOpts;
      const selectGridOpts = computeSelectGridOpts.value;
      const rowOpts = computeRowOpts.value;
      const popupWrapperStyle = computePopupWrapperStyle.value;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-table-select--readonly", className]
        }, [
          h("span", {
            class: "vxe-table-select-label"
          }, selectLabel)
        ]);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-table-select", className ? import_xe_utils90.default.isFunction(className) ? className({ $tableSelect: $xeTableSelect }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--loading": loading2,
          "is--active": isActivated
        }]
      }, [
        h(input_default, {
          ref: refInput,
          clearable: props.clearable,
          placeholder: loading2 ? getI18n("vxe.select.loadingText") : props.placeholder,
          readonly: true,
          disabled: isDisabled,
          type: "text",
          prefixIcon: props.prefixIcon,
          suffixIcon: loading2 ? getIcon().TABLE_SELECT_LOADED : visiblePanel ? getIcon().TABLE_SELECT_OPEN : getIcon().TABLE_SELECT_CLOSE,
          modelValue: loading2 ? "" : selectLabel,
          onClear: clearEvent,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent,
          onSuffixClick: togglePanelEvent
        }, prefixSlot ? {
          prefix: () => prefixSlot({})
        } : {}),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-table-select--panel", popupClassName ? import_xe_utils90.default.isFunction(popupClassName) ? popupClassName({ $tableSelect: $xeTableSelect }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": !loading2 && isAniVisible,
              "ani--enter": !loading2 && visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, initialized ? [
            h("div", {
              class: "vxe-table-select--panel-wrapper"
            }, [
              headerSlot ? h("div", {
                class: "vxe-table-select--panel-header"
              }, headerSlot({})) : renderEmptyElement($xeTableSelect),
              h("div", {
                class: "vxe-table-select--panel-body"
              }, [
                h("div", {
                  ref: refGridWrapper,
                  class: "vxe-table-select-grid--wrapper",
                  style: popupWrapperStyle
                }, [
                  VxeTableGridComponent ? h(VxeTableGridComponent, Object.assign(Object.assign(Object.assign({}, selectGridOpts), gridEvents), { class: "vxe-table-select--grid", ref: refGrid, rowConfig: rowOpts, data: options, columns: tableColumns.length ? tableColumns : selectGridOpts.columns, height: "100%", autoResize: true, onRadioChange: radioChangeEvent, onCheckboxChange: checkboxChangeEvent, onCheckboxAll: checkboxAllEvent }), Object.assign({}, slots, {
                    header: void 0,
                    footer: void 0,
                    prefixSlot: void 0
                  })) : renderEmptyElement($xeTableSelect)
                ])
              ]),
              footerSlot ? h("div", {
                class: "vxe-table-select--panel-footer"
              }, footerSlot({})) : renderEmptyElement($xeTableSelect)
            ])
          ] : [])
        ])
      ]);
    };
    watch(() => props.options, () => {
      cacheDataMap();
    });
    watch(() => props.columns, (val) => {
      loadTableColumn(val);
    });
    watch(() => props.modelValue, (val) => {
      updateModel(val);
    });
    loadTableColumn(props.columns);
    cacheDataMap();
    onMounted(() => {
      const { gridConfig } = props;
      if (gridConfig && gridConfig.proxyConfig) {
        if (gridConfig.proxyConfig.autoLoad !== false) {
          reactData.initialized = true;
        }
      }
      globalEvents.on($xeTableSelect, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeTableSelect, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeTableSelect, "blur", handleGlobalBlurEvent);
      globalEvents.on($xeTableSelect, "resize", handleGlobalResizeEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeTableSelect, "mousewheel");
      globalEvents.off($xeTableSelect, "mousedown");
      globalEvents.off($xeTableSelect, "blur");
      globalEvents.off($xeTableSelect, "resize");
      import_xe_utils90.default.assign(internalData, createInternalData4());
    });
    nextTick(() => {
      if (!VxeTableGridComponent) {
        errLog("vxe.error.reqComp", ["[table-select] vxe-grid"]);
      }
    });
    provide("$xeTableSelect", $xeTableSelect);
    $xeTableSelect.renderVN = renderVN;
    return $xeTableSelect;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/table-select/index.js
var VxeTableSelect = Object.assign({}, table_select_default, {
  install(app) {
    app.component(table_select_default.name, table_select_default);
  }
});
dynamicApp.use(VxeTableSelect);
VxeUI.component(table_select_default);
var TableSelect = VxeTableSelect;
var table_select_default2 = VxeTableSelect;

// node_modules/vxe-pc-ui/es/tabs/src/tabs.js
var import_xe_utils91 = __toESM(require_xe_utils());
var scrollbarOffsetSize = 20;
var tabs_default = defineVxeComponent({
  name: "VxeTabs",
  props: {
    modelValue: [String, Number, Boolean],
    options: Array,
    width: [String, Number],
    height: [String, Number],
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().tabs.destroyOnClose
    },
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    type: {
      type: String,
      default: () => getConfig().tabs.type
    },
    position: {
      type: String,
      default: () => getConfig().tabs.position
    },
    showClose: Boolean,
    showBody: {
      type: Boolean,
      default: true
    },
    padding: {
      type: Boolean,
      default: () => getConfig().tabs.padding
    },
    trigger: String,
    beforeChangeMethod: Function,
    closeConfig: Object,
    refreshConfig: Object,
    size: {
      type: String,
      default: () => getConfig().tabs.size || getConfig().size
    },
    // 已废弃
    beforeCloseMethod: Function
  },
  emits: [
    "update:modelValue",
    "change",
    "tab-change",
    "tab-change-fail",
    "tab-close",
    "tab-close-fail",
    "tab-click",
    "tab-load"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils91.default.uniqueId();
    const $xeParentTabs = inject("$xeTabs", null);
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refHeadWrapperElem = ref();
    const refHeadPrevElem = ref();
    const refHeadNextElem = ref();
    const reactData = reactive({
      staticTabs: [],
      activeName: null,
      initNames: [],
      lintLeft: 0,
      lintTop: 0,
      lintWidth: 0,
      lintHeight: 0,
      scrollbarWidth: 0,
      scrollbarHeight: 0,
      isTabOver: false,
      resizeFlag: 1,
      cacheTabMaps: {}
    });
    const internalData = {
      slTimeout: void 0
    };
    const refMaps = {
      refElem
    };
    const computeTabType = computed(() => {
      const { type } = props;
      return type || "default";
    });
    const computeTabPosition = computed(() => {
      const { position } = props;
      return position || "top";
    });
    const computeLrPosition = computed(() => {
      const tabPosition = computeTabPosition.value;
      return tabPosition === "left" || tabPosition === "right";
    });
    const computeLineStyle = computed(() => {
      const { lintLeft, lintTop, lintWidth, lintHeight } = reactData;
      const lrPosition = computeLrPosition.value;
      return lrPosition ? {
        top: `${lintTop}px`,
        height: `${lintHeight}px`
      } : {
        left: `${lintLeft}px`,
        width: `${lintWidth}px`
      };
    });
    const computeWrapperStyle = computed(() => {
      const { width, height } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeCloseOpts = computed(() => {
      return Object.assign({}, getConfig().tabs.closeConfig, props.closeConfig);
    });
    const computeRefreshOpts = computed(() => {
      return Object.assign({}, getConfig().tabs.refreshConfig, props.refreshConfig);
    });
    const computeTabOptions = computed(() => {
      const { options } = props;
      return (options || []).filter((item) => handleFilterTab(item));
    });
    const computeTabStaticOptions = computed(() => {
      const { staticTabs } = reactData;
      return staticTabs.filter((item) => handleFilterTab(item));
    });
    const computeParentTabsResizeFlag = computed(() => {
      return $xeParentTabs ? $xeParentTabs.reactData.resizeFlag : null;
    });
    const computeMaps = {};
    const $xeTabs = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const handleFilterTab = (item) => {
      const { permissionCode } = item;
      if (permissionCode) {
        if (!permission.checkVisible(permissionCode)) {
          return false;
        }
      }
      return true;
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils91.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils91.default.isFunction(slotFunc)) {
          return getSlotVNs2(slotFunc(params));
        }
      }
      return [];
    };
    const checkScrolling = () => {
      const lrPosition = computeLrPosition.value;
      const headerWrapperEl = refHeadWrapperElem.value;
      const headPrevEl = refHeadPrevElem.value;
      const headNextEl = refHeadNextElem.value;
      if (headerWrapperEl) {
        const { scrollLeft, scrollTop, clientWidth, clientHeight, scrollWidth, scrollHeight } = headerWrapperEl;
        if (headPrevEl) {
          if ((lrPosition ? scrollTop : scrollLeft) > 0) {
            addClass(headPrevEl, "scrolling--middle");
          } else {
            removeClass(headPrevEl, "scrolling--middle");
          }
        }
        if (headNextEl) {
          if (lrPosition ? clientHeight < scrollHeight - Math.ceil(scrollTop) : clientWidth < scrollWidth - Math.ceil(scrollLeft)) {
            addClass(headNextEl, "scrolling--middle");
          } else {
            removeClass(headNextEl, "scrolling--middle");
          }
        }
      }
    };
    const updateTabStyle = () => {
      const handleStyle = () => {
        const { activeName } = reactData;
        const tabType = computeTabType.value;
        const tabOptions = computeTabOptions.value;
        const tabStaticOptions = computeTabStaticOptions.value;
        const headerWrapperEl = refHeadWrapperElem.value;
        const lrPosition = computeLrPosition.value;
        let lintWidth = 0;
        let lintHeight = 0;
        let lintLeft = 0;
        let lintTop = 0;
        let sBarWidth = 0;
        let sBarHeight = 0;
        let isOver = false;
        if (headerWrapperEl) {
          const index = import_xe_utils91.default.findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, (item) => item.name === activeName);
          const { children, offsetWidth, scrollWidth, offsetHeight, scrollHeight, clientWidth, clientHeight } = headerWrapperEl;
          sBarWidth = offsetWidth - clientWidth;
          sBarHeight = offsetHeight - clientHeight;
          if (lrPosition) {
            isOver = scrollHeight !== clientHeight;
            if (index > -1) {
              const tabEl = children[index];
              if (tabEl) {
                const tabHeight = tabEl.clientHeight;
                const tabWidth = tabEl.clientWidth;
                if (tabType === "card") {
                  lintWidth = tabWidth;
                  lintHeight = tabHeight;
                  lintTop = tabEl.offsetTop;
                } else if (tabType === "border-card") {
                  lintWidth = tabWidth;
                  lintHeight = tabHeight;
                  lintTop = tabEl.offsetTop - 1;
                } else {
                  lintHeight = Math.max(4, Math.floor(tabHeight * 0.6));
                  lintTop = tabEl.offsetTop + Math.floor((tabHeight - lintHeight) / 2);
                }
              }
            }
          } else {
            isOver = scrollWidth !== clientWidth;
            if (index > -1) {
              const tabEl = children[index];
              if (tabEl) {
                const tabWidth = tabEl.clientWidth;
                if (tabType === "card") {
                  lintWidth = tabWidth + 1;
                  lintLeft = tabEl.offsetLeft;
                } else if (tabType === "border-card") {
                  lintWidth = tabWidth;
                  lintLeft = tabEl.offsetLeft - 1;
                } else {
                  lintWidth = Math.max(4, Math.floor(tabWidth * 0.6));
                  lintLeft = tabEl.offsetLeft + Math.floor((tabWidth - lintWidth) / 2);
                }
              }
            }
          }
        }
        reactData.scrollbarWidth = sBarWidth;
        reactData.scrollbarHeight = sBarHeight;
        reactData.lintLeft = lintLeft;
        reactData.lintTop = lintTop;
        reactData.lintWidth = lintWidth;
        reactData.lintHeight = lintHeight;
        reactData.isTabOver = isOver;
        checkScrolling();
      };
      handleStyle();
      nextTick(handleStyle);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tabs: $xeTabs }, params));
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const addInitName = (name, evnt) => {
      const { initNames } = reactData;
      if (name && !initNames.includes(name)) {
        dispatchEvent("tab-load", { name }, evnt);
        initNames.push(name);
        return true;
      }
      return false;
    };
    const initDefaultName = (list) => {
      let activeName = null;
      const nameMaps = {};
      if (list && list.length) {
        let validVal = false;
        activeName = props.modelValue;
        list.forEach((item) => {
          const { name, preload } = item || {};
          if (name) {
            nameMaps[`${name}`] = {
              loading: false
            };
            if (activeName === name) {
              validVal = true;
            }
            if (preload) {
              addInitName(name, null);
            }
          }
        });
        if (!validVal) {
          activeName = list[0].name;
          addInitName(activeName, null);
          emitModel(activeName);
        }
      }
      reactData.activeName = activeName;
      reactData.cacheTabMaps = nameMaps;
    };
    const clickEvent = (evnt, item) => {
      const { trigger } = props;
      const beforeMethod = props.beforeChangeMethod || getConfig().tabs.beforeChangeMethod;
      const { activeName } = reactData;
      const { name } = item;
      const value = name;
      dispatchEvent("tab-click", { name }, evnt);
      if (trigger === "manual") {
        return;
      }
      if (name !== activeName) {
        Promise.resolve(!beforeMethod || beforeMethod({ $tabs: $xeTabs, name, oldName: activeName, newName: name, option: item })).then((status) => {
          if (status) {
            reactData.activeName = name;
            emitModel(value);
            addInitName(name, evnt);
            dispatchEvent("change", { value, name, oldName: activeName, newName: name, option: item }, evnt);
            dispatchEvent("tab-change", { value, name, oldName: activeName, newName: name, option: item }, evnt);
          } else {
            dispatchEvent("tab-change-fail", { value, name, oldName: activeName, newName: name, option: item }, evnt);
          }
        }).catch(() => {
          dispatchEvent("tab-change-fail", { value, name, oldName: activeName, newName: name, option: item }, evnt);
        });
      }
    };
    const handleRefreshTabEvent = (evnt, item) => {
      evnt.stopPropagation();
      const { activeName, cacheTabMaps } = reactData;
      const { name } = item;
      const refreshOpts = computeRefreshOpts.value;
      const { queryMethod } = refreshOpts;
      const cacheItem = name ? cacheTabMaps[`${name}`] : null;
      if (cacheItem) {
        if (queryMethod) {
          if (cacheItem.loading) {
            return;
          }
          cacheItem.loading = true;
          Promise.resolve(queryMethod({ $tabs: $xeTabs, value: activeName, name, option: item })).finally(() => {
            cacheItem.loading = false;
          });
        } else {
          errLog("vxe.error.notFunc", ["refresh-config.queryMethod"]);
        }
      }
    };
    const handleCloseTabEvent = (evnt, item, index, list) => {
      evnt.stopPropagation();
      const { activeName } = reactData;
      const closeOpts = computeCloseOpts.value;
      const beforeMethod = closeOpts.beforeMethod || props.beforeCloseMethod || getConfig().tabs.beforeCloseMethod;
      const { name } = item;
      const value = activeName;
      let nextName = value;
      if (activeName === name) {
        const nextItem = index < list.length - 1 ? list[index + 1] : list[index - 1];
        nextName = nextItem ? nextItem.name : null;
      }
      Promise.resolve(!beforeMethod || beforeMethod({ $tabs: $xeTabs, value, name, nextName, option: item })).then((status) => {
        if (status) {
          dispatchEvent("tab-close", { value, name, nextName }, evnt);
        } else {
          dispatchEvent("tab-close-fail", { value, name, nextName }, evnt);
        }
      }).catch(() => {
        dispatchEvent("tab-close-fail", { value, name, nextName }, evnt);
      });
    };
    const startScrollAnimation = (offsetPos, offsetSize) => {
      const { slTimeout } = internalData;
      const lrPosition = computeLrPosition.value;
      let offsetLeft = lrPosition ? 0 : offsetSize;
      let offsetTop = lrPosition ? offsetSize : 0;
      let scrollCount = 6;
      let delayNum = 35;
      if (slTimeout) {
        clearTimeout(slTimeout);
        internalData.slTimeout = void 0;
      }
      const scrollAnimate = () => {
        const headerWrapperEl = refHeadWrapperElem.value;
        if (scrollCount > 0) {
          scrollCount--;
          if (headerWrapperEl) {
            const { clientWidth, clientHeight, scrollWidth, scrollHeight, scrollLeft, scrollTop } = headerWrapperEl;
            if (lrPosition) {
              offsetTop = Math.floor(offsetTop / 2);
              if (offsetPos > 0) {
                if (clientHeight + scrollTop < scrollHeight) {
                  headerWrapperEl.scrollTop += offsetTop;
                  delayNum -= 4;
                  internalData.slTimeout = setTimeout(scrollAnimate, delayNum);
                }
              } else {
                if (scrollTop > 0) {
                  headerWrapperEl.scrollTop -= offsetTop;
                  delayNum -= 4;
                  internalData.slTimeout = setTimeout(scrollAnimate, delayNum);
                }
              }
            } else {
              offsetLeft = Math.floor(offsetLeft / 2);
              if (offsetPos > 0) {
                if (clientWidth + scrollLeft < scrollWidth) {
                  headerWrapperEl.scrollLeft += offsetLeft;
                  delayNum -= 4;
                  internalData.slTimeout = setTimeout(scrollAnimate, delayNum);
                }
              } else {
                if (scrollLeft > 0) {
                  headerWrapperEl.scrollLeft -= offsetLeft;
                  delayNum -= 4;
                  internalData.slTimeout = setTimeout(scrollAnimate, delayNum);
                }
              }
            }
            updateTabStyle();
          }
        }
      };
      scrollAnimate();
    };
    const handleScrollToLeft = (offsetPos) => {
      const lrPosition = computeLrPosition.value;
      const headerWrapperEl = refHeadWrapperElem.value;
      if (headerWrapperEl) {
        const { clientWidth, clientHeight } = headerWrapperEl;
        const offsetSize = Math.floor((lrPosition ? clientHeight : clientWidth) * 0.75);
        startScrollAnimation(offsetPos, offsetSize);
      }
    };
    const scrollLeftEvent = () => {
      handleScrollToLeft(-1);
    };
    const scrollRightEvent = () => {
      handleScrollToLeft(1);
    };
    const scrollToTab = (name) => {
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      const lrPosition = computeLrPosition.value;
      return nextTick().then(() => {
        const headerWrapperEl = refHeadWrapperElem.value;
        if (headerWrapperEl) {
          const index = import_xe_utils91.default.findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, (item) => item.name === name);
          if (index > -1) {
            const { scrollLeft, scrollTop, clientWidth, clientHeight, children } = headerWrapperEl;
            const tabEl = children[index];
            if (tabEl) {
              if (lrPosition) {
                const tabOffsetTop = tabEl.offsetTop;
                const tabClientHeight = tabEl.clientHeight;
                const overSize = tabOffsetTop + tabClientHeight - (scrollTop + clientHeight);
                if (overSize > 0) {
                  headerWrapperEl.scrollTop += overSize;
                }
                if (tabOffsetTop < scrollTop) {
                  headerWrapperEl.scrollTop = tabOffsetTop;
                }
              } else {
                const tabOffsetLeft = tabEl.offsetLeft;
                const tabClientWidth = tabEl.clientWidth;
                const overSize = tabOffsetLeft + tabClientWidth - (scrollLeft + clientWidth);
                if (overSize > 0) {
                  headerWrapperEl.scrollLeft += overSize;
                }
                if (tabOffsetLeft < scrollLeft) {
                  headerWrapperEl.scrollLeft = tabOffsetLeft;
                }
              }
            }
          }
          updateTabStyle();
        }
      });
    };
    const handlePrevNext = (isNext) => {
      const { activeName } = reactData;
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      const list = tabStaticOptions.length ? tabStaticOptions : tabOptions;
      const index = import_xe_utils91.default.findIndexOf(list, (item) => item.name === activeName);
      if (index > -1) {
        let item = null;
        if (isNext) {
          if (index < list.length - 1) {
            item = list[index + 1];
          }
        } else {
          if (index > 0) {
            item = list[index - 1];
          }
        }
        if (item) {
          const name = item.name;
          const value = name;
          reactData.activeName = name;
          emitModel(value);
          addInitName(name, null);
        }
      }
      return nextTick();
    };
    const tabsMethods = {
      dispatchEvent,
      scrollToTab,
      prev() {
        return handlePrevNext(false);
      },
      next() {
        return handlePrevNext(true);
      },
      prevTab() {
        warnLog("vxe.error.delFunc", ["[tabs] prevTab", "prev"]);
        return tabsMethods.prev();
      },
      nextTab() {
        warnLog("vxe.error.delFunc", ["[tabs] nextTab", "next"]);
        return tabsMethods.next();
      }
    };
    const tabsPrivateMethods = {};
    Object.assign($xeTabs, tabsMethods, tabsPrivateMethods);
    const renderTabHeader = (tabList) => {
      const { titleWidth: allTitleWidth, titleAlign: allTitleAlign, showClose, closeConfig, refreshConfig } = props;
      const { activeName, scrollbarWidth, scrollbarHeight, isTabOver, cacheTabMaps } = reactData;
      const tabType = computeTabType.value;
      const tabPosition = computeTabPosition.value;
      const lrPosition = computeLrPosition.value;
      const lineStyle = computeLineStyle.value;
      const tabPrefixSlot = slots.tabPrefix || slots["tab-prefix"] || slots.prefix;
      const tabSuffixSlot = slots.tabSuffix || slots["tab-suffix"] || slots.suffix || slots.extra;
      const closeOpts = computeCloseOpts.value;
      const closeVisibleMethod = closeOpts.visibleMethod;
      const refreshOpts = computeRefreshOpts.value;
      const refreshVisibleMethod = refreshOpts.visibleMethod;
      return h("div", {
        key: "th",
        class: ["vxe-tabs-header", `type--${tabType}`, `pos--${tabPosition}`]
      }, [
        tabPrefixSlot ? h("div", {
          class: ["vxe-tabs-header--prefix", `type--${tabType}`, `pos--${tabPosition}`]
        }, callSlot(tabPrefixSlot, { name: activeName })) : renderEmptyElement($xeTabs),
        isTabOver ? h("div", {
          ref: refHeadPrevElem,
          class: ["vxe-tabs-header--bar vxe-tabs-header--prev-bar", `type--${tabType}`, `pos--${tabPosition}`],
          onClick: scrollLeftEvent
        }, [
          h("span", {
            class: lrPosition ? getIcon().TABS_TAB_BUTTON_TOP : getIcon().TABS_TAB_BUTTON_LEFT
          })
        ]) : renderEmptyElement($xeTabs),
        h("div", {
          class: ["vxe-tabs-header--wrapper", `type--${tabType}`, `pos--${tabPosition}`]
        }, [
          h("div", {
            ref: refHeadWrapperElem,
            class: "vxe-tabs-header--item-wrapper",
            style: lrPosition ? {
              marginRight: `-${scrollbarWidth + scrollbarOffsetSize}px`,
              paddingRight: `${scrollbarOffsetSize}px`
            } : {
              marginBottom: `-${scrollbarHeight + scrollbarOffsetSize}px`,
              paddingBottom: `${scrollbarOffsetSize}px`
            },
            onScroll: checkScrolling
          }, tabList.map((item, index) => {
            const { title, titleWidth, titleAlign, icon, name } = item;
            const itemSlots = item.slots || {};
            const titleSlot = itemSlots.title || itemSlots.tab;
            const titlePrefixSlot = itemSlots.titlePrefix || itemSlots["title-prefix"];
            const titleSuffixSlot = itemSlots.titleSuffix || itemSlots["title-suffix"];
            const itemWidth = titleWidth || allTitleWidth;
            const itemAlign = titleAlign || allTitleAlign;
            const params = { $tabs: $xeTabs, value: activeName, name, option: item };
            const isActive = activeName === name;
            const cacheItem = name ? cacheTabMaps[`${name}`] : null;
            const isLoading = cacheItem ? cacheItem.loading : false;
            return h("div", {
              key: `${name}`,
              class: ["vxe-tabs-header--item", `type--${tabType}`, `pos--${tabPosition}`, itemAlign ? `align--${itemAlign}` : "", {
                "is--active": isActive
              }],
              style: itemWidth ? {
                width: toCssUnit(itemWidth)
              } : void 0,
              onClick(evnt) {
                clickEvent(evnt, item);
              }
            }, [
              h("div", {
                class: "vxe-tabs-header--item-inner"
              }, [
                h("div", {
                  class: "vxe-tabs-header--item-content"
                }, [
                  icon ? h("span", {
                    class: "vxe-tabs-header--item-icon"
                  }, [
                    h("i", {
                      class: icon
                    })
                  ]) : renderEmptyElement($xeTabs),
                  titlePrefixSlot ? h("span", {
                    class: "vxe-tabs-header--item-prefix"
                  }, callSlot(titlePrefixSlot, { name, title })) : renderEmptyElement($xeTabs),
                  h("span", {
                    class: "vxe-tabs-header--item-name"
                  }, titleSlot ? callSlot(titleSlot, { name, title }) : `${title}`),
                  titleSuffixSlot ? h("span", {
                    class: "vxe-tabs-header--item-suffix"
                  }, callSlot(titleSuffixSlot, { name, title })) : renderEmptyElement($xeTabs)
                ]),
                (isEnableConf(refreshConfig) || refreshOpts.enabled) && (refreshVisibleMethod ? refreshVisibleMethod(params) : true) ? h("div", {
                  class: ["vxe-tabs-header--refresh-btn", {
                    "is--active": isActive,
                    "is--loading": isLoading,
                    "is--disabled": isLoading
                  }],
                  onClick(evnt) {
                    handleRefreshTabEvent(evnt, item);
                  }
                }, [
                  h("i", {
                    class: isLoading ? getIcon().TABS_TAB_REFRESH_LOADING : getIcon().TABS_TAB_REFRESH
                  })
                ]) : renderEmptyElement($xeTabs),
                (showClose || (isEnableConf(closeConfig) || closeOpts.enabled)) && (!closeVisibleMethod || closeVisibleMethod(params)) ? h("div", {
                  class: ["vxe-tabs-header--close-btn", {
                    "is--active": isActive
                  }],
                  onClick(evnt) {
                    handleCloseTabEvent(evnt, item, index, tabList);
                  }
                }, [
                  h("i", {
                    class: getIcon().TABS_TAB_CLOSE
                  })
                ]) : renderEmptyElement($xeTabs)
              ])
            ]);
          }).concat([
            h("span", {
              key: "line",
              class: ["vxe-tabs-header--active-line", `type--${tabType}`, `pos--${tabPosition}`],
              style: lineStyle
            })
          ]))
        ]),
        isTabOver ? h("div", {
          ref: refHeadNextElem,
          class: ["vxe-tabs-header--bar vxe-tabs-header--next-bar", `type--${tabType}`, `pos--${tabPosition}`],
          onClick: scrollRightEvent
        }, [
          h("span", {
            class: lrPosition ? getIcon().TABS_TAB_BUTTON_BOTTOM : getIcon().TABS_TAB_BUTTON_RIGHT
          })
        ]) : renderEmptyElement($xeTabs),
        tabSuffixSlot ? h("div", {
          class: ["vxe-tabs-header--suffix", `type--${tabType}`, `pos--${tabPosition}`]
        }, callSlot(tabSuffixSlot, { name: activeName })) : renderEmptyElement($xeTabs)
      ]);
    };
    const renderTabPane = (item) => {
      const { initNames, activeName } = reactData;
      const { name, slots: slots2 } = item;
      const defaultSlot = slots2 ? slots2.default : null;
      return name && initNames.includes(name) ? h("div", {
        key: `${name}`,
        class: ["vxe-tabs-pane--item", {
          "is--visible": activeName === name
        }]
      }, defaultSlot ? callSlot(defaultSlot, { name }) : []) : renderEmptyElement($xeTabs);
    };
    const renderTabContent = (tabList) => {
      const { destroyOnClose } = props;
      const { activeName } = reactData;
      if (destroyOnClose) {
        const activeTab = tabList.find((item) => item.name === activeName);
        return [activeTab ? renderTabPane(activeTab) : renderEmptyElement($xeTabs)];
      }
      return tabList.map((item) => renderTabPane(item));
    };
    const rendetTabBody = (tabList) => {
      const { height, padding, showBody } = props;
      const { activeName, cacheTabMaps } = reactData;
      const vSize = computeSize.value;
      const tabType = computeTabType.value;
      const tabPosition = computeTabPosition.value;
      const refreshOpts = computeRefreshOpts.value;
      const { showLoading } = refreshOpts;
      const headerpSlot = slots.header;
      const footerSlot = slots.footer;
      if (!showBody) {
        return renderEmptyElement($xeTabs);
      }
      const cacheItem = activeName ? cacheTabMaps[`${activeName}`] : null;
      const isLoading = cacheItem ? cacheItem.loading : false;
      const defParams = { name: activeName };
      return h("div", {
        key: "tb",
        class: ["vxe-tabs-pane--wrapper", `type--${tabType}`, `pos--${tabPosition}`, {
          "is--content": showBody
        }]
      }, [
        headerpSlot ? h("div", {
          class: "vxe-tabs-pane--header"
        }, callSlot(headerpSlot, defParams)) : renderEmptyElement($xeTabs),
        h("div", {
          class: ["vxe-tabs-pane--body", `type--${tabType}`, `pos--${tabPosition}`, {
            [`size--${vSize}`]: vSize,
            "is--padding": padding,
            "is--height": height
          }]
        }, renderTabContent(tabList)),
        footerSlot ? h("div", {
          class: "vxe-tabs-pane--footer"
        }, callSlot(footerSlot, defParams)) : renderEmptyElement($xeTabs),
        showLoading && isLoading ? renderEmptyElement($xeTabs) : h(loading_default, {
          class: "vxe-tabs--loading",
          modelValue: isLoading
        })
      ]);
    };
    const renderVN = () => {
      const { height, padding, trigger } = props;
      const { activeName } = reactData;
      const vSize = computeSize.value;
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      const tabType = computeTabType.value;
      const tabPosition = computeTabPosition.value;
      const wrapperStyle = computeWrapperStyle.value;
      const defaultSlot = slots.default;
      const tabList = defaultSlot ? tabStaticOptions : tabOptions;
      const vns = [
        h("div", {
          key: "ts",
          class: "vxe-tabs-slots"
        }, defaultSlot ? defaultSlot({ name: activeName }) : [])
      ];
      if (tabPosition === "right" || tabPosition === "bottom") {
        vns.push(rendetTabBody(tabList), renderTabHeader(tabList));
      } else {
        vns.push(renderTabHeader(tabList), rendetTabBody(tabList));
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-tabs", `pos--${tabPosition}`, `vxe-tabs--${tabType}`, `trigger--${trigger === "manual" ? "trigger" : "default"}`, {
          [`size--${vSize}`]: vSize,
          "is--padding": padding,
          "is--height": height
        }],
        style: wrapperStyle
      }, vns);
    };
    watch(() => props.position, () => {
      reactData.resizeFlag++;
    });
    watch(() => props.modelValue, (val) => {
      addInitName(val, null);
      reactData.activeName = val;
    });
    watch(() => reactData.activeName, (val) => {
      scrollToTab(val);
    });
    const optsFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    watch(() => props.options, () => {
      optsFlag.value++;
    });
    watch(optsFlag, () => {
      initDefaultName(props.options);
      reactData.resizeFlag++;
    });
    const stFlag = ref(0);
    watch(() => reactData.staticTabs ? reactData.staticTabs.length : -1, () => {
      stFlag.value++;
    });
    watch(() => reactData.staticTabs, () => {
      stFlag.value++;
    });
    watch(stFlag, () => {
      initDefaultName(reactData.staticTabs);
      reactData.resizeFlag++;
    });
    watch(computeParentTabsResizeFlag, () => {
      reactData.resizeFlag++;
    });
    watch(() => reactData.resizeFlag, () => {
      nextTick(() => {
        updateTabStyle();
      });
    });
    onMounted(() => {
      updateTabStyle();
      globalEvents.on($xeTabs, "resize", updateTabStyle);
    });
    onUnmounted(() => {
      globalEvents.off($xeTabs, "resize");
    });
    provide("$xeTabs", $xeTabs);
    addInitName(props.modelValue, null);
    initDefaultName(reactData.staticTabs.length ? reactData.staticTabs : props.options);
    $xeTabs.renderVN = renderVN;
    return $xeTabs;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/tabs/index.js
var VxeTabs = Object.assign({}, tabs_default, {
  install(app) {
    app.component(tabs_default.name, tabs_default);
  }
});
dynamicApp.use(VxeTabs);
VxeUI.component(tabs_default);
var Tabs = VxeTabs;
var tabs_default2 = VxeTabs;

// node_modules/vxe-pc-ui/es/tag/src/tag.js
var import_xe_utils92 = __toESM(require_xe_utils());
var tag_default = defineVxeComponent({
  name: "VxeTag",
  props: {
    border: {
      type: Boolean,
      default: () => getConfig().tag.border
    },
    visible: {
      type: Boolean,
      default: null
    },
    status: String,
    title: [String, Number],
    icon: String,
    closeIcon: {
      type: String,
      default: () => getConfig().tag.closeIcon
    },
    content: [String, Number],
    round: Boolean,
    closable: {
      type: Boolean,
      default: () => getConfig().tag.closable
    },
    color: String,
    loading: Boolean,
    size: {
      type: String,
      default: () => getConfig().tag.size || getConfig().size
    }
  },
  emits: [
    "click",
    "dblclick",
    "close",
    "update:visible"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils92.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({
      showTag: props.visible !== false
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTag = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tag: $xeTag }, params));
    };
    const tagMethods = {
      dispatchEvent
    };
    const tagPrivateMethods = {};
    const updateVisible = () => {
      reactData.showTag = props.visible !== false;
    };
    const clickEvent = (evnt) => {
      const { loading: loading2 } = props;
      if (!loading2) {
        dispatchEvent("click", {}, evnt);
      }
    };
    const dblclickEvent = (evnt) => {
      const { loading: loading2 } = props;
      if (!loading2) {
        dispatchEvent("dblclick", {}, evnt);
      }
    };
    const closeEvent = (evnt) => {
      const { loading: loading2 } = props;
      if (!loading2) {
        const visible = !reactData.showTag;
        reactData.showTag = visible;
        emit("update:visible", visible);
        dispatchEvent("close", { visible }, evnt);
      }
    };
    Object.assign($xeTag, tagMethods, tagPrivateMethods);
    const renderContent = () => {
      const { icon, content, closable, closeIcon, loading: loading2 } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      const closeIconSlot = slots.closeIcon || slots["close-icon"];
      return [
        iconSlot || icon ? h("span", {
          class: "vxe-tag--icon"
        }, iconSlot ? iconSlot({}) : [
          h("i", {
            class: icon
          })
        ]) : renderEmptyElement($xeTag),
        h("span", {
          class: "vxe-tag--content"
        }, defaultSlot ? defaultSlot({}) : import_xe_utils92.default.toValueString(content)),
        loading2 || closable ? h("span", {
          class: loading2 ? "vxe-tag--loading" : "vxe-tag--close",
          onClick: closeEvent
        }, !loading2 && closeIconSlot ? closeIconSlot({}) : [
          h("i", {
            class: loading2 ? getIcon().TAG_LOADING : closeIcon || getIcon().TAG_CLOSE
          })
        ]) : renderEmptyElement($xeTag)
      ];
    };
    const renderVN = () => {
      const { status, color, title, round, border, loading: loading2 } = props;
      const { showTag } = reactData;
      const vSize = computeSize.value;
      if (!showTag) {
        return renderEmptyElement($xeTag);
      }
      return h("span", {
        ref: refElem,
        class: ["vxe-tag", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status && !color,
          [`color--${color}`]: color && !status,
          "is--round": round,
          "is--border": border,
          "is--loading": loading2
        }],
        title,
        onClick: clickEvent,
        onDblclick: dblclickEvent
      }, renderContent());
    };
    watch(() => props.visible, () => {
      updateVisible();
    });
    updateVisible();
    $xeTag.renderVN = renderVN;
    return $xeTag;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/tag/index.js
var VxeTag = Object.assign({}, tag_default, {
  install(app) {
    app.component(tag_default.name, tag_default);
  }
});
dynamicApp.use(VxeTag);
VxeUI.component(tag_default);
var Tag = VxeTag;
var tag_default2 = VxeTag;

// node_modules/vxe-pc-ui/es/text-ellipsis/src/text-ellipsis.js
var import_xe_utils93 = __toESM(require_xe_utils());
var text_ellipsis_default = defineVxeComponent({
  name: "VxeTextEllipsis",
  props: {
    href: String,
    target: String,
    content: [String, Number],
    lineClamp: [String, Number],
    status: String,
    title: [String, Number],
    loading: Boolean,
    offsetLength: [String, Number],
    routerLink: Object,
    underline: {
      type: Boolean,
      default: () => getConfig().textEllipsis.underline
    },
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => getConfig().textEllipsis.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils93.default.uniqueId();
    const { computeSize } = useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const refElem = ref();
    const realityElem = ref();
    const reactData = reactive({
      resizeObserver: null,
      visibleLen: 0
    });
    const refMaps = {
      refElem
    };
    const computeTextLineClamp = computed(() => {
      return import_xe_utils93.default.toNumber(props.lineClamp);
    });
    const computeTextContent = computed(() => {
      return import_xe_utils93.default.toValueString(props.content);
    });
    const computeTextOffsetLength = computed(() => {
      return props.offsetLength ? import_xe_utils93.default.toNumber(props.offsetLength) : 0;
    });
    const computeVisibleContent = computed(() => {
      const { visibleLen } = reactData;
      const textLineClamp = computeTextLineClamp.value;
      const textContent = computeTextContent.value;
      const textOffsetLength = computeTextOffsetLength.value;
      if (textLineClamp > 1) {
        if (textContent.length > visibleLen) {
          return `${textContent.slice(0, Math.max(1, visibleLen - 3 + textOffsetLength))}...`;
        }
        return textContent;
      }
      return textContent;
    });
    const computeMaps = {};
    const $xeTextEllipsis = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $textEllipsis: $xeTextEllipsis }, params));
    };
    const calculateFont = (targetWidth) => {
      const el = refElem.value;
      const ryEl = realityElem.value;
      if (el && ryEl) {
        let fontSize = 12;
        try {
          fontSize = Math.max(10, import_xe_utils93.default.toNumber(getComputedStyle(ryEl).fontSize));
        } catch (e) {
        }
        const textContent = computeTextContent.value;
        let currIndex = Math.floor(targetWidth / fontSize);
        let currStr = textContent.slice(0, currIndex);
        ryEl.textContent = currStr;
        reactData.visibleLen = currStr.length;
        let maxCount = 0;
        while (targetWidth > ryEl.clientWidth && maxCount < 30) {
          maxCount++;
          const offsetIndex = Math.floor((targetWidth - ryEl.clientWidth) / fontSize);
          if (offsetIndex) {
            currIndex += offsetIndex;
            currStr = textContent.slice(0, currIndex);
            ryEl.textContent = currStr;
            reactData.visibleLen = currStr.length;
          } else {
            break;
          }
        }
        ryEl.textContent = "";
        ryEl.style.display = "";
        ryEl.style.position = "";
        ryEl.style.top = "";
        ryEl.style.left = "";
      }
    };
    const updateStyle = () => {
      const el = refElem.value;
      const ryEl = realityElem.value;
      const textContent = computeTextContent.value;
      const textLineClamp = computeTextLineClamp.value;
      if (el && ryEl) {
        const cWidth = el.clientWidth;
        ryEl.style.display = "block";
        ryEl.style.position = "absolute";
        ryEl.style.top = "-3000px";
        ryEl.style.left = "-3000px";
        ryEl.textContent = textContent;
        const sWidth = ryEl.offsetWidth;
        const targetWidth = Math.floor(cWidth * textLineClamp);
        if (targetWidth > sWidth) {
          reactData.visibleLen = textContent.length;
        } else {
          calculateFont(targetWidth);
        }
      } else {
        reactData.visibleLen = textContent.length;
      }
    };
    const textEllipsisMethods = {
      dispatchEvent
    };
    const clickEvent = () => {
      emit("click", {});
    };
    const initObserver = () => {
      const { resizeObserver } = reactData;
      const textLineClamp = computeTextLineClamp.value;
      if (!resizeObserver) {
        const el = refElem.value;
        if (el && textLineClamp > 1) {
          if (window.ResizeObserver) {
            const observerObj = new window.ResizeObserver(import_xe_utils93.default.throttle(() => {
              updateStyle();
            }, 300, { leading: true, trailing: true }));
            observerObj.observe(el);
            reactData.resizeObserver = observerObj;
          }
        }
      }
    };
    const textEllipsisPrivateMethods = {};
    Object.assign($xeTextEllipsis, textEllipsisMethods, textEllipsisPrivateMethods);
    const renderContent = () => {
      const { routerLink, href, target, title } = props;
      const visibleContent = computeVisibleContent.value;
      if (routerLink) {
        return h(resolveComponent("router-link"), {
          class: "vxe-text-ellipsis--link",
          title,
          target,
          to: routerLink
        }, {
          default() {
            return renderContent();
          }
        });
      }
      if (href) {
        return h("a", {
          class: "vxe-text-ellipsis--link",
          href,
          target,
          title
        }, visibleContent);
      }
      return h("span", {
        class: "vxe-text-ellipsis--content"
      }, visibleContent);
    };
    const renderVN = () => {
      const { loading: loading2, status, title, underline } = props;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      const textLineClamp = computeTextLineClamp.value;
      if (!permissionInfo.visible) {
        return renderEmptyElement($xeTextEllipsis);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-text-ellipsis", textLineClamp > 1 ? "is--multi" : "is--single", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--underline": underline,
          "is--loading": loading2
        }],
        title,
        onClick: clickEvent
      }, [
        h("span", {
          ref: realityElem,
          class: "vxe-text-ellipsis--reality"
        }),
        renderContent()
      ]);
    };
    watch(() => props.content, () => {
      updateStyle();
    });
    watch(() => props.lineClamp, () => {
      initObserver();
      updateStyle();
    });
    onMounted(() => {
      initObserver();
      updateStyle();
    });
    onBeforeUnmount(() => {
      const { resizeObserver } = reactData;
      const el = refElem.value;
      const ryEl = realityElem.value;
      if (ryEl) {
        ryEl.textContent = "";
      }
      if (resizeObserver) {
        if (el) {
          resizeObserver.unobserve(el);
        }
        resizeObserver.disconnect();
        reactData.resizeObserver = null;
      }
    });
    $xeTextEllipsis.renderVN = renderVN;
    return $xeTextEllipsis;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/text-ellipsis/index.js
var VxeTextEllipsis = Object.assign({}, text_ellipsis_default, {
  install(app) {
    app.component(text_ellipsis_default.name, text_ellipsis_default);
  }
});
dynamicApp.use(VxeTextEllipsis);
VxeUI.component(text_ellipsis_default);
var TextEllipsis = VxeTextEllipsis;
var text_ellipsis_default2 = VxeTextEllipsis;

// node_modules/vxe-pc-ui/es/text/index.js
var VxeText = Object.assign({}, text_default, {
  install(app) {
    app.component(text_default.name, text_default);
  }
});
dynamicApp.use(VxeText);
VxeUI.component(text_default);
var Text = VxeText;
var text_default2 = VxeText;

// node_modules/vxe-pc-ui/es/textarea/src/textarea.js
var import_xe_utils94 = __toESM(require_xe_utils());
var autoTxtElem;
var textarea_default = defineVxeComponent({
  name: "VxeTextarea",
  props: {
    modelValue: [String, Number],
    className: String,
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    readonly: {
      type: Boolean,
      default: null
    },
    editable: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    rows: {
      type: [String, Number],
      default: null
    },
    cols: {
      type: [String, Number],
      default: null
    },
    showWordCount: Boolean,
    countMethod: Function,
    autosize: [Boolean, Object],
    form: String,
    resize: {
      type: String,
      default: () => getConfig().textarea.resize
    },
    size: {
      type: String,
      default: () => getConfig().textarea.size || getConfig().size
    },
    // 已废弃
    maxlength: [String, Number]
  },
  emits: [
    "update:modelValue",
    "input",
    "keydown",
    "keyup",
    "click",
    "change",
    "focus",
    "blur",
    "lazy-change"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils94.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      inputValue: props.modelValue
    });
    const refElem = ref();
    const refTextarea = ref();
    const refMaps = {
      refElem,
      refTextarea
    };
    const $xeTextarea = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let textareaMethods = {};
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeInputReadonly = computed(() => {
      const { editable } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || !editable;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().textarea.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseInput");
    });
    const computeInpMaxLength = computed(() => {
      const { maxLength, maxlength } = props;
      return maxLength || maxlength;
    });
    const computeInputCount = computed(() => {
      return import_xe_utils94.default.getSize(reactData.inputValue);
    });
    const computeIsCountError = computed(() => {
      const inputCount = computeInputCount.value;
      const inpMaxLength = computeInpMaxLength.value;
      return inpMaxLength && inputCount > import_xe_utils94.default.toNumber(inpMaxLength);
    });
    const computeSizeOpts = computed(() => {
      return Object.assign({ minRows: 1, maxRows: 10 }, getConfig().textarea.autosize, props.autosize);
    });
    const updateAutoTxt = () => {
      const { size, autosize } = props;
      const { inputValue } = reactData;
      if (autosize) {
        if (!autoTxtElem) {
          autoTxtElem = document.createElement("div");
        }
        if (!autoTxtElem.parentNode) {
          document.body.appendChild(autoTxtElem);
        }
        const textElem = refTextarea.value;
        if (!textElem) {
          return;
        }
        const textStyle = getComputedStyle(textElem);
        autoTxtElem.className = ["vxe-textarea--autosize", size ? `size--${size}` : ""].join(" ");
        autoTxtElem.style.width = `${textElem.clientWidth}px`;
        autoTxtElem.style.padding = textStyle.padding;
        autoTxtElem.innerText = ("" + (inputValue || "　")).replace(/\n$/, "\n　");
      }
    };
    const handleResize = () => {
      if (props.autosize) {
        nextTick(() => {
          const sizeOpts = computeSizeOpts.value;
          const { minRows, maxRows } = sizeOpts;
          const textElem = refTextarea.value;
          if (!textElem) {
            return;
          }
          const sizeHeight = autoTxtElem.clientHeight;
          const textStyle = getComputedStyle(textElem);
          const lineHeight = import_xe_utils94.default.toNumber(textStyle.lineHeight);
          const paddingTop = import_xe_utils94.default.toNumber(textStyle.paddingTop);
          const paddingBottom = import_xe_utils94.default.toNumber(textStyle.paddingBottom);
          const borderTopWidth = import_xe_utils94.default.toNumber(textStyle.borderTopWidth);
          const borderBottomWidth = import_xe_utils94.default.toNumber(textStyle.borderBottomWidth);
          const intervalHeight = paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
          const rowNum = (sizeHeight - intervalHeight) / lineHeight;
          const textRows = rowNum && /[0-9]/.test("" + rowNum) ? rowNum : Math.floor(rowNum) + 1;
          let vaildRows = textRows;
          if (textRows < minRows) {
            vaildRows = minRows;
          } else if (textRows > maxRows) {
            vaildRows = maxRows;
          }
          textElem.style.height = `${vaildRows * lineHeight + intervalHeight}px`;
        });
      }
    };
    const triggerEvent = (evnt) => {
      const value = reactData.inputValue;
      $xeTextarea.dispatchEvent(evnt.type, { value }, evnt);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      if (import_xe_utils94.default.toValueString(props.modelValue) !== value) {
        textareaMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const inputEvent = (evnt) => {
      const { immediate } = props;
      const textElem = evnt.target;
      const value = textElem.value;
      reactData.inputValue = value;
      if (immediate) {
        handleChange(value, evnt);
      }
      $xeTextarea.dispatchEvent("input", { value }, evnt);
      handleResize();
    };
    const changeEvent = (evnt) => {
      const { immediate } = props;
      if (immediate) {
        triggerEvent(evnt);
      } else {
        handleChange(reactData.inputValue, evnt);
      }
      $xeTextarea.dispatchEvent("lazy-change", { value: reactData.inputValue }, evnt);
    };
    const blurEvent = (evnt) => {
      const { immediate } = props;
      const { inputValue } = reactData;
      if (!immediate) {
        handleChange(inputValue, evnt);
      }
      $xeTextarea.dispatchEvent("blur", { value: inputValue }, evnt);
    };
    textareaMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $textarea: $xeTextarea }, params));
      },
      focus() {
        const textElem = refTextarea.value;
        textElem.focus();
        return nextTick();
      },
      blur() {
        const textElem = refTextarea.value;
        textElem.blur();
        return nextTick();
      }
    };
    Object.assign($xeTextarea, textareaMethods);
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
      updateAutoTxt();
    });
    watch(computeSizeOpts, () => {
      updateAutoTxt();
      handleResize();
    });
    nextTick(() => {
      const { autosize } = props;
      if (autosize) {
        updateAutoTxt();
        handleResize();
      }
    });
    const renderVN = () => {
      const { className, resize, autosize, showWordCount, countMethod, rows, cols } = props;
      const { inputValue } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      const inputReadonly = computeInputReadonly.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const inpMaxLength = computeInpMaxLength.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-textarea--readonly", className]
        }, inputValue);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-textarea", className, {
          [`size--${vSize}`]: vSize,
          "is--autosize": autosize,
          "is--count": showWordCount,
          "is--disabled": isDisabled,
          "is--rows": !import_xe_utils94.default.eqNull(rows),
          "is--cols": !import_xe_utils94.default.eqNull(cols)
        }],
        spellcheck: false
      }, [
        h("textarea", {
          ref: refTextarea,
          class: "vxe-textarea--inner",
          value: inputValue,
          name: props.name,
          placeholder: inpPlaceholder,
          maxlength: inpMaxLength,
          readonly: inputReadonly,
          disabled: isDisabled,
          rows,
          cols,
          style: resize ? {
            resize
          } : null,
          onInput: inputEvent,
          onChange: changeEvent,
          onKeydown: triggerEvent,
          onKeyup: triggerEvent,
          onClick: triggerEvent,
          onFocus: triggerEvent,
          onBlur: blurEvent
        }),
        showWordCount ? h("span", {
          class: ["vxe-textarea--count", {
            "is--error": isCountError
          }]
        }, countMethod ? `${countMethod({ value: inputValue })}` : `${inputCount}${inpMaxLength ? `/${inpMaxLength}` : ""}`) : null
      ]);
    };
    $xeTextarea.renderVN = renderVN;
    return $xeTextarea;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/textarea/index.js
var VxeTextarea = Object.assign(textarea_default, {
  install: function(app) {
    app.component(textarea_default.name, textarea_default);
  }
});
dynamicApp.use(VxeTextarea);
VxeUI.component(textarea_default);
var Textarea = VxeTextarea;
var textarea_default2 = VxeTextarea;

// node_modules/vxe-pc-ui/es/tip/src/tip.js
var import_xe_utils95 = __toESM(require_xe_utils());
var tip_default = defineVxeComponent({
  name: "VxeTip",
  props: {
    title: {
      type: [String, Number],
      default: () => getConfig().tip.title
    },
    content: [String, Number],
    status: String,
    icon: {
      type: String,
      default: () => getConfig().tip.icon
    },
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => getConfig().tip.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils95.default.uniqueId();
    const { computeSize } = useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTip = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tip: $xeTip }, params));
    };
    const tipMethods = {
      dispatchEvent
    };
    const tipPrivateMethods = {};
    Object.assign($xeTip, tipMethods, tipPrivateMethods);
    const renderVN = () => {
      const { status, content, icon, title } = props;
      const defaultSlot = slots.default;
      const titleSlot = slots.title;
      const iconSlot = slots.icon;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      if (!permissionInfo.visible) {
        return renderEmptyElement($xeTip);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-tip", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "has--title": !!(titleSlot || title)
        }]
      }, [
        iconSlot || icon ? h("div", {
          class: "vxe-tip--icon"
        }, iconSlot ? getSlotVNs2(iconSlot({})) : [
          h("i", {
            class: icon
          })
        ]) : renderEmptyElement($xeTip),
        h("div", {
          class: "vxe-tip--body"
        }, [
          titleSlot || title ? h("div", {
            class: "vxe-tip--title"
          }, titleSlot ? getSlotVNs2(titleSlot({})) : import_xe_utils95.default.toValueString(title)) : renderEmptyElement($xeTip),
          h("div", {
            class: "vxe-tip--content"
          }, defaultSlot ? getSlotVNs2(defaultSlot({})) : import_xe_utils95.default.toValueString(content))
        ])
      ]);
    };
    $xeTip.renderVN = renderVN;
    return $xeTip;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/tip/index.js
var VxeTip = Object.assign({}, tip_default, {
  install(app) {
    app.component(tip_default.name, tip_default);
    app.component("VxeTipsComponent", tip_default);
  }
});
dynamicApp.use(VxeTip);
VxeUI.component(tip_default);
var Tips = VxeTip;
var Tip = VxeTip;
var tip_default2 = VxeTip;

// node_modules/vxe-pc-ui/es/tooltip/index.js
var VxeTooltip = Object.assign({}, tooltip_default, {
  install(app) {
    app.component(tooltip_default.name, tooltip_default);
  }
});
dynamicApp.use(VxeTooltip);
VxeUI.component(tooltip_default);
var Tooltip = VxeTooltip;
var tooltip_default2 = VxeTooltip;

// node_modules/vxe-pc-ui/es/tree/src/util.js
var import_xe_utils96 = __toESM(require_xe_utils());
function enNodeValue(nodeid) {
  return import_xe_utils96.default.eqNull(nodeid) ? "" : encodeURIComponent(`${nodeid}`);
}
function deNodeValue(nodeid) {
  return nodeid ? decodeURIComponent(`${nodeid}`) : nodeid;
}
function countTreeExpand($xeTree, prevNode) {
  let count = 1;
  if (!prevNode) {
    return count;
  }
  const props = $xeTree.props;
  const { transform } = props;
  const reactData = $xeTree.reactData;
  const { updateExpandedFlag } = reactData;
  const internalData = $xeTree.internalData;
  const { treeExpandedMaps } = internalData;
  const { computeChildrenField, computeMapChildrenField } = $xeTree.getComputeMaps();
  const childrenField = computeChildrenField.value;
  const mapChildrenField = computeMapChildrenField.value;
  const nodeChildren = prevNode[transform ? mapChildrenField : childrenField];
  if (nodeChildren && updateExpandedFlag && treeExpandedMaps[$xeTree.getNodeId(prevNode)]) {
    for (let index = 0; index < nodeChildren.length; index++) {
      count += countTreeExpand($xeTree, nodeChildren[index]);
    }
  }
  return count;
}
function calcTreeLine($xeTree, node, prevNode) {
  const internalData = $xeTree.internalData;
  const { scrollYStore } = internalData;
  const { rowHeight } = scrollYStore;
  let expandSize = 1;
  if (prevNode) {
    expandSize = countTreeExpand($xeTree, prevNode);
  }
  return (rowHeight || 28) * expandSize - (prevNode ? 1 : 12);
}

// node_modules/vxe-pc-ui/es/tree/src/tree.js
var import_xe_utils97 = __toESM(require_xe_utils());
function getNodeUniqueId() {
  return import_xe_utils97.default.uniqueId("node_");
}
function createInternalData5() {
  return {
    // initialized: false,
    // lastFilterValue: '',
    treeFullData: [],
    afterTreeList: [],
    afterVisibleList: [],
    nodeMaps: {},
    selectCheckboxMaps: {},
    indeterminateRowMaps: {},
    treeExpandedMaps: {},
    treeExpandLazyLoadedMaps: {},
    lastScrollLeft: 0,
    lastScrollTop: 0,
    scrollYStore: {
      startIndex: 0,
      endIndex: 0,
      visibleSize: 0,
      offsetSize: 0,
      rowHeight: 0
    },
    lastScrollTime: 0
    // hpTimeout: undefined
  };
}
var tree_default = defineVxeComponent({
  name: "VxeTree",
  props: {
    data: Array,
    autoResize: {
      type: Boolean,
      default: () => getConfig().tree.autoResize
    },
    height: [String, Number],
    maxHeight: {
      type: [String, Number],
      default: () => getConfig().tree.maxHeight
    },
    minHeight: {
      type: [String, Number],
      default: () => getConfig().tree.minHeight
    },
    loading: Boolean,
    loadingConfig: Object,
    accordion: {
      type: Boolean,
      default: () => getConfig().tree.accordion
    },
    childrenField: {
      type: String,
      default: () => getConfig().tree.childrenField
    },
    valueField: {
      type: String,
      default: () => getConfig().tree.valueField
    },
    keyField: {
      type: String,
      default: () => getConfig().tree.keyField
    },
    parentField: {
      type: String,
      default: () => getConfig().tree.parentField
    },
    titleField: {
      type: String,
      default: () => getConfig().tree.titleField
    },
    hasChildField: {
      type: String,
      default: () => getConfig().tree.hasChildField
    },
    mapChildrenField: {
      type: String,
      default: () => getConfig().tree.mapChildrenField
    },
    transform: Boolean,
    // 已废弃
    isCurrent: Boolean,
    // 已废弃
    isHover: Boolean,
    expandAll: Boolean,
    expandNodeKeys: Array,
    showLine: {
      type: Boolean,
      default: () => getConfig().tree.showLine
    },
    trigger: String,
    indent: {
      type: Number,
      default: () => getConfig().tree.indent
    },
    showRadio: {
      type: Boolean,
      default: () => getConfig().tree.showRadio
    },
    checkNodeKey: {
      type: [String, Number],
      default: () => getConfig().tree.checkNodeKey
    },
    radioConfig: Object,
    showCheckbox: {
      type: Boolean,
      default: () => getConfig().tree.showCheckbox
    },
    checkNodeKeys: {
      type: Array,
      default: () => getConfig().tree.checkNodeKeys
    },
    checkboxConfig: Object,
    nodeConfig: Object,
    lazy: Boolean,
    toggleMethod: Function,
    loadMethod: Function,
    showIcon: {
      type: Boolean,
      default: true
    },
    iconOpen: {
      type: String,
      default: () => getConfig().tree.iconOpen
    },
    iconClose: {
      type: String,
      default: () => getConfig().tree.iconClose
    },
    iconLoaded: {
      type: String,
      default: () => getConfig().tree.iconLoaded
    },
    filterValue: [String, Number],
    filterConfig: Object,
    size: {
      type: String,
      default: () => getConfig().tree.size || getConfig().size
    },
    virtualYConfig: Object
  },
  emits: [
    "update:modelValue",
    "update:checkNodeKey",
    "update:checkNodeKeys",
    "node-click",
    "node-dblclick",
    "current-change",
    "radio-change",
    "checkbox-change",
    "load-success",
    "load-error",
    "scroll"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils97.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refHeaderWrapperElem = ref();
    const refFooterWrapperElem = ref();
    const refVirtualWrapper = ref();
    const refVirtualBody = ref();
    const reactData = reactive({
      parentHeight: 0,
      customHeight: 0,
      customMinHeight: 0,
      customMaxHeight: 0,
      currentNode: null,
      scrollYLoad: false,
      bodyHeight: 0,
      topSpaceHeight: 0,
      selectRadioKey: enNodeValue(props.checkNodeKey),
      treeList: [],
      updateExpandedFlag: 1,
      updateCheckboxFlag: 1
    });
    const internalData = createInternalData5();
    const refMaps = {
      refElem
    };
    const computeTitleField = computed(() => {
      return props.titleField || "title";
    });
    const computeKeyField = computed(() => {
      return props.keyField || "id";
    });
    const computeValueField = computed(() => {
      const keyField = computeKeyField.value;
      return props.valueField || keyField;
    });
    const computeParentField = computed(() => {
      return props.parentField || "parentId";
    });
    const computeChildrenField = computed(() => {
      return props.childrenField || "children";
    });
    const computeMapChildrenField = computed(() => {
      return props.mapChildrenField || "mapChildren";
    });
    const computeHasChildField = computed(() => {
      return props.hasChildField || "hasChild";
    });
    const computeVirtualYOpts = computed(() => {
      return Object.assign({}, getConfig().tree.virtualYConfig, props.virtualYConfig);
    });
    const computeIsRowCurrent = computed(() => {
      const nodeOpts = computeNodeOpts.value;
      const { isCurrent } = nodeOpts;
      if (import_xe_utils97.default.isBoolean(isCurrent)) {
        return isCurrent;
      }
      return props.isCurrent;
    });
    const computeIsRowHover = computed(() => {
      const nodeOpts = computeNodeOpts.value;
      const { isHover } = nodeOpts;
      if (import_xe_utils97.default.isBoolean(isHover)) {
        return isHover;
      }
      return props.isHover;
    });
    const computeRadioOpts = computed(() => {
      return Object.assign({ showIcon: true }, getConfig().tree.radioConfig, props.radioConfig);
    });
    const computeCheckboxOpts = computed(() => {
      return Object.assign({ showIcon: true }, getConfig().tree.checkboxConfig, props.checkboxConfig);
    });
    const computeNodeOpts = computed(() => {
      return Object.assign({}, getConfig().tree.nodeConfig, props.nodeConfig);
    });
    const computeLoadingOpts = computed(() => {
      return Object.assign({}, getConfig().tree.loadingConfig, props.loadingConfig);
    });
    const computeTreeStyle = computed(() => {
      const { customHeight, customMinHeight, customMaxHeight } = reactData;
      const stys = {};
      if (customHeight) {
        stys.height = toCssUnit(customHeight);
      }
      if (customMinHeight) {
        stys.minHeight = toCssUnit(customMinHeight);
      }
      if (customMaxHeight) {
        stys.maxHeight = toCssUnit(customMaxHeight);
      }
      return stys;
    });
    const computeFilterOpts = computed(() => {
      return Object.assign({}, getConfig().tree.filterConfig, props.filterConfig);
    });
    const computeMaps = {
      computeChildrenField,
      computeMapChildrenField,
      computeRadioOpts,
      computeCheckboxOpts,
      computeNodeOpts
    };
    const $xeTree = {
      xID,
      props,
      context,
      internalData,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getNodeId = (node) => {
      const valueField = computeValueField.value;
      const nodeKey = import_xe_utils97.default.get(node, valueField);
      return enNodeValue(nodeKey);
    };
    const isExpandByNode = (node) => {
      const { updateExpandedFlag } = reactData;
      const { treeExpandedMaps } = internalData;
      const nodeid = getNodeId(node);
      return !!(updateExpandedFlag && treeExpandedMaps[nodeid]);
    };
    const isCheckedByRadioNodeId = (nodeid) => {
      const { selectRadioKey } = reactData;
      return selectRadioKey === nodeid;
    };
    const isCheckedByRadioNode = (node) => {
      return isCheckedByRadioNodeId(getNodeId(node));
    };
    const isCheckedByCheckboxNodeId = (nodeid) => {
      const { updateCheckboxFlag } = reactData;
      const { selectCheckboxMaps } = internalData;
      return !!(updateCheckboxFlag && selectCheckboxMaps[nodeid]);
    };
    const isCheckedByCheckboxNode = (node) => {
      return isCheckedByCheckboxNodeId(getNodeId(node));
    };
    const isIndeterminateByCheckboxNodeid = (nodeid) => {
      const { updateCheckboxFlag } = reactData;
      const { indeterminateRowMaps } = internalData;
      return !!(updateCheckboxFlag && indeterminateRowMaps[nodeid]);
    };
    const isIndeterminateByCheckboxNode = (node) => {
      return isIndeterminateByCheckboxNodeid(getNodeId(node));
    };
    const emitCheckboxMode = (value) => {
      emit("update:checkNodeKeys", value);
    };
    const emitRadioMode = (value) => {
      emit("update:checkNodeKey", value);
    };
    const handleSetCheckboxByNodeId = (nodeKeys, checked) => {
      const { nodeMaps } = internalData;
      if (nodeKeys) {
        if (!import_xe_utils97.default.isArray(nodeKeys)) {
          nodeKeys = [nodeKeys];
        }
        const nodeList = [];
        nodeKeys.forEach((nodeKey) => {
          const nodeid = enNodeValue(nodeKey);
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            nodeList.push(nodeItem.item);
          }
        });
        handleCheckedCheckboxNode(nodeList, checked);
      }
      return nextTick();
    };
    const handleCheckedCheckboxNode = (nodeList, checked) => {
      const { transform } = props;
      const { selectCheckboxMaps } = internalData;
      const mapChildrenField = computeMapChildrenField.value;
      const childrenField = computeChildrenField.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const { checkStrictly } = checkboxOpts;
      const handleSelect = (node) => {
        const nodeid = getNodeId(node);
        if (checked) {
          if (!selectCheckboxMaps[nodeid]) {
            selectCheckboxMaps[nodeid] = node;
          }
        } else {
          if (selectCheckboxMaps[nodeid]) {
            delete selectCheckboxMaps[nodeid];
          }
        }
      };
      if (checkStrictly) {
        nodeList.forEach(handleSelect);
      } else {
        import_xe_utils97.default.eachTree(nodeList, handleSelect, { children: transform ? mapChildrenField : childrenField });
      }
      reactData.updateCheckboxFlag++;
      updateCheckboxStatus();
    };
    const updateCheckboxChecked = (nodeKeys) => {
      internalData.selectCheckboxMaps = {};
      handleSetCheckboxByNodeId(nodeKeys, true);
    };
    const handleSetExpand = (nodeid, expanded, expandedMaps) => {
      if (expanded) {
        if (!expandedMaps[nodeid]) {
          expandedMaps[nodeid] = true;
        }
      } else {
        if (expandedMaps[nodeid]) {
          delete expandedMaps[nodeid];
        }
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tree: $xeTree }, params));
    };
    const getParentElem = () => {
      const el = refElem.value;
      return el ? el.parentElement : null;
    };
    const calcTableHeight = (key) => {
      const { parentHeight } = reactData;
      const val = props[key];
      let num = 0;
      if (val) {
        if (val === "100%" || val === "auto") {
          num = parentHeight;
        } else {
          if (isScale(val)) {
            num = Math.floor((import_xe_utils97.default.toInteger(val) || 1) / 100 * parentHeight);
          } else {
            num = import_xe_utils97.default.toNumber(val);
          }
          num = Math.max(40, num);
        }
      }
      return num;
    };
    const updateHeight = () => {
      reactData.customHeight = calcTableHeight("height");
      reactData.customMinHeight = calcTableHeight("minHeight");
      reactData.customMaxHeight = calcTableHeight("maxHeight");
      if (reactData.scrollYLoad && !(reactData.customHeight || reactData.customMinHeight)) {
        reactData.customHeight = 300;
      }
    };
    const createNode = (records) => {
      const valueField = computeValueField.value;
      return Promise.resolve(records.map((obj) => {
        const item = Object.assign({}, obj);
        let nodeid = getNodeId(item);
        if (!nodeid) {
          nodeid = getNodeUniqueId();
          import_xe_utils97.default.set(item, valueField, nodeid);
        }
        return item;
      }));
    };
    const cacheNodeMap = () => {
      const { treeFullData } = internalData;
      const valueField = computeValueField.value;
      const childrenField = computeChildrenField.value;
      const keyMaps = {};
      import_xe_utils97.default.eachTree(treeFullData, (item, index, items, path, parent2, nodes) => {
        let nodeid = getNodeId(item);
        if (!nodeid) {
          nodeid = getNodeUniqueId();
          import_xe_utils97.default.set(item, valueField, nodeid);
        }
        keyMaps[nodeid] = {
          item,
          index,
          items,
          parent: parent2,
          nodes,
          level: nodes.length,
          treeIndex: index,
          lineCount: 0,
          treeLoaded: false
        };
      }, { children: childrenField });
      internalData.nodeMaps = keyMaps;
    };
    const updateAfterDataIndex = () => {
      const { transform } = props;
      const { afterTreeList, nodeMaps } = internalData;
      const childrenField = computeChildrenField.value;
      const mapChildrenField = computeMapChildrenField.value;
      import_xe_utils97.default.eachTree(afterTreeList, (item, index, items) => {
        const nodeid = getNodeId(item);
        const nodeItem = nodeMaps[nodeid];
        if (nodeItem) {
          nodeItem.items = items;
          nodeItem.treeIndex = index;
        } else {
          const rest = {
            item,
            index,
            items,
            parent,
            nodes: [],
            level: 0,
            treeIndex: index,
            lineCount: 0,
            treeLoaded: false
          };
          nodeMaps[nodeid] = rest;
        }
      }, { children: transform ? mapChildrenField : childrenField });
    };
    const updateAfterFullData = () => {
      const { transform, filterValue } = props;
      const { treeFullData, lastFilterValue } = internalData;
      const titleField = computeTitleField.value;
      const childrenField = computeChildrenField.value;
      const mapChildrenField = computeMapChildrenField.value;
      const filterOpts = computeFilterOpts.value;
      const { autoExpandAll, beforeFilterMethod, filterMethod, afterFilterMethod } = filterOpts;
      let fullList = treeFullData;
      let treeList = fullList;
      let filterStr = "";
      if (filterValue || filterValue === 0) {
        filterStr = `${filterValue}`;
        const handleSearch = filterMethod ? (item) => {
          return filterMethod({
            $tree: $xeTree,
            node: item,
            filterValue: filterStr
          });
        } : (item) => {
          return String(item[titleField]).toLowerCase().indexOf(filterStr) > -1;
        };
        const bafParams = { $tree: $xeTree, filterValue: filterStr };
        if (beforeFilterMethod) {
          beforeFilterMethod(bafParams);
        }
        if (transform) {
          treeList = import_xe_utils97.default.searchTree(treeFullData, handleSearch, {
            original: true,
            isEvery: true,
            children: childrenField,
            mapChildren: mapChildrenField
          });
          fullList = treeList;
        } else {
          fullList = treeFullData.filter(handleSearch);
        }
        internalData.lastFilterValue = filterStr;
        nextTick(() => {
          if (autoExpandAll) {
            $xeTree.setAllExpandNode(true).then(() => {
              if (afterFilterMethod) {
                afterFilterMethod(bafParams);
              }
            });
          } else {
            if (afterFilterMethod) {
              afterFilterMethod(bafParams);
            }
          }
        });
      } else {
        if (transform) {
          treeList = import_xe_utils97.default.searchTree(treeFullData, () => true, {
            original: true,
            isEvery: true,
            children: childrenField,
            mapChildren: mapChildrenField
          });
          fullList = treeList;
          if (lastFilterValue) {
            const bafParams = { $tree: $xeTree, filterValue: filterStr };
            if (beforeFilterMethod) {
              beforeFilterMethod(bafParams);
            }
            nextTick(() => {
              if (autoExpandAll) {
                $xeTree.clearAllExpandNode().then(() => {
                  if (afterFilterMethod) {
                    afterFilterMethod(bafParams);
                  }
                });
              } else {
                if (afterFilterMethod) {
                  afterFilterMethod(bafParams);
                }
              }
            });
          }
        }
        internalData.lastFilterValue = "";
      }
      internalData.afterVisibleList = fullList;
      internalData.afterTreeList = treeList;
      updateAfterDataIndex();
    };
    const handleTreeToList = () => {
      const { transform } = props;
      const { afterTreeList, treeExpandedMaps } = internalData;
      const mapChildrenField = computeMapChildrenField.value;
      const expandMaps = {};
      if (transform) {
        const fullData = [];
        import_xe_utils97.default.eachTree(afterTreeList, (item, index, items, path, parentRow) => {
          const nodeid = getNodeId(item);
          const parentNodeid = getNodeId(parentRow);
          if (!parentRow || expandMaps[parentNodeid] && treeExpandedMaps[parentNodeid]) {
            expandMaps[nodeid] = 1;
            fullData.push(item);
          }
        }, { children: mapChildrenField });
        updateScrollYStatus(fullData);
        internalData.afterVisibleList = fullData;
        return fullData;
      }
      return internalData.afterVisibleList;
    };
    const handleData = (force) => {
      const { scrollYLoad } = reactData;
      const { scrollYStore } = internalData;
      let fullList = internalData.afterVisibleList;
      if (force) {
        updateAfterFullData();
        fullList = handleTreeToList();
      }
      const treeList = scrollYLoad ? fullList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullList.slice(0);
      reactData.treeList = treeList;
    };
    const triggerSearchEvent = import_xe_utils97.default.debounce(() => handleData(true), 350, { trailing: true });
    const loadData = (list) => {
      const { expandAll, expandNodeKeys, transform } = props;
      const { initialized, scrollYStore } = internalData;
      const keyField = computeKeyField.value;
      const parentField = computeParentField.value;
      const childrenField = computeChildrenField.value;
      const fullData = transform ? import_xe_utils97.default.toArrayTree(list, { key: keyField, parentKey: parentField, mapChildren: childrenField }) : list ? list.slice(0) : [];
      internalData.treeFullData = fullData;
      Object.assign(scrollYStore, {
        startIndex: 0,
        endIndex: 1,
        visibleSize: 0
      });
      const sYLoad = updateScrollYStatus(fullData);
      cacheNodeMap();
      handleData(true);
      if (sYLoad) {
        if (!(props.height || props.maxHeight)) {
          errLog("vxe.error.reqProp", ["[tree] height | max-height | virtual-y-config.enabled=false"]);
        }
      }
      return computeScrollLoad().then(() => {
        if (!initialized) {
          if (list && list.length) {
            internalData.initialized = true;
            if (expandAll) {
              $xeTree.setAllExpandNode(true);
            } else if (expandNodeKeys && expandNodeKeys.length) {
              $xeTree.setExpandByNodeId(expandNodeKeys, true);
            }
            handleSetCheckboxByNodeId(props.checkNodeKeys || [], true);
          }
        }
        updateHeight();
        refreshScroll();
      });
    };
    const updateScrollYStatus = (fullData) => {
      const { transform } = props;
      const virtualYOpts = computeVirtualYOpts.value;
      const allList = fullData || internalData.treeFullData;
      const scrollYLoad = !!transform && !!virtualYOpts.enabled && virtualYOpts.gt > -1 && (virtualYOpts.gt === 0 || virtualYOpts.gt < allList.length);
      reactData.scrollYLoad = scrollYLoad;
      return scrollYLoad;
    };
    const updateYSpace = () => {
      const { scrollYLoad } = reactData;
      const { scrollYStore, afterVisibleList } = internalData;
      reactData.bodyHeight = scrollYLoad ? afterVisibleList.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return nextTick().then(() => {
        const { scrollYLoad } = reactData;
        const { scrollYStore } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const virtualYOpts = computeVirtualYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(20, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, scrollBodyElem ? Math.ceil(scrollBodyElem.clientHeight / rowHeight) : 0);
          const offsetYSize = Math.max(0, Math.min(2, import_xe_utils97.default.toNumber(virtualYOpts.oSize)));
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex, visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
      });
    };
    const handleScrollTo = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollLeft) {
        if (!import_xe_utils97.default.isNumber(scrollLeft)) {
          scrollTop = scrollLeft.top;
          scrollLeft = scrollLeft.left;
        }
      }
      if (scrollBodyElem) {
        if (import_xe_utils97.default.isNumber(scrollLeft)) {
          scrollBodyElem.scrollLeft = scrollLeft;
        }
        if (import_xe_utils97.default.isNumber(scrollTop)) {
          scrollBodyElem.scrollTop = scrollTop;
        }
      }
      if (reactData.scrollYLoad) {
        return new Promise((resolve) => {
          setTimeout(() => {
            nextTick(() => {
              resolve();
            });
          }, 50);
        });
      }
      return nextTick();
    };
    const refreshScroll = () => {
      const { lastScrollLeft, lastScrollTop } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    };
    const recalculate = () => {
      const { scrollYStore } = internalData;
      const { rowHeight } = scrollYStore;
      const el = refElem.value;
      if (el && el.clientWidth && el.clientHeight) {
        const parentEl = getParentElem();
        const headerWrapperEl = refHeaderWrapperElem.value;
        const footerWrapperEl = refFooterWrapperElem.value;
        const headHeight = headerWrapperEl ? headerWrapperEl.clientHeight : 0;
        const footHeight = footerWrapperEl ? footerWrapperEl.clientHeight : 0;
        if (parentEl) {
          const parentPaddingSize = getPaddingTopBottomSize(parentEl);
          reactData.parentHeight = Math.max(headHeight + footHeight + rowHeight, parentEl.clientHeight - parentPaddingSize - headHeight - footHeight);
        }
        updateHeight();
        return computeScrollLoad().then(() => {
          updateHeight();
          updateYSpace();
        });
      }
      return nextTick();
    };
    const loadYData = () => {
      const { scrollYStore } = internalData;
      const { startIndex, endIndex, visibleSize, offsetSize, rowHeight } = scrollYStore;
      const scrollBodyElem = refVirtualWrapper.value;
      if (!scrollBodyElem) {
        return;
      }
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    const scrollEvent = (evnt) => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData();
      }
      internalData.lastScrollTime = Date.now();
      dispatchEvent("scroll", { scrollLeft, scrollTop, isX, isY }, evnt);
    };
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
        scrollBodyElem.scrollLeft = 0;
      }
      internalData.lastScrollTop = 0;
      internalData.lastScrollLeft = 0;
      return nextTick();
    };
    const handleNodeClickEvent = (evnt, node) => {
      const { showRadio, showCheckbox, trigger } = props;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const isRowCurrent = computeIsRowCurrent.value;
      let triggerCurrent = false;
      let triggerRadio = false;
      let triggerCheckbox = false;
      let triggerExpand = false;
      if (isRowCurrent) {
        triggerCurrent = true;
        changeCurrentEvent(evnt, node);
      } else if (reactData.currentNode) {
        reactData.currentNode = null;
      }
      if (trigger === "node") {
        triggerExpand = true;
        toggleExpandEvent(evnt, node);
      }
      if (showRadio && radioOpts.trigger === "node") {
        triggerRadio = true;
        changeRadioEvent(evnt, node);
      }
      if (showCheckbox && checkboxOpts.trigger === "node") {
        triggerCheckbox = true;
        changeCheckboxEvent(evnt, node);
      }
      dispatchEvent("node-click", { node, triggerCurrent, triggerRadio, triggerCheckbox, triggerExpand }, evnt);
    };
    const handleNodeDblclickEvent = (evnt, node) => {
      dispatchEvent("node-dblclick", { node }, evnt);
    };
    const handleAsyncTreeExpandChilds = (node) => {
      const checkboxOpts = computeCheckboxOpts.value;
      const { loadMethod } = props;
      const { checkStrictly } = checkboxOpts;
      return new Promise((resolve) => {
        if (loadMethod) {
          const { nodeMaps } = internalData;
          const nodeid = getNodeId(node);
          const nodeItem = nodeMaps[nodeid];
          internalData.treeExpandLazyLoadedMaps[nodeid] = true;
          Promise.resolve(loadMethod({ $tree: $xeTree, node })).then((childRecords) => {
            const { treeExpandLazyLoadedMaps } = internalData;
            nodeItem.treeLoaded = true;
            if (treeExpandLazyLoadedMaps[nodeid]) {
              treeExpandLazyLoadedMaps[nodeid] = false;
            }
            if (!import_xe_utils97.default.isArray(childRecords)) {
              childRecords = [];
            }
            if (childRecords) {
              return $xeTree.loadChildrenNode(node, childRecords).then((childRows) => {
                const { treeExpandedMaps } = internalData;
                if (childRows.length && !treeExpandedMaps[nodeid]) {
                  treeExpandedMaps[nodeid] = true;
                }
                reactData.updateExpandedFlag++;
                if (!checkStrictly && $xeTree.isCheckedByCheckboxNodeId(nodeid)) {
                  handleCheckedCheckboxNode(childRows, true);
                }
                dispatchEvent("load-success", { node, data: childRecords }, new Event("load-success"));
                return nextTick();
              });
            } else {
              dispatchEvent("load-success", { node, data: childRecords }, new Event("load-success"));
            }
          }).catch((e) => {
            const { treeExpandLazyLoadedMaps } = internalData;
            nodeItem.treeLoaded = false;
            if (treeExpandLazyLoadedMaps[nodeid]) {
              treeExpandLazyLoadedMaps[nodeid] = false;
            }
            dispatchEvent("load-error", { node, data: e }, new Event("load-error"));
          }).finally(() => {
            handleTreeToList();
            handleData();
            return recalculate();
          });
        } else {
          resolve();
        }
      });
    };
    const handleBaseTreeExpand = (nodeList, expanded) => {
      const { lazy, accordion, toggleMethod } = props;
      const { treeExpandLazyLoadedMaps, treeExpandedMaps } = internalData;
      const { nodeMaps } = internalData;
      const childrenField = computeChildrenField.value;
      const hasChildField = computeHasChildField.value;
      const result = [];
      let validNodes = toggleMethod ? nodeList.filter((node) => toggleMethod({ $tree: $xeTree, expanded, node })) : nodeList;
      if (accordion) {
        validNodes = validNodes.length ? [validNodes[validNodes.length - 1]] : [];
        const nodeid = getNodeId(validNodes[0]);
        const nodeItem = nodeMaps[nodeid];
        if (nodeItem) {
          nodeItem.items.forEach((item) => {
            const itemNodeId = getNodeId(item);
            if (treeExpandedMaps[itemNodeId]) {
              delete treeExpandedMaps[itemNodeId];
            }
          });
        }
      }
      const expandNodes = [];
      if (expanded) {
        validNodes.forEach((item) => {
          const itemNodeId = getNodeId(item);
          if (!treeExpandedMaps[itemNodeId]) {
            const nodeItem = nodeMaps[itemNodeId];
            const isLoad = lazy && item[hasChildField] && !nodeItem.treeLoaded && !treeExpandLazyLoadedMaps[itemNodeId];
            if (isLoad) {
              result.push(handleAsyncTreeExpandChilds(item));
            } else {
              if (item[childrenField] && item[childrenField].length) {
                treeExpandedMaps[itemNodeId] = true;
                expandNodes.push(item);
              }
            }
          }
        });
      } else {
        validNodes.forEach((item) => {
          const itemNodeId = getNodeId(item);
          if (treeExpandedMaps[itemNodeId]) {
            delete treeExpandedMaps[itemNodeId];
            expandNodes.push(item);
          }
        });
      }
      reactData.updateExpandedFlag++;
      handleTreeToList();
      handleData();
      return Promise.all(result).then(() => recalculate());
    };
    const toggleExpandEvent = (evnt, node) => {
      const { lazy } = props;
      const { treeExpandedMaps, treeExpandLazyLoadedMaps } = internalData;
      const nodeid = getNodeId(node);
      const expanded = !treeExpandedMaps[nodeid];
      evnt.stopPropagation();
      if (!lazy || !treeExpandLazyLoadedMaps[nodeid]) {
        handleBaseTreeExpand([node], expanded);
      }
    };
    const updateCheckboxStatus = () => {
      const { transform } = props;
      const { selectCheckboxMaps, indeterminateRowMaps, afterTreeList } = internalData;
      const childrenField = computeChildrenField.value;
      const mapChildrenField = computeMapChildrenField.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const { checkStrictly, checkMethod } = checkboxOpts;
      if (!checkStrictly) {
        const childRowMaps = {};
        const childRowList = [];
        import_xe_utils97.default.eachTree(afterTreeList, (node) => {
          const nodeid = getNodeId(node);
          const childList = node[childrenField];
          if (childList && childList.length && !childRowMaps[nodeid]) {
            childRowMaps[nodeid] = 1;
            childRowList.unshift([node, nodeid, childList]);
          }
        }, { children: transform ? mapChildrenField : childrenField });
        childRowList.forEach((vals) => {
          const node = vals[0];
          const nodeid = vals[1];
          const childList = vals[2];
          let sLen = 0;
          let hLen = 0;
          let vLen = 0;
          const cLen = childList.length;
          childList.forEach(checkMethod ? (item) => {
            const childNodeid = getNodeId(item);
            const isSelect = selectCheckboxMaps[childNodeid];
            if (checkMethod({ $tree: $xeTree, node: item })) {
              if (isSelect) {
                sLen++;
              } else if (indeterminateRowMaps[childNodeid]) {
                hLen++;
              }
              vLen++;
            } else {
              if (isSelect) {
                sLen++;
              } else if (indeterminateRowMaps[childNodeid]) {
                hLen++;
              }
            }
          } : (item) => {
            const childNodeid = getNodeId(item);
            const isSelect = selectCheckboxMaps[childNodeid];
            if (isSelect) {
              sLen++;
            } else if (indeterminateRowMaps[childNodeid]) {
              hLen++;
            }
            vLen++;
          });
          let isSelected = false;
          if (cLen > 0) {
            if (vLen > 0) {
              isSelected = (sLen > 0 || hLen > 0) && sLen >= vLen;
            } else {
              if (sLen > 0 && sLen >= vLen) {
                isSelected = true;
              } else if (selectCheckboxMaps[nodeid]) {
                isSelected = true;
              } else {
                isSelected = false;
              }
            }
          } else {
            isSelected = selectCheckboxMaps[nodeid];
          }
          const halfSelect = !isSelected && (sLen > 0 || hLen > 0);
          if (isSelected) {
            selectCheckboxMaps[nodeid] = node;
            if (indeterminateRowMaps[nodeid]) {
              delete indeterminateRowMaps[nodeid];
            }
          } else {
            if (selectCheckboxMaps[nodeid]) {
              delete selectCheckboxMaps[nodeid];
            }
            if (halfSelect) {
              indeterminateRowMaps[nodeid] = node;
            } else {
              if (indeterminateRowMaps[nodeid]) {
                delete indeterminateRowMaps[nodeid];
              }
            }
          }
        });
        reactData.updateCheckboxFlag++;
      }
    };
    const changeCheckboxEvent = (evnt, node) => {
      evnt.preventDefault();
      evnt.stopPropagation();
      const { transform } = props;
      const { selectCheckboxMaps } = internalData;
      const childrenField = computeChildrenField.value;
      const mapChildrenField = computeMapChildrenField.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const { checkStrictly, checkMethod } = checkboxOpts;
      let isDisabled = !!checkMethod;
      if (checkMethod) {
        isDisabled = !checkMethod({ $tree: $xeTree, node });
      }
      if (isDisabled) {
        return;
      }
      const nodeid = getNodeId(node);
      let isChecked = false;
      if (selectCheckboxMaps[nodeid]) {
        delete selectCheckboxMaps[nodeid];
      } else {
        isChecked = true;
        selectCheckboxMaps[nodeid] = node;
      }
      if (!checkStrictly) {
        import_xe_utils97.default.eachTree(import_xe_utils97.default.get(node, transform ? mapChildrenField : childrenField), (childNode) => {
          const childNodeid = getNodeId(childNode);
          if (isChecked) {
            if (!selectCheckboxMaps[childNodeid]) {
              selectCheckboxMaps[childNodeid] = true;
            }
          } else {
            if (selectCheckboxMaps[childNodeid]) {
              delete selectCheckboxMaps[childNodeid];
            }
          }
        }, { children: transform ? mapChildrenField : childrenField });
      }
      reactData.updateCheckboxFlag++;
      updateCheckboxStatus();
      const nodeids = import_xe_utils97.default.keys(selectCheckboxMaps);
      const value = nodeids.map(deNodeValue);
      emitCheckboxMode(value);
      dispatchEvent("checkbox-change", { node, value, checked: isChecked }, evnt);
    };
    const changeCurrentEvent = (evnt, node) => {
      evnt.preventDefault();
      const nodeOpts = computeNodeOpts.value;
      const { currentMethod, trigger } = nodeOpts;
      const childrenField = computeChildrenField.value;
      const childList = import_xe_utils97.default.get(node, childrenField);
      const hasChild = childList && childList.length;
      let isDisabled = !!currentMethod;
      if (trigger === "child") {
        if (hasChild) {
          return;
        }
      } else if (trigger === "parent") {
        if (!hasChild) {
          return;
        }
      }
      if (currentMethod) {
        isDisabled = !currentMethod({ node });
      }
      if (isDisabled) {
        return;
      }
      const isChecked = true;
      reactData.currentNode = node;
      dispatchEvent("current-change", { node, checked: isChecked }, evnt);
    };
    const changeRadioEvent = (evnt, node) => {
      evnt.preventDefault();
      evnt.stopPropagation();
      const radioOpts = computeRadioOpts.value;
      const { checkMethod } = radioOpts;
      let isDisabled = !!checkMethod;
      if (checkMethod) {
        isDisabled = !checkMethod({ $tree: $xeTree, node });
      }
      if (isDisabled) {
        return;
      }
      const isChecked = true;
      const nodeid = getNodeId(node);
      const value = deNodeValue(nodeid);
      reactData.selectRadioKey = nodeid;
      emitRadioMode(value);
      dispatchEvent("radio-change", { node, value, checked: isChecked }, evnt);
    };
    const handleGlobalResizeEvent = () => {
      const el = refElem.value;
      if (!el || !el.clientWidth) {
        return;
      }
      recalculate();
    };
    const treeMethods = {
      dispatchEvent,
      getNodeId,
      getNodeById(nodeid) {
        const { nodeMaps } = internalData;
        if (nodeid) {
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            return nodeItem.item;
          }
        }
        return null;
      },
      loadData(data) {
        return loadData(data || []);
      },
      reloadData(data) {
        return loadData(data || []);
      },
      clearCurrentNode() {
        reactData.currentNode = null;
        return nextTick();
      },
      getCurrentNodeId() {
        const { currentNode } = reactData;
        if (currentNode) {
          return deNodeValue(getNodeId(currentNode));
        }
        return null;
      },
      getCurrentNode() {
        const { currentNode } = reactData;
        const { nodeMaps } = internalData;
        if (currentNode) {
          const nodeItem = nodeMaps[getNodeId(currentNode)];
          if (nodeItem) {
            return nodeItem.item;
          }
        }
        return null;
      },
      setCurrentNodeId(nodeKey) {
        const { nodeMaps } = internalData;
        const nodeItem = nodeMaps[enNodeValue(nodeKey)];
        reactData.currentNode = nodeItem ? nodeItem.item : null;
        return nextTick();
      },
      setCurrentNode(node) {
        reactData.currentNode = node;
        return nextTick();
      },
      clearRadioNode() {
        reactData.selectRadioKey = null;
        emitRadioMode(null);
        return nextTick();
      },
      getRadioNodeId() {
        return reactData.selectRadioKey || null;
      },
      getRadioNode() {
        const { selectRadioKey } = reactData;
        const { nodeMaps } = internalData;
        if (selectRadioKey) {
          const nodeItem = nodeMaps[selectRadioKey];
          if (nodeItem) {
            return nodeItem.item;
          }
        }
        return null;
      },
      setRadioNodeId(nodeKey) {
        reactData.selectRadioKey = enNodeValue(nodeKey);
        emitRadioMode(nodeKey);
        return nextTick();
      },
      setRadioNode(node) {
        if (node) {
          const nodeid = getNodeId(node);
          reactData.selectRadioKey = nodeid;
          emitRadioMode(deNodeValue(nodeid));
        } else {
          emitRadioMode(null);
        }
        return nextTick();
      },
      setCheckboxNode(nodeList, checked) {
        if (nodeList) {
          if (!import_xe_utils97.default.isArray(nodeList)) {
            nodeList = [nodeList];
          }
          handleCheckedCheckboxNode(nodeList, checked);
        }
        emitCheckboxMode($xeTree.getCheckboxNodeIds());
        return nextTick();
      },
      setCheckboxByNodeId(nodeKeys, selected) {
        handleSetCheckboxByNodeId(nodeKeys, selected);
        emitCheckboxMode($xeTree.getCheckboxNodeIds());
        return nextTick();
      },
      getCheckboxNodeIds() {
        const { selectCheckboxMaps } = internalData;
        const nodeKeys = [];
        import_xe_utils97.default.each(selectCheckboxMaps, (item, nodeId) => {
          nodeKeys.push(deNodeValue(nodeId));
        });
        return nodeKeys;
      },
      getCheckboxNodes() {
        const { nodeMaps, selectCheckboxMaps } = internalData;
        const list = [];
        import_xe_utils97.default.each(selectCheckboxMaps, (item, nodeid) => {
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            list.push(nodeItem.item);
          }
        });
        return list;
      },
      clearCheckboxNode() {
        internalData.indeterminateRowMaps = {};
        internalData.selectCheckboxMaps = {};
        reactData.updateCheckboxFlag++;
        emitCheckboxMode([]);
        updateCheckboxStatus();
        return nextTick().then(() => {
          return { checkNodeKeys: [], checkNodes: [] };
        });
      },
      setAllCheckboxNode(checked) {
        const { transform } = props;
        const selectMaps = {};
        const childrenField = computeChildrenField.value;
        const mapChildrenField = computeMapChildrenField.value;
        const checkKeys = [];
        const checkNodes = [];
        if (checked) {
          import_xe_utils97.default.eachTree(internalData.afterTreeList, (node) => {
            const nodeid = getNodeId(node);
            checkKeys.push(nodeid);
            checkNodes.push(node);
            selectMaps[nodeid] = true;
          }, { children: transform ? mapChildrenField : childrenField });
        }
        internalData.indeterminateRowMaps = {};
        internalData.selectCheckboxMaps = selectMaps;
        reactData.updateCheckboxFlag++;
        updateCheckboxStatus();
        return nextTick().then(() => {
          return { checkNodeKeys: checkKeys, checkNodes };
        });
      },
      clearExpandNode() {
        return treeMethods.clearAllExpandNode();
      },
      clearAllExpandNode() {
        const { nodeMaps, scrollYStore } = internalData;
        import_xe_utils97.default.each(nodeMaps, (nodeItem) => {
          nodeItem.treeLoaded = false;
        });
        internalData.treeExpandedMaps = {};
        reactData.updateExpandedFlag++;
        reactData.topSpaceHeight = 0;
        scrollYStore.startIndex = 0;
        scrollYStore.endIndex = 1;
        handleTreeToList();
        handleData();
        return recalculate();
      },
      setExpandByNodeId(nodeKeys, expanded) {
        const { treeExpandedMaps } = internalData;
        if (nodeKeys) {
          if (!import_xe_utils97.default.isArray(nodeKeys)) {
            nodeKeys = [nodeKeys];
          }
          nodeKeys.forEach((nodeKey) => {
            const nodeid = enNodeValue(nodeKey);
            handleSetExpand(nodeid, expanded, treeExpandedMaps);
          });
          reactData.updateExpandedFlag++;
        }
        handleTreeToList();
        handleData();
        return recalculate();
      },
      getExpandNodeIds() {
        const { treeExpandedMaps } = internalData;
        const nodeKeys = [];
        import_xe_utils97.default.each(treeExpandedMaps, (item, nodeId) => {
          nodeKeys.push(deNodeValue(nodeId));
        });
        return nodeKeys;
      },
      getExpandNodes() {
        const { nodeMaps, treeExpandedMaps } = internalData;
        const list = [];
        import_xe_utils97.default.each(treeExpandedMaps, (item, nodeid) => {
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            list.push(nodeItem.item);
          }
        });
        return list;
      },
      setExpandNode(nodes, expanded) {
        const { treeExpandedMaps } = internalData;
        if (nodes) {
          if (!import_xe_utils97.default.isArray(nodes)) {
            nodes = [nodes];
          }
          nodes.forEach((node) => {
            const nodeid = getNodeId(node);
            handleSetExpand(nodeid, expanded, treeExpandedMaps);
          });
          reactData.updateExpandedFlag++;
        }
        handleTreeToList();
        handleData();
        return recalculate();
      },
      toggleExpandByNodeId(nodeKeys) {
        const { treeExpandedMaps } = internalData;
        if (nodeKeys) {
          if (!import_xe_utils97.default.isArray(nodeKeys)) {
            nodeKeys = [nodeKeys];
          }
          nodeKeys.forEach((nodeKey) => {
            const nodeid = enNodeValue(nodeKey);
            handleSetExpand(nodeid, !treeExpandedMaps[`${nodeid}`], treeExpandedMaps);
          });
          reactData.updateExpandedFlag++;
        }
        handleTreeToList();
        handleData();
        return recalculate();
      },
      toggleExpandNode(nodes) {
        const { treeExpandedMaps } = internalData;
        if (nodes) {
          if (!import_xe_utils97.default.isArray(nodes)) {
            nodes = [nodes];
          }
          nodes.forEach((node) => {
            const nodeid = getNodeId(node);
            handleSetExpand(nodeid, !treeExpandedMaps[nodeid], treeExpandedMaps);
          });
          reactData.updateExpandedFlag++;
        }
        handleTreeToList();
        handleData();
        return recalculate();
      },
      setAllExpandNode(expanded) {
        const { transform } = props;
        const { scrollYLoad } = reactData;
        const { scrollYStore, treeExpandedMaps } = internalData;
        const childrenField = computeChildrenField.value;
        const mapChildrenField = computeMapChildrenField.value;
        if (expanded) {
          import_xe_utils97.default.eachTree(internalData.afterTreeList, (node) => {
            const childList = import_xe_utils97.default.get(node, childrenField);
            const hasChild = childList && childList.length;
            if (hasChild) {
              const nodeid = getNodeId(node);
              treeExpandedMaps[nodeid] = true;
            }
          }, { children: transform ? mapChildrenField : childrenField });
        } else {
          internalData.treeExpandedMaps = {};
        }
        reactData.updateExpandedFlag++;
        reactData.topSpaceHeight = 0;
        scrollYStore.startIndex = 0;
        scrollYStore.endIndex = 1;
        handleTreeToList();
        handleData();
        return recalculate().then(() => {
          if (scrollYLoad) {
            loadYData();
          }
          return recalculate();
        });
      },
      reloadExpandNode(node) {
        const { lazy } = props;
        if (lazy) {
          treeMethods.clearExpandLoaded(node);
          return handleAsyncTreeExpandChilds(node);
        }
        return recalculate();
      },
      clearExpandLoaded(node) {
        const { lazy } = props;
        const { nodeMaps } = internalData;
        if (lazy) {
          const nodeItem = nodeMaps[getNodeId(node)];
          if (nodeItem) {
            nodeItem.treeLoaded = false;
          }
        }
        return recalculate();
      },
      /**
       * 用于树结构，给行数据加载子节点
       */
      loadChildrenNode(node, childRecords) {
        const { lazy, transform } = props;
        const { nodeMaps } = internalData;
        if (!lazy) {
          return Promise.resolve([]);
        }
        const childrenField = computeChildrenField.value;
        const mapChildrenField = computeMapChildrenField.value;
        const parentNodeItem = nodeMaps[getNodeId(node)];
        const parentLevel = parentNodeItem ? parentNodeItem.level : 0;
        const parentNodes = parentNodeItem ? parentNodeItem.nodes : [];
        return createNode(childRecords).then((nodeList) => {
          import_xe_utils97.default.eachTree(nodeList, (childRow, index, items, path, parent2, nodes) => {
            const itemNodeId = getNodeId(childRow);
            nodeMaps[itemNodeId] = {
              item: childRow,
              index: -1,
              items,
              parent: parent2 || parentNodeItem.item,
              nodes: parentNodes.concat(nodes),
              level: parentLevel + nodes.length,
              treeIndex: -1,
              lineCount: 0,
              treeLoaded: false
            };
          }, { children: childrenField });
          node[childrenField] = nodeList;
          if (transform) {
            node[mapChildrenField] = nodeList;
          }
          updateAfterDataIndex();
          return nodeList;
        });
      },
      isExpandByNode,
      isCheckedByRadioNodeId,
      isCheckedByRadioNode,
      isCheckedByCheckboxNodeId,
      isIndeterminateByCheckboxNode,
      isCheckedByCheckboxNode,
      getCheckboxIndeterminateNodes() {
        const { nodeMaps, indeterminateRowMaps } = internalData;
        const list = [];
        import_xe_utils97.default.each(indeterminateRowMaps, (item, nodeid) => {
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            list.push(nodeItem.item);
          }
        });
        return list;
      },
      recalculate,
      scrollTo: handleScrollTo,
      scrollToNode(node) {
        return $xeTree.scrollToNodeId(getNodeId(node));
      },
      scrollToNodeId(nodeid) {
        const { transform } = props;
        const { scrollYStore, afterTreeList } = internalData;
        const childrenField = computeChildrenField.value;
        const mapChildrenField = computeMapChildrenField.value;
        const scrollBodyElem = refVirtualWrapper.value;
        if (nodeid && scrollBodyElem) {
          if (transform) {
            const matchObj = import_xe_utils97.default.findTree(afterTreeList, (item) => getNodeId(item) === nodeid, { children: transform ? mapChildrenField : childrenField });
            if (matchObj) {
              return $xeTree.setExpandNode(matchObj.nodes, true).then(() => {
                const itemIndex = import_xe_utils97.default.findIndexOf(internalData.afterVisibleList, (item) => getNodeId(item) === nodeid);
                if (itemIndex > -1) {
                  const targetTop = Math.max(0, (itemIndex - 1) * scrollYStore.rowHeight);
                  return handleScrollTo(scrollBodyElem.scrollLeft, targetTop);
                }
              });
            }
          } else {
            const itemEl = scrollBodyElem.querySelector(`.vxe-tree--node-wrapper[nodeid="${nodeid}"]`);
            if (itemEl) {
              return handleScrollTo(scrollBodyElem.scrollLeft, itemEl.offsetTop);
            }
          }
        }
        return recalculate();
      },
      clearScroll
    };
    const treePrivateMethods = {};
    Object.assign($xeTree, treeMethods, treePrivateMethods);
    const renderRadio = (node, nodeid, isChecked) => {
      const { showRadio } = props;
      const radioOpts = computeRadioOpts.value;
      const { showIcon, checkMethod, visibleMethod } = radioOpts;
      const isVisible = !visibleMethod || visibleMethod({ $tree: $xeTree, node });
      let isDisabled = !!checkMethod;
      if (showRadio && showIcon && isVisible) {
        if (checkMethod) {
          isDisabled = !checkMethod({ $tree: $xeTree, node });
        }
        return h("div", {
          class: ["vxe-tree--radio-option", {
            "is--checked": isChecked,
            "is--disabled": isDisabled
          }],
          onClick: (evnt) => {
            if (!isDisabled) {
              changeRadioEvent(evnt, node);
            }
          }
        }, [
          h("span", {
            class: ["vxe-radio--icon", isChecked ? getIcon().RADIO_CHECKED : getIcon().RADIO_UNCHECKED]
          })
        ]);
      }
      return renderEmptyElement($xeTree);
    };
    const renderCheckbox = (node, nodeid, isChecked) => {
      const { showCheckbox } = props;
      const checkboxOpts = computeCheckboxOpts.value;
      const { showIcon, checkMethod, visibleMethod } = checkboxOpts;
      const isIndeterminate = isIndeterminateByCheckboxNodeid(nodeid);
      const isVisible = !visibleMethod || visibleMethod({ $tree: $xeTree, node });
      let isDisabled = !!checkMethod;
      if (showCheckbox && showIcon && isVisible) {
        if (checkMethod) {
          isDisabled = !checkMethod({ $tree: $xeTree, node });
        }
        return h("div", {
          class: ["vxe-tree--checkbox-option", {
            "is--checked": isChecked,
            "is--indeterminate": isIndeterminate,
            "is--disabled": isDisabled
          }],
          onClick: (evnt) => {
            if (!isDisabled) {
              changeCheckboxEvent(evnt, node);
            }
          }
        }, [
          h("span", {
            class: ["vxe-checkbox--icon", isIndeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
          })
        ]);
      }
      return renderEmptyElement($xeTree);
    };
    const renderNode = (node, nodeid) => {
      const { lazy, showRadio, showCheckbox, showLine, indent, iconOpen, iconClose, iconLoaded, showIcon } = props;
      const { currentNode, selectRadioKey, updateExpandedFlag } = reactData;
      const { afterTreeList, nodeMaps, treeExpandedMaps, treeExpandLazyLoadedMaps } = internalData;
      const childrenField = computeChildrenField.value;
      const titleField = computeTitleField.value;
      const hasChildField = computeHasChildField.value;
      const childList = import_xe_utils97.default.get(node, childrenField);
      const hasChild = childList && childList.length;
      const iconSlot = slots.icon;
      const titleSlot = slots.title;
      const extraSlot = slots.extra;
      const isExpand = updateExpandedFlag && treeExpandedMaps[nodeid];
      const nodeItem = nodeMaps[nodeid];
      const nodeValue = import_xe_utils97.default.get(node, titleField);
      const nLevel = nodeItem.level;
      let isRadioChecked = false;
      if (showRadio) {
        isRadioChecked = nodeid === String(selectRadioKey);
      }
      let isCheckboxChecked = false;
      if (showCheckbox) {
        isCheckboxChecked = isCheckedByCheckboxNodeId(nodeid);
      }
      let hasLazyChilds = false;
      let isLazyLoading = false;
      let isLazyLoaded = false;
      if (lazy) {
        isLazyLoading = !!treeExpandLazyLoadedMaps[nodeid];
        hasLazyChilds = node[hasChildField];
        isLazyLoaded = !!nodeItem.treeLoaded;
      }
      const prevNode = nodeItem.items[nodeItem.treeIndex - 1];
      const nParams = { node, isExpand };
      return h("div", {
        key: nodeid,
        class: ["vxe-tree--node-wrapper", `node--level-${nLevel}`],
        nodeid
      }, [
        h("div", {
          class: ["vxe-tree--node-item", {
            "is--current": currentNode && nodeid === getNodeId(currentNode),
            "is-radio--checked": isRadioChecked,
            "is-checkbox--checked": isCheckboxChecked
          }],
          style: {
            paddingLeft: `${(nLevel - 1) * (indent || 1)}px`
          },
          onClick(evnt) {
            handleNodeClickEvent(evnt, node);
          },
          onDblclick(evnt) {
            handleNodeDblclickEvent(evnt, node);
          }
        }, [
          showLine ? h("div", {
            class: "vxe-tree--node-line-wrapper"
          }, [
            h("div", {
              class: "vxe-tree--node-line",
              style: {
                height: `${getNodeId(afterTreeList[0]) === nodeid ? 1 : calcTreeLine($xeTree, node, prevNode)}px`
              }
            })
          ]) : renderEmptyElement($xeTree),
          h("div", {
            class: "vxe-tree--node-item-switcher"
          }, showIcon && (lazy ? isLazyLoaded ? hasChild : hasLazyChilds : hasChild) ? [
            h("div", {
              class: "vxe-tree--node-item-icon",
              onClick(evnt) {
                toggleExpandEvent(evnt, node);
              }
            }, iconSlot ? getSlotVNs2(iconSlot(nParams)) : [
              h("i", {
                class: isLazyLoading ? iconLoaded || getIcon().TREE_NODE_LOADED : isExpand ? iconOpen || getIcon().TREE_NODE_OPEN : iconClose || getIcon().TREE_NODE_CLOSE
              })
            ])
          ] : []),
          renderRadio(node, nodeid, isRadioChecked),
          renderCheckbox(node, nodeid, isCheckboxChecked),
          h("div", {
            class: "vxe-tree--node-item-inner"
          }, [
            h("div", {
              class: "vxe-tree--node-item-title"
            }, titleSlot ? getSlotVNs2(titleSlot(nParams)) : `${nodeValue}`),
            extraSlot ? h("div", {
              class: "vxe-tree--node-item-extra"
            }, getSlotVNs2(extraSlot(nParams))) : renderEmptyElement($xeTree)
          ])
        ])
      ]);
    };
    const renderList = (treeList) => {
      const { transform } = props;
      const { treeExpandedMaps } = internalData;
      const childrenField = computeChildrenField.value;
      if (!treeList.length) {
        return [
          h("div", {
            class: "vxe-tree--empty-placeholder"
          }, getI18n("vxe.tree.searchEmpty"))
        ];
      }
      const nodeVNs = [];
      treeList.forEach(transform ? (node) => {
        const nodeid = getNodeId(node);
        nodeVNs.push(renderNode(node, nodeid));
      } : (node) => {
        const nodeid = getNodeId(node);
        nodeVNs.push(renderNode(node, nodeid));
        const childList = import_xe_utils97.default.get(node, childrenField);
        const hasChild = childList && childList.length;
        if (hasChild && treeExpandedMaps[nodeid]) {
          nodeVNs.push(...renderList(childList));
        }
      });
      return nodeVNs;
    };
    const renderVN = () => {
      const { loading: loading2, trigger, showLine } = props;
      const { bodyHeight, topSpaceHeight, treeList } = reactData;
      const vSize = computeSize.value;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const loadingOpts = computeLoadingOpts.value;
      const isRowHover = computeIsRowHover.value;
      const treeStyle = computeTreeStyle.value;
      const loadingSlot = slots.loading;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      return h("div", {
        ref: refElem,
        class: ["vxe-tree", {
          [`size--${vSize}`]: vSize,
          "show--line": showLine,
          "checkbox--highlight": checkboxOpts.highlight,
          "radio--highlight": radioOpts.highlight,
          "node--hover": isRowHover,
          "node--trigger": trigger === "node",
          "is--loading": loading2
        }]
      }, [
        headerSlot ? h("div", {
          ref: refHeaderWrapperElem,
          class: "vxe-tree--header-wrapper"
        }, headerSlot({ $tree: $xeTree })) : renderEmptyElement($xeTree),
        h("div", {
          ref: refVirtualWrapper,
          class: "vxe-tree--node-list-wrapper",
          style: treeStyle,
          onScroll: scrollEvent
        }, [
          h("div", {
            class: "vxe-tree--y-space",
            style: {
              height: bodyHeight ? `${bodyHeight}px` : ""
            }
          }),
          h("div", {
            ref: refVirtualBody,
            class: "vxe-tree--node-list-body",
            style: {
              transform: `translateY(${topSpaceHeight}px)`
            }
          }, renderList(treeList))
        ]),
        footerSlot ? h("div", {
          ref: refFooterWrapperElem,
          class: "vxe-tree--footer-wrapper"
        }, footerSlot({ $tree: $xeTree })) : renderEmptyElement($xeTree),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-tree--loading",
          modelValue: loading2,
          icon: loadingOpts.icon,
          text: loadingOpts.text
        }, loadingSlot ? {
          default: () => loadingSlot({ $tree: $xeTree })
        } : {})
      ]);
    };
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : 0, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      loadData(props.data || []);
    });
    watch(() => props.checkNodeKey, (nodeKey) => {
      reactData.selectRadioKey = enNodeValue(nodeKey);
    });
    const checkboxFlag = ref(0);
    watch(() => props.checkNodeKeys ? props.checkNodeKeys.length : 0, () => {
      checkboxFlag.value++;
    });
    watch(() => props.checkNodeKeys, () => {
      checkboxFlag.value++;
    });
    watch(checkboxFlag, () => {
      updateCheckboxChecked(props.checkNodeKeys || []);
    });
    watch(() => props.filterValue, () => {
      triggerSearchEvent(new Event("filter"));
    });
    const hFlag = ref(0);
    watch(() => props.height, () => {
      hFlag.value++;
    });
    watch(() => props.minHeight, () => {
      hFlag.value++;
    });
    watch(() => props.maxHeight, () => {
      hFlag.value++;
    });
    watch(hFlag, () => {
      recalculate();
    });
    onMounted(() => {
      if (props.autoResize) {
        const el = refElem.value;
        const parentEl = getParentElem();
        const resizeObserver = globalResize.create(() => {
          if (props.autoResize) {
            recalculate();
          }
        });
        if (el) {
          resizeObserver.observe(el);
        }
        if (parentEl) {
          resizeObserver.observe(parentEl);
        }
        internalData.resizeObserver = resizeObserver;
      }
      globalEvents.on($xeTree, "resize", handleGlobalResizeEvent);
    });
    onUnmounted(() => {
      const { resizeObserver } = internalData;
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      globalEvents.off($xeTree, "resize");
      import_xe_utils97.default.assign(internalData, createInternalData5());
    });
    loadData(props.data || []);
    $xeTree.renderVN = renderVN;
    return $xeTree;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/tree/index.js
var VxeTree = Object.assign({}, tree_default, {
  install(app) {
    app.component(tree_default.name, tree_default);
  }
});
dynamicApp.use(VxeTree);
VxeUI.component(tree_default);
var Tree = VxeTree;
var tree_default2 = VxeTree;

// node_modules/vxe-pc-ui/es/tree-select/src/tree-select.js
var import_xe_utils98 = __toESM(require_xe_utils());
function getOptUniqueId2() {
  return import_xe_utils98.default.uniqueId("node_");
}
function createInternalData6() {
  return {
    // hpTimeout: undefined,
    fullOptionList: [],
    fullNodeMaps: {}
  };
}
var tree_select_default = defineVxeComponent({
  name: "VxeTreeSelect",
  props: {
    modelValue: [String, Number, Array],
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => import_xe_utils98.default.eqNull(getConfig().treeSelect.placeholder) ? getI18n("vxe.base.pleaseSelect") : getConfig().treeSelect.placeholder
    },
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    filterable: Boolean,
    filterConfig: Object,
    multiple: Boolean,
    className: [String, Function],
    popupClassName: [String, Function],
    prefixIcon: String,
    placement: String,
    lazyOptions: Array,
    options: Array,
    optionProps: Object,
    zIndex: Number,
    size: {
      type: String,
      default: () => getConfig().treeSelect.size || getConfig().size
    },
    remote: Boolean,
    remoteConfig: Function,
    popupConfig: Object,
    treeConfig: Object,
    virtualYConfig: Object,
    autoClose: {
      type: Boolean,
      default: () => getConfig().treeSelect.autoClose
    },
    showTotalButoon: {
      type: Boolean,
      default: () => getConfig().treeSelect.showTotalButoon
    },
    showCheckedButoon: {
      type: Boolean,
      default: () => getConfig().treeSelect.showCheckedButoon
    },
    showClearButton: {
      type: Boolean,
      default: () => getConfig().treeSelect.showClearButton
    },
    showExpandButton: {
      type: Boolean,
      default: () => getConfig().treeSelect.showExpandButton
    },
    transfer: {
      type: Boolean,
      default: null
    },
    /**
     * 已废弃，被 remote-config.queryMethod 替换
     * @deprecated
     */
    remoteMethod: Function
  },
  emits: [
    "update:modelValue",
    "change",
    "all-change",
    "clear",
    "blur",
    "focus",
    "click",
    "node-click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils98.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refInput = ref();
    const refInpSearch = ref();
    const refTreeWrapper = ref();
    const refOptionPanel = ref();
    const refTree = ref();
    const reactData = reactive({
      initialized: false,
      searchValue: "",
      searchLoading: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = createInternalData6();
    const refMaps = {
      refElem
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (import_xe_utils98.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computePopupOpts = computed(() => {
      return Object.assign({}, getConfig().treeSelect.popupConfig, props.popupConfig);
    });
    const computeTreeOpts = computed(() => {
      return Object.assign({}, getConfig().treeSelect.treeConfig, props.treeConfig, { data: void 0 });
    });
    const computeTreeNodeOpts = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({ isHover: true }, treeOpts.nodeConfig);
    });
    const computeTreeCheckboxOpts = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        showIcon: !!treeOpts.showCheckbox
      }, treeOpts.checkboxConfig, {
        trigger: "node"
      });
    });
    const computeTreeRadioOpts = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        showIcon: !!treeOpts.showRadio
      }, treeOpts.radioConfig, {
        trigger: "node"
      });
    });
    const computePropsOpts = computed(() => {
      return props.optionProps || {};
    });
    const computeNodeKeyField = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return treeOpts.keyField || "id";
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeChildrenField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.children || "children";
    });
    const computeParentField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.parent || "parentField";
    });
    const computeHasChildField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.hasChild || "hasChild";
    });
    const computeVirtualYOpts = computed(() => {
      return Object.assign({}, getConfig().treeSelect.virtualYConfig, props.virtualYConfig);
    });
    const computeRemoteOpts = computed(() => {
      return Object.assign({}, getConfig().treeSelect.remoteConfig, props.remoteConfig);
    });
    const computeFilterOpts = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({}, treeOpts.filterConfig, props.filterConfig);
    });
    const computeSelectLabel = computed(() => {
      const { modelValue, lazyOptions } = props;
      const { fullNodeMaps } = internalData;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const selectVals = import_xe_utils98.default.eqNull(modelValue) ? [] : import_xe_utils98.default.isArray(modelValue) ? modelValue : [modelValue];
      return selectVals.map((val) => {
        const cacheItem = fullNodeMaps[val];
        if (cacheItem) {
          return cacheItem.item[labelField];
        }
        if (lazyOptions) {
          const lazyItem = lazyOptions.find((item) => item[valueField] === val);
          if (lazyItem) {
            return lazyItem[labelField];
          }
        }
        return val;
      }).join(", ");
    });
    const computePopupWrapperStyle = computed(() => {
      const popupOpts = computePopupOpts.value;
      const { height, width } = popupOpts;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
        stys.maxHeight = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {};
    const $xeTreeSelect = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $treeSelect: $xeTreeSelect }, params));
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const treeSelectMethods = {
      dispatchEvent
    };
    const getNodeid = (option) => {
      const nodeKeyField = computeNodeKeyField.value;
      const nodeid = option[nodeKeyField];
      return nodeid ? encodeURIComponent(nodeid) : "";
    };
    const cacheDataMap = () => {
      const { options } = props;
      const treeOpts = computeTreeOpts.value;
      const nodeKeyField = computeNodeKeyField.value;
      const childrenField = computeChildrenField.value;
      const valueField = computeValueField.value;
      const { transform } = treeOpts;
      const nodeMaps = {};
      const keyMaps = {};
      const handleOptNode = (item, index, items, path, parent2, nodes) => {
        let nodeid = getNodeid(item);
        if (!nodeid) {
          nodeid = getOptUniqueId2();
        }
        if (keyMaps[nodeid]) {
          errLog("vxe.error.repeatKey", [`[tree-select] ${nodeKeyField}`, nodeid]);
        }
        keyMaps[nodeid] = true;
        const value = item[valueField];
        if (nodeMaps[value]) {
          errLog("vxe.error.repeatKey", [`[tree-select] ${valueField}`, value]);
        }
        nodeMaps[value] = { item, index, items, parent: parent2, nodes };
      };
      if (options) {
        if (transform) {
          options.forEach((item, index, items) => {
            handleOptNode(item, index, items, [], null, []);
          });
        } else {
          import_xe_utils98.default.eachTree(options, handleOptNode, { children: childrenField });
        }
      }
      internalData.fullOptionList = options || [];
      internalData.fullNodeMaps = nodeMaps;
    };
    const updateZindex = () => {
      const { zIndex } = props;
      if (zIndex) {
        reactData.panelIndex = zIndex;
      } else if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const { placement } = props;
      const { panelIndex } = reactData;
      const targetElem = refElem.value;
      const panelElem = refOptionPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return nextTick().then(handleStyle);
    };
    const showOptionPanel = () => {
      const { loading: loading2, remote, filterable } = props;
      const { fullOptionList } = internalData;
      const isDisabled = computeIsDisabled.value;
      const remoteOpts = computeRemoteOpts.value;
      if (!loading2 && !isDisabled) {
        clearTimeout(internalData.hpTimeout);
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (filterable) {
          if (remote && remoteOpts.enabled && remoteOpts.autoLoad && !fullOptionList.length) {
            handleSearchEvent();
          }
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
          handleFocusSearch();
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue, node) => {
      const value = import_xe_utils98.default.isArray(selectValue) ? selectValue.map(deNodeValue) : deNodeValue(selectValue);
      emitModel(value);
      if (value !== props.modelValue) {
        dispatchEvent("change", { value, node, option: node }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue, null);
      dispatchEvent("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const allCheckedPanelEvent = (params) => {
      const { $event } = params;
      const { multiple, autoClose } = props;
      const $tree = refTree.value;
      if (multiple) {
        if ($tree) {
          $tree.setAllCheckboxNode(true).then(({ checkNodeKeys, checkNodes }) => {
            changeEvent($event, checkNodeKeys, checkNodes[0]);
            dispatchEvent("all-change", { value: checkNodeKeys }, $event);
            if (autoClose) {
              hideOptionPanel();
            }
          });
        }
      }
    };
    const clearCheckedPanelEvent = (params) => {
      const { $event } = params;
      const { multiple, autoClose } = props;
      const $tree = refTree.value;
      if ($tree) {
        const value = multiple ? [] : null;
        $tree.clearCheckboxNode().then(() => {
          if (autoClose) {
            hideOptionPanel();
          }
        });
        changeEvent($event, value, null);
        dispatchEvent("clear", { value }, $event);
      }
    };
    const allExpandPanelEvent = () => {
      const $tree = refTree.value;
      if ($tree) {
        $tree.setAllExpandNode(true);
      }
    };
    const clearExpandPanelEvent = () => {
      const $tree = refTree.value;
      if ($tree) {
        $tree.clearAllExpandNode();
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { visiblePanel, isActivated } = reactData;
      if (visiblePanel) {
        hideOptionPanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const { visiblePanel } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    const handleFocusSearch = () => {
      if (props.filterable) {
        nextTick(() => {
          const inpSearch = refInpSearch.value;
          if (inpSearch) {
            inpSearch.focus();
          }
        });
      }
    };
    const focusEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 150);
        }
      }
      dispatchEvent("focus", {}, evnt);
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      dispatchEvent("click", {}, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      dispatchEvent("blur", {}, evnt);
    };
    const modelSearchEvent = (value) => {
      reactData.searchValue = value;
    };
    const handleSearchEvent = () => {
      const { modelValue, remote, remoteMethod } = props;
      const { searchValue } = reactData;
      const remoteOpts = computeRemoteOpts.value;
      const queryMethod = remoteOpts.queryMethod || remoteMethod;
      if (remote && queryMethod && remoteOpts.enabled) {
        reactData.searchLoading = true;
        Promise.resolve(queryMethod({ $treeSelect: $xeTreeSelect, searchValue, value: modelValue })).then(() => nextTick()).catch(() => nextTick()).finally(() => {
          reactData.searchLoading = false;
        });
      }
    };
    const togglePanelEvent = (params) => {
      const { $event } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const nodeClickEvent = (params) => {
      const { $event } = params;
      dispatchEvent("node-click", params, $event);
    };
    const radioChangeEvent = (params) => {
      const { value, $event, node } = params;
      changeEvent($event, value, node);
      hideOptionPanel();
    };
    const checkboxChangeEvent = (params) => {
      const { value, $event, node } = params;
      changeEvent($event, value, node);
    };
    const loadSuccessEvent = () => {
      cacheDataMap();
    };
    const treeSelectPrivateMethods = {};
    Object.assign($xeTreeSelect, treeSelectMethods, treeSelectPrivateMethods);
    const renderVN = () => {
      const { className, modelValue, multiple, options, loading: loading2, filterable, showTotalButoon, showCheckedButoon, showClearButton, showExpandButton } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel, searchValue } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const popupWrapperStyle = computePopupWrapperStyle.value;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      const popupOpts = computePopupOpts.value;
      const popupClassName = popupOpts.className || props.popupClassName;
      const treeOpts = computeTreeOpts.value;
      const treeNodeOpts = computeTreeNodeOpts.value;
      const treeCheckboxOpts = computeTreeCheckboxOpts.value;
      const treeRadioOpts = computeTreeRadioOpts.value;
      const nodeKeyField = computeNodeKeyField.value;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const childrenField = computeChildrenField.value;
      const parentField = computeParentField.value;
      const hasChildField = computeHasChildField.value;
      const virtualYOpts = computeVirtualYOpts.value;
      const filterOpts = computeFilterOpts.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-tree-select--readonly", className]
        }, [
          h("span", {
            class: "vxe-tree-select-label"
          }, selectLabel)
        ]);
      }
      const selectVals = import_xe_utils98.default.eqNull(modelValue) ? [] : import_xe_utils98.default.isArray(modelValue) ? modelValue : [modelValue];
      return h("div", {
        ref: refElem,
        class: ["vxe-tree-select", className ? import_xe_utils98.default.isFunction(className) ? className({ $treeSelect: $xeTreeSelect }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--filterable": filterable,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--loading": loading2,
          "is--active": isActivated
        }]
      }, [
        h(input_default, {
          ref: refInput,
          clearable: props.clearable,
          placeholder: loading2 ? getI18n("vxe.select.loadingText") : props.placeholder,
          readonly: true,
          disabled: isDisabled,
          type: "text",
          prefixIcon: props.prefixIcon,
          suffixIcon: loading2 ? getIcon().TREE_SELECT_LOADED : visiblePanel ? getIcon().TREE_SELECT_OPEN : getIcon().TREE_SELECT_CLOSE,
          modelValue: loading2 ? "" : selectLabel,
          title: selectLabel,
          onClear: clearEvent,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent,
          onSuffixClick: togglePanelEvent
        }, prefixSlot ? {
          prefix: () => prefixSlot({})
        } : {}),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-tree-select--panel", popupClassName ? import_xe_utils98.default.isFunction(popupClassName) ? popupClassName({ $treeSelect: $xeTreeSelect }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": !loading2 && isAniVisible,
              "ani--enter": !loading2 && visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, initialized ? [
            h("div", {
              class: "vxe-tree-select--panel-wrapper"
            }, [
              filterable ? h("div", {
                class: "vxe-tree-select--panel-search"
              }, [
                h(input_default, {
                  ref: refInpSearch,
                  class: "vxe-tree-select-search--input",
                  modelValue: searchValue,
                  clearable: true,
                  disabled: false,
                  readonly: false,
                  placeholder: getI18n("vxe.treeSelect.search"),
                  prefixIcon: getIcon().INPUT_SEARCH,
                  "onUpdate:modelValue": modelSearchEvent
                })
              ]) : renderEmptyElement($xeTreeSelect),
              showTotalButoon || showCheckedButoon && multiple || showClearButton || showExpandButton || headerSlot ? h("div", {
                class: "vxe-tree-select--panel-header"
              }, headerSlot ? headerSlot({}) : [
                h("div", {
                  class: "vxe-tree-select--header-button"
                }, [
                  showTotalButoon ? h("div", {
                    class: "vxe-tree-select--header-total"
                  }, getI18n("vxe.treeSelect.total", [selectVals.length])) : renderEmptyElement($xeTreeSelect),
                  h("div", {
                    class: "vxe-tree-select--header-btns"
                  }, [
                    showCheckedButoon && multiple ? h(button_default, {
                      content: getI18n("vxe.treeSelect.allChecked"),
                      mode: "text",
                      onClick: allCheckedPanelEvent
                    }) : renderEmptyElement($xeTreeSelect),
                    showClearButton ? h(button_default, {
                      content: getI18n("vxe.treeSelect.clearChecked"),
                      mode: "text",
                      onClick: clearCheckedPanelEvent
                    }) : renderEmptyElement($xeTreeSelect),
                    showExpandButton ? h(button_default, {
                      content: getI18n("vxe.treeSelect.allExpand"),
                      mode: "text",
                      onClick: allExpandPanelEvent
                    }) : renderEmptyElement($xeTreeSelect),
                    showExpandButton ? h(button_default, {
                      content: getI18n("vxe.treeSelect.clearExpand"),
                      mode: "text",
                      onClick: clearExpandPanelEvent
                    }) : renderEmptyElement($xeTreeSelect)
                  ])
                ])
              ]) : renderEmptyElement($xeTreeSelect),
              h("div", {
                class: "vxe-tree-select--panel-body"
              }, [
                h("div", {
                  ref: refTreeWrapper,
                  class: "vxe-tree-select-tree--wrapper",
                  style: popupWrapperStyle
                }, [
                  h(tree_default, {
                    ref: refTree,
                    class: "vxe-tree-select--tree",
                    height: popupOpts.height ? "100%" : treeOpts.height,
                    minHeight: treeOpts.minHeight,
                    maxHeight: popupOpts.height ? "" : treeOpts.maxHeight,
                    autoResize: true,
                    data: options,
                    indent: treeOpts.indent,
                    showRadio: !multiple,
                    radioConfig: treeRadioOpts,
                    checkNodeKey: multiple ? null : modelValue,
                    showCheckbox: !!multiple,
                    checkNodeKeys: multiple ? modelValue : null,
                    checkboxConfig: treeCheckboxOpts,
                    titleField: labelField,
                    valueField,
                    keyField: nodeKeyField,
                    childrenField: treeOpts.childrenField || childrenField,
                    parentField: treeOpts.parentField || parentField,
                    hasChildField: treeOpts.hasChildField || hasChildField,
                    accordion: treeOpts.accordion,
                    expandAll: treeOpts.expandAll,
                    expandNodeKeys: treeOpts.expandNodeKeys,
                    nodeConfig: treeNodeOpts,
                    lazy: treeOpts.lazy,
                    loadMethod: treeOpts.loadMethod,
                    toggleMethod: treeOpts.toggleMethod,
                    transform: treeOpts.transform,
                    trigger: treeOpts.trigger,
                    showIcon: treeOpts.showIcon,
                    showLine: treeOpts.showLine,
                    iconOpen: treeOpts.iconOpen,
                    iconLoaded: treeOpts.iconLoaded,
                    iconClose: treeOpts.iconClose,
                    filterValue: searchValue,
                    filterConfig: filterOpts,
                    virtualYConfig: virtualYOpts,
                    onNodeClick: nodeClickEvent,
                    onRadioChange: radioChangeEvent,
                    onCheckboxChange: checkboxChangeEvent,
                    onLoadSuccess: loadSuccessEvent
                  })
                ])
              ]),
              footerSlot ? h("div", {
                class: "vxe-tree-select--panel-footer"
              }, footerSlot({})) : renderEmptyElement($xeTreeSelect)
            ])
          ] : [])
        ])
      ]);
    };
    watch(() => props.options, () => {
      cacheDataMap();
    });
    cacheDataMap();
    onMounted(() => {
      globalEvents.on($xeTreeSelect, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeTreeSelect, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeTreeSelect, "blur", handleGlobalBlurEvent);
      globalEvents.on($xeTreeSelect, "resize", handleGlobalResizeEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeTreeSelect, "mousewheel");
      globalEvents.off($xeTreeSelect, "mousedown");
      globalEvents.off($xeTreeSelect, "blur");
      globalEvents.off($xeTreeSelect, "resize");
      import_xe_utils98.default.assign(internalData, createInternalData6());
    });
    provide("$xeTreeSelect", $xeTreeSelect);
    $xeTreeSelect.renderVN = renderVN;
    return $xeTreeSelect;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/tree-select/index.js
var VxeTreeSelect = Object.assign({}, tree_select_default, {
  install(app) {
    app.component(tree_select_default.name, tree_select_default);
  }
});
dynamicApp.use(VxeTreeSelect);
VxeUI.component(tree_select_default);
var TreeSelect = VxeTreeSelect;
var tree_select_default2 = VxeTreeSelect;

// node_modules/vxe-pc-ui/es/upload/src/upload.js
var import_xe_utils100 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/upload/src/util.js
var import_xe_utils99 = __toESM(require_xe_utils());
var fileForm = null;
var fileInput = null;
function parseFile(file) {
  const name = file.name;
  const tIndex = import_xe_utils99.default.lastIndexOf(name, ".");
  const type = name.substring(tIndex + 1, name.length).toLowerCase();
  const filename = name.substring(0, tIndex);
  return { filename, type };
}
var readLocalFile = (options) => {
  const opts = Object.assign({}, options);
  return new Promise((resolve, reject) => {
    if (!fileInput) {
      fileInput = document.createElement("input");
      fileInput.name = "file";
      fileInput.type = "file";
    }
    if (!fileForm) {
      fileForm = document.createElement("form");
      fileForm.style.display = "none";
      fileForm.appendChild(fileInput);
      document.body.appendChild(fileForm);
    }
    const types = opts.types || [];
    const isAllType = !types.length || types.some((type) => type === "*");
    fileInput.multiple = !!opts.multiple;
    fileInput.accept = isAllType ? "" : `.${types.join(", .")}`;
    fileInput.onchange = (evnt) => {
      const eventTarget = evnt.target;
      const files = Array.from(eventTarget.files || []);
      const file = files[0];
      let errType = "";
      if (!isAllType) {
        for (let fIndex = 0; fIndex < files.length; fIndex++) {
          const { type } = parseFile(files[fIndex]);
          if (!import_xe_utils99.default.includes(types, type)) {
            errType = type;
            break;
          }
        }
      }
      if (!errType) {
        resolve({ status: true, files, file });
      } else {
        if (opts.message !== false) {
          if (VxeUI.modal) {
            VxeUI.modal.message({
              content: getI18n("vxe.error.notType", [errType]),
              status: "error"
            });
          }
        }
        const params = { status: false, files, file };
        reject(params);
      }
    };
    fileForm.reset();
    fileInput.click();
  });
};
function getExportBlobByContent(content, options) {
  return new Blob([content], { type: `text/${options.type};charset=utf-8;` });
}
var saveLocalFile = (options) => {
  const opts = Object.assign({ type: "" }, options);
  const { filename, type, content } = opts;
  const name = type ? `${filename}.${type}` : `${filename}`;
  if (window.Blob) {
    const blob = content instanceof Blob ? content : getExportBlobByContent(import_xe_utils99.default.toValueString(content), opts);
    const winNavigator = window.navigator;
    if (winNavigator.msSaveBlob) {
      winNavigator.msSaveBlob(blob, name);
    } else {
      const url = URL.createObjectURL(blob);
      const linkElem = document.createElement("a");
      linkElem.target = "_blank";
      linkElem.download = name;
      linkElem.href = url;
      document.body.appendChild(linkElem);
      linkElem.click();
      requestAnimationFrame(() => {
        if (linkElem.parentNode) {
          linkElem.parentNode.removeChild(linkElem);
        }
        URL.revokeObjectURL(url);
      });
    }
    return Promise.resolve();
  }
  return Promise.reject(new Error(getI18n("vxe.error.notExp")));
};

// node_modules/vxe-pc-ui/es/upload/src/upload.js
var upload_default = defineVxeComponent({
  name: "VxeUpload",
  props: {
    modelValue: [Array, String, Object],
    showList: {
      type: Boolean,
      default: () => getConfig().upload.showList
    },
    moreConfig: Object,
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    autoSubmit: {
      type: Boolean,
      default: () => getConfig().upload.autoSubmit
    },
    mode: {
      type: String,
      default: () => getConfig().upload.mode
    },
    imageTypes: {
      type: Array,
      default: () => import_xe_utils100.default.clone(getConfig().upload.imageTypes, true)
    },
    imageConfig: {
      type: Object,
      default: () => import_xe_utils100.default.clone(getConfig().upload.imageConfig, true)
    },
    /**
     * 已废弃，被 image-config 替换
     * @deprecated
     */
    imageStyle: {
      type: Object,
      default: () => import_xe_utils100.default.clone(getConfig().upload.imageStyle, true)
    },
    fileTypes: {
      type: Array,
      default: () => import_xe_utils100.default.clone(getConfig().upload.fileTypes, true)
    },
    dragSort: Boolean,
    dragToUpload: {
      type: Boolean,
      default: () => import_xe_utils100.default.clone(getConfig().upload.dragToUpload, true)
    },
    pasteToUpload: {
      type: Boolean,
      default: () => import_xe_utils100.default.clone(getConfig().upload.pasteToUpload, true)
    },
    keyField: String,
    singleMode: Boolean,
    urlMode: Boolean,
    urlArgs: {
      type: Boolean,
      default: () => getConfig().upload.urlArgs
    },
    multiple: Boolean,
    limitSize: {
      type: [String, Number],
      default: () => getConfig().upload.limitSize
    },
    showLimitSize: {
      type: Boolean,
      default: () => getConfig().upload.showLimitSize
    },
    limitSizeText: {
      type: [String, Number, Function],
      default: () => getConfig().upload.limitSizeText
    },
    limitCount: {
      type: [String, Number],
      default: () => getConfig().upload.limitCount
    },
    showLimitCount: {
      type: Boolean,
      default: () => getConfig().upload.showLimitCount
    },
    limitCountText: {
      type: [String, Number, Function],
      default: () => getConfig().upload.limitCountText
    },
    nameField: {
      type: String,
      default: () => getConfig().upload.nameField
    },
    typeField: {
      type: String,
      default: () => getConfig().upload.typeField
    },
    urlField: {
      type: String,
      default: () => getConfig().upload.urlField
    },
    sizeField: {
      type: String,
      default: () => getConfig().upload.sizeField
    },
    showErrorStatus: {
      type: Boolean,
      default: () => getConfig().upload.showErrorStatus
    },
    showProgress: {
      type: Boolean,
      default: () => getConfig().upload.showProgress
    },
    progressText: {
      type: [String, Number, Function],
      default: () => getConfig().upload.progressText
    },
    showSubmitButton: Boolean,
    autoHiddenButton: {
      type: Boolean,
      default: () => getConfig().upload.autoHiddenButton
    },
    showUploadButton: {
      type: Boolean,
      default: () => getConfig().upload.showUploadButton
    },
    buttonText: {
      type: [String, Number, Function],
      default: () => getConfig().upload.buttonText
    },
    buttonIcon: {
      type: String,
      default: () => getConfig().upload.buttonIcon
    },
    showButtonText: {
      type: Boolean,
      default: () => getConfig().upload.showButtonText
    },
    showButtonIcon: {
      type: Boolean,
      default: () => getConfig().upload.showButtonIcon
    },
    showRemoveButton: {
      type: Boolean,
      default: () => getConfig().upload.showRemoveButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().upload.showDownloadButton
    },
    showPreview: {
      type: Boolean,
      default: () => getConfig().upload.showPreview
    },
    showTip: {
      type: Boolean,
      default: () => null
    },
    maxSimultaneousUploads: {
      type: Number,
      default: () => getConfig().upload.maxSimultaneousUploads
    },
    tipText: [String, Number, Function],
    hintText: String,
    previewMethod: Function,
    uploadMethod: Function,
    beforeRemoveMethod: Function,
    removeMethod: Function,
    beforeDownloadMethod: Function,
    downloadMethod: Function,
    getUrlMethod: Function,
    getThumbnailUrlMethod: Function,
    size: {
      type: String,
      default: () => getConfig().upload.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "add",
    "remove",
    "remove-fail",
    "download",
    "download-fail",
    "upload-success",
    "upload-error",
    "sort-dragend",
    "more-visible"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const $xeTable = inject("$xeTable", null);
    const xID = import_xe_utils100.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refPopupElem = ref();
    const refDragLineElem = ref();
    const refModalDragLineElem = ref();
    const reactData = reactive({
      isDragUploadStatus: false,
      showMorePopup: false,
      isActivated: false,
      fileList: [],
      fileCacheMaps: {},
      isDragMove: false,
      dragIndex: -1,
      dragTipText: ""
    });
    const internalData = {
      moreId: import_xe_utils100.default.uniqueId("upload"),
      imagePreviewTypes: ["jpg", "jpeg", "png", "gif"],
      prevDragIndex: -1
      // prevDragPos: ''
    };
    const refMaps = {
      refElem
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeKeyField = computed(() => {
      return props.keyField || "_X_KEY";
    });
    const computeIsImage = computed(() => {
      return props.mode === "image";
    });
    const computeNameProp = computed(() => {
      return props.nameField || "name";
    });
    const computeTypeProp = computed(() => {
      return props.typeField || "type";
    });
    const computeUrlProp = computed(() => {
      return props.urlField || "url";
    });
    const computeSizeProp = computed(() => {
      return props.sizeField || "size";
    });
    const computeLimitMaxSize = computed(() => {
      return import_xe_utils100.default.toNumber(props.limitSize) * 1024 * 1024;
    });
    const computeLimitMaxCount = computed(() => {
      return props.multiple ? import_xe_utils100.default.toNumber(props.limitCount) : 1;
    });
    const computeOverCount = computed(() => {
      const { multiple } = props;
      const { fileList } = reactData;
      const limitMaxCount = computeLimitMaxCount.value;
      if (multiple) {
        if (limitMaxCount) {
          return fileList.length >= limitMaxCount;
        }
        return true;
      }
      return fileList.length >= 1;
    });
    const computeLimitSizeUnit = computed(() => {
      const limitSize = import_xe_utils100.default.toNumber(props.limitSize);
      if (limitSize) {
        if (limitSize > 1048576) {
          return `${limitSize / 1048576}T`;
        }
        if (limitSize > 1024) {
          return `${limitSize / 1024}G`;
        }
        return `${limitSize}M`;
      }
      return "";
    });
    const computedShowTipText = computed(() => {
      const { showTip, tipText } = props;
      if (import_xe_utils100.default.isBoolean(showTip)) {
        return showTip;
      }
      const defShowTip = getConfig().upload.showTip;
      if (import_xe_utils100.default.isBoolean(defShowTip)) {
        return defShowTip;
      }
      if (tipText) {
        return true;
      }
      return false;
    });
    const computedDefTipText = computed(() => {
      const { limitSize, fileTypes, multiple, limitCount } = props;
      const tipText = props.tipText || props.hintText;
      const isImage = computeIsImage.value;
      const limitSizeUnit = computeLimitSizeUnit.value;
      if (import_xe_utils100.default.isString(tipText)) {
        return tipText;
      }
      if (import_xe_utils100.default.isFunction(tipText)) {
        return `${tipText({})}`;
      }
      const defTips = [];
      if (isImage) {
        if (multiple && limitCount) {
          defTips.push(getI18n("vxe.upload.imgCountHint", [limitCount]));
        }
        if (limitSize && limitSizeUnit) {
          defTips.push(getI18n("vxe.upload.imgSizeHint", [limitSizeUnit]));
        }
      } else {
        if (fileTypes && fileTypes.length) {
          defTips.push(getI18n("vxe.upload.fileTypeHint", [fileTypes.join("/")]));
        }
        if (limitSize && limitSizeUnit) {
          defTips.push(getI18n("vxe.upload.fileSizeHint", [limitSizeUnit]));
        }
        if (multiple && limitCount) {
          defTips.push(getI18n("vxe.upload.fileCountHint", [limitCount]));
        }
      }
      return defTips.join(getI18n("vxe.base.comma"));
    });
    const computeImageOpts = computed(() => {
      return Object.assign({}, props.imageConfig || props.imageStyle);
    });
    const computeImgStyle = computed(() => {
      const imageOpts = computeImageOpts.value;
      const { width, height } = imageOpts;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMoreOpts = computed(() => {
      return Object.assign({ showMoreButton: true }, props.moreConfig);
    });
    const computeMaps = {};
    const $xeUpload = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getUniqueKey = () => {
      return import_xe_utils100.default.uniqueId();
    };
    const getFieldKey = (item) => {
      const keyField = computeKeyField.value;
      return item[keyField];
    };
    const updateFileList = () => {
      const { modelValue, multiple } = props;
      const formReadonly = computeFormReadonly.value;
      const keyField = computeKeyField.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const urlProp = computeUrlProp.value;
      const sizeProp = computeSizeProp.value;
      const fileList = modelValue ? (modelValue ? import_xe_utils100.default.isArray(modelValue) ? modelValue : [modelValue] : []).map((item) => {
        if (!item || import_xe_utils100.default.isString(item)) {
          const url = `${item || ""}`;
          const urlObj = import_xe_utils100.default.parseUrl(item);
          const name2 = (urlObj ? urlObj.searchQuery[nameProp] : "") || parseFileName(url);
          return {
            [nameProp]: name2,
            [typeProp]: (urlObj ? urlObj.searchQuery[typeProp] : "") || parseFileType(name2),
            [urlProp]: url,
            [sizeProp]: import_xe_utils100.default.toNumber(urlObj ? urlObj.searchQuery[sizeProp] : 0) || 0,
            [keyField]: getUniqueKey()
          };
        }
        const name = item[nameProp] || "";
        item[nameProp] = name;
        item[typeProp] = item[typeProp] || parseFileType(name);
        item[urlProp] = item[urlProp] || "";
        item[sizeProp] = item[sizeProp] || 0;
        item[keyField] = item[keyField] || getUniqueKey();
        return item;
      }) : [];
      reactData.fileList = formReadonly || multiple ? fileList : fileList.slice(0, 1);
    };
    const parseFileName = (url) => {
      return decodeURIComponent(`${url || ""}`).split("/").pop() || "";
    };
    const parseFileType = (name) => {
      const index = name.lastIndexOf(".");
      if (index > 0) {
        return name.substring(index + 1).toLowerCase();
      }
      return "";
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $upload: $xeUpload }, params));
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const handleChange = (value) => {
      const { singleMode, urlArgs } = props;
      const urlProp = computeUrlProp.value;
      const nameProp = computeNameProp.value;
      let restList = value ? value.slice(0) : [];
      if (urlArgs) {
        restList = restList.map((item) => {
          const url = item[urlProp];
          if (url) {
            const urlObj = import_xe_utils100.default.parseUrl(url);
            if (!urlObj.searchQuery[nameProp]) {
              if (url.indexOf("blob:") === -1) {
                return `${url}${url.indexOf("?") === -1 ? "?" : "&"}${nameProp}=${encodeURIComponent(item[nameProp] || "")}`;
              }
            }
          }
          return url;
        });
      }
      emitModel(singleMode ? restList[0] || null : restList);
    };
    const getThumbnailFileUrl = (item) => {
      const getThumbnailUrlFn = props.getThumbnailUrlMethod || getConfig().upload.getThumbnailUrlMethod;
      if (getThumbnailUrlFn) {
        return getThumbnailUrlFn({
          $upload: $xeUpload,
          option: item
        });
      }
      return getFileUrl(item);
    };
    const getFileUrl = (item) => {
      const getUrlFn = props.getUrlMethod || getConfig().upload.getUrlMethod;
      const urlProp = computeUrlProp.value;
      return getUrlFn ? getUrlFn({
        $upload: $xeUpload,
        option: item
      }) : item[urlProp];
    };
    const handleDefaultFilePreview = (item) => {
      const { imageTypes, showDownloadButton } = props;
      const typeProp = computeTypeProp.value;
      const beforeDownloadFn = props.beforeDownloadMethod || getConfig().upload.beforeDownloadMethod;
      const { imagePreviewTypes } = internalData;
      if (imagePreviewTypes.concat(imageTypes || []).some((type) => `${type}`.toLowerCase() === `${item[typeProp]}`.toLowerCase())) {
        if (VxeUI.previewImage) {
          VxeUI.previewImage({
            urlList: [getFileUrl(item)],
            showDownloadButton,
            beforeDownloadMethod: beforeDownloadFn ? () => {
              return beforeDownloadFn({
                $upload: $xeUpload,
                option: item
              });
            } : void 0
          });
        }
      }
    };
    const handlePreviewFileEvent = (evnt, item) => {
      const previewFn = props.previewMethod || getConfig().upload.previewMethod;
      if (props.showPreview) {
        if (previewFn) {
          previewFn({
            $upload: $xeUpload,
            option: item
          });
        } else {
          handleDefaultFilePreview(item);
        }
      }
    };
    const handlePreviewImageEvent = (evnt, item, index) => {
      const { showDownloadButton } = props;
      const { fileList } = reactData;
      const beforeDownloadFn = props.beforeDownloadMethod || getConfig().upload.beforeDownloadMethod;
      if (props.showPreview) {
        if (VxeUI.previewImage) {
          VxeUI.previewImage({
            urlList: fileList.map((item2) => getFileUrl(item2)),
            activeIndex: index,
            showDownloadButton,
            beforeDownloadMethod: beforeDownloadFn ? ({ index: index2 }) => {
              return beforeDownloadFn({
                $upload: $xeUpload,
                option: fileList[index2]
              });
            } : void 0
          });
        }
      }
    };
    const handleUploadResult = (item, file) => {
      const { showErrorStatus } = props;
      const fileKey = getFieldKey(item);
      const uploadFn = props.uploadMethod || getConfig().upload.uploadMethod;
      if (uploadFn) {
        return Promise.resolve(uploadFn({
          $upload: $xeUpload,
          file,
          option: item,
          updateProgress(percentNum) {
            const { fileCacheMaps } = reactData;
            const cacheItem = fileCacheMaps[getFieldKey(item)];
            if (cacheItem) {
              cacheItem.percent = Math.max(0, Math.min(99, import_xe_utils100.default.toNumber(percentNum)));
            }
          }
        })).then((res) => {
          const { fileCacheMaps } = reactData;
          const cacheItem = fileCacheMaps[fileKey];
          if (cacheItem) {
            cacheItem.percent = 100;
            cacheItem.status = "success";
          }
          Object.assign(item, res);
          dispatchEvent("upload-success", { option: item, data: res }, null);
        }).catch((res) => {
          const { fileCacheMaps } = reactData;
          const cacheItem = fileCacheMaps[fileKey];
          if (cacheItem) {
            cacheItem.status = "error";
          }
          if (showErrorStatus) {
            Object.assign(item, res);
          } else {
            reactData.fileList = reactData.fileList.filter((obj) => getFieldKey(obj) !== fileKey);
          }
          dispatchEvent("upload-error", { option: item, data: res }, null);
        }).finally(() => {
          const { fileCacheMaps } = reactData;
          const cacheItem = fileCacheMaps[fileKey];
          if (cacheItem) {
            cacheItem.loading = false;
          }
        });
      } else {
        const { fileCacheMaps } = reactData;
        const cacheItem = fileCacheMaps[fileKey];
        if (cacheItem) {
          cacheItem.loading = false;
        }
      }
      return Promise.resolve();
    };
    const handleReUpload = (item) => {
      const { uploadMethod, urlMode } = props;
      const { fileCacheMaps } = reactData;
      const fileKey = getFieldKey(item);
      const cacheItem = fileCacheMaps[fileKey];
      const uploadFn = uploadMethod || getConfig().upload.uploadMethod;
      if (uploadFn && cacheItem) {
        const file = cacheItem.file;
        cacheItem.loading = true;
        cacheItem.status = "pending";
        cacheItem.percent = 0;
        handleUploadResult(item, file).then(() => {
          if (urlMode) {
            handleChange(reactData.fileList);
          }
        });
      }
    };
    const handleUploadFile = (files, evnt) => {
      const { multiple, urlMode, showLimitSize, limitSizeText, showLimitCount, limitCountText, autoSubmit } = props;
      const { fileList } = reactData;
      const uploadFn = props.uploadMethod || getConfig().upload.uploadMethod;
      const keyField = computeKeyField.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const urlProp = computeUrlProp.value;
      const sizeProp = computeSizeProp.value;
      const limitMaxSize = computeLimitMaxSize.value;
      const limitMaxCount = computeLimitMaxCount.value;
      const limitSizeUnit = computeLimitSizeUnit.value;
      let selectFiles = files;
      if (multiple && limitMaxCount) {
        if (showLimitCount && fileList.length >= limitMaxCount) {
          if (VxeUI.modal) {
            VxeUI.modal.notification({
              title: getI18n("vxe.modal.errTitle"),
              status: "error",
              content: limitCountText ? `${import_xe_utils100.default.isFunction(limitCountText) ? limitCountText({ maxCount: limitMaxCount }) : limitCountText}` : getI18n("vxe.upload.overCountErr", [limitMaxCount])
            });
          }
          return;
        }
        const overNum = selectFiles.length - (limitMaxCount - fileList.length);
        if (showLimitCount && overNum > 0) {
          const overExtraList = selectFiles.slice(limitMaxCount - fileList.length);
          if (limitCountText) {
            VxeUI.modal.notification({
              title: getI18n("vxe.modal.errTitle"),
              status: "error",
              content: `${import_xe_utils100.default.isFunction(limitCountText) ? limitCountText({ maxCount: limitMaxCount }) : limitCountText}`
            });
          } else if (VxeUI.modal) {
            VxeUI.modal.notification({
              title: getI18n("vxe.modal.errTitle"),
              status: "error",
              width: null,
              slots: {
                default() {
                  return h("div", {
                    class: "vxe-upload--file-message-over-error"
                  }, [
                    h("div", {}, getI18n("vxe.upload.overCountExtraErr", [limitMaxCount, overNum])),
                    h("div", {
                      class: "vxe-upload--file-message-over-extra"
                    }, overExtraList.map((file, index) => {
                      return h("div", {
                        key: index,
                        class: "vxe-upload--file-message-over-extra-item"
                      }, file.name);
                    }))
                  ]);
                }
              }
            });
          }
        }
        selectFiles = selectFiles.slice(0, limitMaxCount - fileList.length);
      }
      if (showLimitSize && limitMaxSize) {
        for (let i = 0; i < files.length; i++) {
          const file = files[0];
          if (file.size > limitMaxSize) {
            if (VxeUI.modal) {
              VxeUI.modal.notification({
                title: getI18n("vxe.modal.errTitle"),
                status: "error",
                content: limitSizeText ? `${import_xe_utils100.default.isFunction(limitSizeText) ? limitSizeText({ maxSize: limitMaxSize }) : limitSizeText}` : getI18n("vxe.upload.overSizeErr", [limitSizeUnit])
              });
            }
            return;
          }
        }
      }
      const cacheMaps = Object.assign({}, reactData.fileCacheMaps);
      const newFileList = multiple ? fileList : [];
      const uploadPromiseRests = [];
      selectFiles.forEach((file) => {
        const { name } = file;
        const fileKey = getUniqueKey();
        const fileObj = {
          [nameProp]: name,
          [typeProp]: parseFileType(name),
          [sizeProp]: file.size,
          [urlProp]: URL.createObjectURL(file),
          [keyField]: fileKey
        };
        if (uploadFn) {
          cacheMaps[fileKey] = {
            file,
            loading: !!autoSubmit,
            status: "pending",
            percent: 0
          };
        }
        const item = reactive(fileObj);
        if (uploadFn && autoSubmit) {
          uploadPromiseRests.push(handleUploadResult(item, file));
        }
        newFileList.push(item);
      });
      reactData.fileList = newFileList;
      reactData.fileCacheMaps = cacheMaps;
      newFileList.forEach((item) => {
        dispatchEvent("add", { option: item }, evnt);
      });
      Promise.all(urlMode ? uploadPromiseRests : []).then(() => {
        handleChange(newFileList);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, newFileList);
        }
      });
    };
    const handleChoose = (evnt) => {
      const { multiple, imageTypes, fileTypes } = props;
      const isDisabled = computeIsDisabled.value;
      const isImage = computeIsImage.value;
      if (isDisabled) {
        return Promise.resolve({
          status: false,
          files: [],
          file: null
        });
      }
      return readLocalFile({
        multiple,
        types: isImage ? imageTypes : fileTypes
      }).then((params) => {
        handleUploadFile(params.files, evnt);
        return params;
      });
    };
    const clickEvent = (evnt) => {
      handleChoose(evnt).catch(() => {
      });
    };
    const handleRemoveEvent = (evnt, item, index) => {
      const { fileList } = reactData;
      fileList.splice(index, 1);
      handleChange(fileList);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, fileList);
      }
      dispatchEvent("remove", { option: item }, evnt);
    };
    const removeFileEvent = (evnt, item, index) => {
      const beforeRemoveFn = props.beforeRemoveMethod || getConfig().upload.beforeRemoveMethod;
      const removeFn = props.removeMethod || getConfig().upload.removeMethod;
      Promise.resolve(beforeRemoveFn ? beforeRemoveFn({
        $upload: $xeUpload,
        option: item
      }) : true).then((status) => {
        if (status) {
          if (removeFn) {
            Promise.resolve(removeFn({
              $upload: $xeUpload,
              option: item
            })).then(() => {
              handleRemoveEvent(evnt, item, index);
            }).catch((e) => e);
          } else {
            handleRemoveEvent(evnt, item, index);
          }
        } else {
          dispatchEvent("remove-fail", { option: item }, evnt);
        }
      });
    };
    const handleDownloadEvent = (evnt, item) => {
      dispatchEvent("download", { option: item }, evnt);
    };
    const downloadFileEvent = (evnt, item) => {
      const beforeDownloadFn = props.beforeDownloadMethod || getConfig().upload.beforeDownloadMethod;
      const downloadFn = props.downloadMethod || getConfig().upload.downloadMethod;
      Promise.resolve(beforeDownloadFn ? beforeDownloadFn({
        $upload: $xeUpload,
        option: item
      }) : true).then((status) => {
        if (status) {
          if (downloadFn) {
            Promise.resolve(downloadFn({
              $upload: $xeUpload,
              option: item
            })).then(() => {
              handleDownloadEvent(evnt, item);
            }).catch((e) => e);
          } else {
            handleDownloadEvent(evnt, item);
          }
        } else {
          dispatchEvent("download-fail", { option: item }, evnt);
        }
      });
    };
    const handleUploadDragleaveEvent = (evnt) => {
      const targetElem = evnt.currentTarget;
      const { clientX, clientY } = evnt;
      if (targetElem) {
        const { x: targetX, y: targetY, height: targetHeight, width: targetWidth } = targetElem.getBoundingClientRect();
        if (clientX < targetX || clientX > targetX + targetWidth || clientY < targetY || clientY > targetY + targetHeight) {
          reactData.isDragUploadStatus = false;
        }
      }
    };
    const handleUploadDragoverEvent = (evnt) => {
      const dataTransfer = evnt.dataTransfer;
      if (dataTransfer) {
        const { items } = dataTransfer;
        if (items && items.length) {
          evnt.preventDefault();
          reactData.isDragUploadStatus = true;
        }
      }
    };
    const uploadTransferFileEvent = (evnt, files) => {
      const { imageTypes, fileTypes } = props;
      const { imagePreviewTypes } = internalData;
      const isImage = computeIsImage.value;
      if (isImage) {
        const pasteImgTypes = imagePreviewTypes.concat(imageTypes && imageTypes.length ? imageTypes : []);
        files = files.filter((file) => {
          const fileType = `${file.type.split("/")[1] || ""}`.toLowerCase();
          if (pasteImgTypes.some((type) => `${type}`.toLowerCase() === fileType)) {
            return true;
          }
          return false;
        });
      } else {
        if (fileTypes && fileTypes.length) {
          const errTypes = [];
          files.forEach((file) => {
            const fileType = parseFileType(file.name);
            if (!fileTypes.some((type) => `${type}`.toLowerCase() === fileType)) {
              errTypes.push(fileType);
            }
          });
          if (errTypes.length) {
            if (VxeUI.modal) {
              VxeUI.modal.message({
                content: getI18n("vxe.error.notType", [errTypes.join(", ")]),
                status: "error"
              });
            }
            return;
          }
        }
      }
      if (!files.length) {
        if (VxeUI.modal) {
          VxeUI.modal.notification({
            title: getI18n("vxe.modal.errTitle"),
            status: "error",
            content: getI18n("vxe.upload.uploadTypeErr")
          });
        }
        return;
      }
      handleUploadFile(files, evnt);
    };
    const handleUploadDropEvent = (evnt) => {
      const dataTransfer = evnt.dataTransfer;
      if (dataTransfer) {
        const { items } = dataTransfer;
        if (items && items.length) {
          evnt.preventDefault();
          const files = handleTransferFiles(items);
          if (files.length) {
            uploadTransferFileEvent(evnt, files);
          }
        }
      }
      reactData.isDragUploadStatus = false;
    };
    const handleTransferFiles = (items) => {
      const files = [];
      import_xe_utils100.default.arrayEach(items, (item) => {
        const file = item.getAsFile();
        if (file) {
          files.push(file);
        }
      });
      return files;
    };
    const handleMoreEvent = (evntParams) => {
      const formReadonly = computeFormReadonly.value;
      const isImage = computeIsImage.value;
      const evnt = evntParams.$event;
      if (VxeUI.modal) {
        VxeUI.modal.open({
          id: internalData.moreId,
          title: formReadonly ? getI18n("vxe.upload.morePopup.readTitle") : getI18n(`vxe.upload.morePopup.${isImage ? "imageTitle" : "fileTitle"}`),
          width: 660,
          height: 500,
          escClosable: true,
          showMaximize: true,
          resize: true,
          maskClosable: true,
          slots: {
            default() {
              const { showErrorStatus, dragToUpload, dragSort } = props;
              const { isActivated, isDragMove, isDragUploadStatus, dragIndex } = reactData;
              const { fileList } = reactData;
              const isDisabled = computeIsDisabled.value;
              const moreContSlot = slots.moreContent || slots["more-content"];
              const ons = {};
              if (dragToUpload && dragIndex === -1) {
                ons.onDragover = handleUploadDragoverEvent;
                ons.onDragleave = handleUploadDragleaveEvent;
                ons.onDrop = handleUploadDropEvent;
              }
              return h("div", Object.assign({ ref: refPopupElem, class: ["vxe-upload--more-popup", {
                "is--readonly": formReadonly,
                "is--disabled": isDisabled,
                "is--active": isActivated,
                "show--error": showErrorStatus,
                "is--drag": isDragUploadStatus
              }] }, ons), moreContSlot ? getSlotVNs2(moreContSlot({ options: fileList })) : [
                isImage ? dragSort ? h(TransitionGroup, {
                  name: `vxe-upload--drag-list${isDragMove ? "" : "-disabled"}`,
                  tag: "div",
                  class: "vxe-upload--image-more-list"
                }, {
                  default: () => renderImageItemList(fileList, true).concat(renderImageAction(true))
                }) : h("div", {
                  class: "vxe-upload--image-more-list"
                }, renderImageItemList(fileList, true).concat(renderImageAction(true))) : h("div", {
                  class: "vxe-upload--file-more-list"
                }, [
                  renderFileAction(true),
                  dragSort ? h(TransitionGroup, {
                    name: `vxe-upload--drag-list${isDragMove ? "" : "-disabled"}`,
                    tag: "div",
                    class: "vxe-upload--file-list"
                  }, {
                    default: () => renderFileItemList(fileList, false)
                  }) : h("div", {
                    class: "vxe-upload--file-list"
                  }, renderFileItemList(fileList, true))
                ]),
                dragSort ? h("div", {
                  ref: refModalDragLineElem,
                  class: "vxe-upload--drag-line"
                }) : renderEmptyElement($xeUpload),
                isDragUploadStatus ? h("div", {
                  class: "vxe-upload--drag-placeholder"
                }, getI18n("vxe.upload.dragPlaceholder")) : renderEmptyElement($xeUpload)
              ]);
            }
          },
          onShow() {
            reactData.showMorePopup = true;
          },
          onHide({ $event }) {
            reactData.showMorePopup = false;
            if ($event) {
              dispatchEvent("more-visible", { visible: false }, $event);
            }
          }
        });
        if (evnt) {
          dispatchEvent("more-visible", { visible: true }, evnt);
        }
      }
    };
    const showDropTip = (evnt, dragEl, dragPos) => {
      const { showMorePopup } = reactData;
      const el = refElem.value;
      const popupEl = refPopupElem.value;
      const wrapperEl = showMorePopup ? popupEl : el;
      if (!wrapperEl) {
        return;
      }
      const wrapperRect = wrapperEl.getBoundingClientRect();
      const ddLineEl = refDragLineElem.value;
      const mdLineEl = refModalDragLineElem.value;
      const currDLineEl = showMorePopup ? mdLineEl : ddLineEl;
      if (currDLineEl) {
        const dragRect = dragEl.getBoundingClientRect();
        currDLineEl.style.display = "block";
        currDLineEl.style.top = `${Math.max(1, dragRect.y - wrapperRect.y)}px`;
        currDLineEl.style.left = `${Math.max(1, dragRect.x - wrapperRect.x)}px`;
        currDLineEl.style.height = `${dragRect.height}px`;
        currDLineEl.style.width = `${dragRect.width - 1}px`;
        currDLineEl.setAttribute("drag-pos", dragPos);
      }
    };
    const hideDropTip = () => {
      const ddLineEl = refDragLineElem.value;
      const mdLineEl = refModalDragLineElem.value;
      if (ddLineEl) {
        ddLineEl.style.display = "";
      }
      if (mdLineEl) {
        mdLineEl.style.display = "";
      }
    };
    const handleDragSortDragstartEvent = (evnt) => {
      evnt.stopPropagation();
      if (evnt.dataTransfer) {
        evnt.dataTransfer.setDragImage(getTpImg(), 0, 0);
      }
      const dragEl = evnt.currentTarget;
      const parentEl = dragEl.parentElement;
      const dragIndex = import_xe_utils100.default.findIndexOf(Array.from(parentEl.children), (item) => dragEl === item);
      reactData.isDragMove = true;
      reactData.dragIndex = dragIndex;
      setTimeout(() => {
        reactData.isDragMove = false;
      }, 500);
    };
    const handleDragSortDragoverEvent = (evnt) => {
      evnt.stopPropagation();
      evnt.preventDefault();
      const { dragIndex } = reactData;
      if (dragIndex === -1) {
        return;
      }
      const isImage = computeIsImage.value;
      const dragEl = evnt.currentTarget;
      const parentEl = dragEl.parentElement;
      const currIndex = import_xe_utils100.default.findIndexOf(Array.from(parentEl.children), (item) => dragEl === item);
      let dragPos = "";
      if (isImage) {
        const offsetX = evnt.clientX - dragEl.getBoundingClientRect().x;
        dragPos = offsetX < dragEl.clientWidth / 2 ? "left" : "right";
      } else {
        const offsetY = evnt.clientY - dragEl.getBoundingClientRect().y;
        dragPos = offsetY < dragEl.clientHeight / 2 ? "top" : "bottom";
      }
      if (dragIndex === currIndex) {
        showDropTip(evnt, dragEl, dragPos);
        return;
      }
      showDropTip(evnt, dragEl, dragPos);
      internalData.prevDragIndex = currIndex;
      internalData.prevDragPos = dragPos;
    };
    const handleDragSortDragendEvent = (evnt) => {
      const { fileList, dragIndex } = reactData;
      const { prevDragIndex, prevDragPos } = internalData;
      const oldIndex = dragIndex;
      const targetIndex = prevDragIndex;
      const dragOffsetIndex = prevDragPos === "bottom" || prevDragPos === "right" ? 1 : 0;
      const oldItem = fileList[oldIndex];
      const newItem = fileList[targetIndex];
      if (oldItem && newItem) {
        fileList.splice(oldIndex, 1);
        const ptfIndex = import_xe_utils100.default.findIndexOf(fileList, (item) => newItem === item);
        const nIndex = ptfIndex + dragOffsetIndex;
        fileList.splice(nIndex, 0, oldItem);
        dispatchEvent("sort-dragend", {
          oldItem,
          newItem,
          dragPos: prevDragPos,
          offsetIndex: dragOffsetIndex,
          _index: {
            newIndex: nIndex,
            oldIndex
          }
        }, evnt);
      }
      hideDropTip();
      reactData.dragIndex = -1;
    };
    const handleItemMousedownEvent = (evnt) => {
      if ($xeTable) {
        evnt.stopPropagation();
      }
      reactData.isActivated = true;
    };
    const handleGlobalPasteEvent = (evnt) => {
      const { pasteToUpload } = props;
      const { isActivated } = reactData;
      if (!isActivated || !pasteToUpload) {
        return;
      }
      const clipboardData = evnt.clipboardData || evnt.originalEvent.clipboardData;
      if (!clipboardData) {
        return;
      }
      const { items } = clipboardData;
      if (!items) {
        return;
      }
      const files = handleTransferFiles(items);
      if (files.length) {
        evnt.preventDefault();
        uploadTransferFileEvent(evnt, files);
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const el = refElem.value;
      const popupEl = refPopupElem.value;
      let isActivated = getEventTargetNode(evnt, el).flag;
      if (!isActivated && popupEl) {
        const parentEl = popupEl.parentElement || popupEl;
        const modalEl = parentEl ? parentEl.parentElement : parentEl;
        isActivated = getEventTargetNode(evnt, modalEl).flag;
      }
      reactData.isActivated = isActivated;
    };
    const handleGlobalBlurEvent = () => {
      reactData.isActivated = false;
    };
    const uploadMethods = {
      dispatchEvent,
      choose() {
        return handleChoose(null);
      },
      submit(isFull) {
        const { maxSimultaneousUploads } = props;
        const msNum = import_xe_utils100.default.toNumber(maxSimultaneousUploads || 1) || 1;
        const { fileList, fileCacheMaps } = reactData;
        const allPendingList = fileList.filter((item) => {
          const fileKey = getFieldKey(item);
          const cacheItem = fileCacheMaps[fileKey];
          return cacheItem && (cacheItem.status === "pending" || isFull && cacheItem.status === "error");
        });
        const handleSubmit = (item) => {
          const fileKey = getFieldKey(item);
          const cacheItem = fileCacheMaps[fileKey];
          if (cacheItem) {
            const file = cacheItem.file;
            if (file && (cacheItem.status === "pending" || isFull && cacheItem.status === "error")) {
              cacheItem.loading = true;
              cacheItem.percent = 0;
              return handleUploadResult(item, file).then(handleNextSubmit);
            }
          }
          return handleNextSubmit();
        };
        const handleNextSubmit = () => {
          if (allPendingList.length) {
            const item = allPendingList[0];
            allPendingList.splice(0, 1);
            return handleSubmit(item).then(handleNextSubmit);
          }
          return Promise.resolve();
        };
        return Promise.all(allPendingList.splice(0, msNum).map(handleSubmit)).then(() => {
        });
      },
      getMoreVisible() {
        return reactData.showMorePopup;
      },
      openMore() {
        handleMoreEvent({ $event: new Event("click") });
        return nextTick();
      },
      openMoreByEvent(evnt) {
        handleMoreEvent({ $event: evnt });
        return nextTick();
      },
      closeMore() {
        if (VxeUI.modal) {
          VxeUI.modal.close(internalData.moreId);
        }
        return nextTick();
      }
    };
    const uploadPrivateMethods = {};
    Object.assign($xeUpload, uploadMethods, uploadPrivateMethods);
    const renderFileItemList = (currList, isMoreView) => {
      const { showRemoveButton, showDownloadButton, showProgress, progressText, showPreview, showErrorStatus, dragSort, autoSubmit, showSubmitButton } = props;
      const { fileList, fileCacheMaps } = reactData;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const optionSlot = slots.option;
      const actionSlot = slots.action;
      const cornerSlot = slots.corner;
      const nameSlot = slots.name;
      const ons = {};
      if (dragSort && currList.length > 1) {
        ons.onDragstart = handleDragSortDragstartEvent;
        ons.onDragover = handleDragSortDragoverEvent;
        ons.onDragend = handleDragSortDragendEvent;
      }
      return currList.map((item, index) => {
        const fileKey = getFieldKey(item);
        const cacheItem = fileCacheMaps[fileKey];
        let isLoading = false;
        let isError = false;
        let isPending = false;
        const fileName = `${item[nameProp] || ""}`;
        if (cacheItem) {
          isLoading = cacheItem.loading;
          isError = cacheItem.status === "error";
          isPending = cacheItem.status === "pending";
        }
        return h("div", Object.assign({ key: dragSort ? fileKey : index, class: ["vxe-upload--file-item", {
          "is--preview": showPreview,
          "is--loading": isLoading,
          "is--pending": isPending,
          "is--error": isError
        }], fileid: fileKey, draggable: dragSort ? true : null }, ons), optionSlot ? getSlotVNs2(optionSlot({ option: item, isMoreView, options: fileList })) : [
          h("div", {
            class: "vxe-upload--file-item-icon"
          }, [
            h("i", {
              class: getIcon()[`UPLOAD_FILE_TYPE_${`${item[typeProp]}`.toLocaleUpperCase()}`] || getIcon().UPLOAD_FILE_TYPE_DEFAULT
            })
          ]),
          h("div", {
            class: "vxe-upload--file-item-name",
            title: fileName,
            onClick(evnt) {
              if (!isLoading && !isError) {
                handlePreviewFileEvent(evnt, item);
              }
            }
          }, nameSlot ? getSlotVNs2(nameSlot({ option: item, isMoreView, options: fileList })) : fileName),
          isLoading ? h("div", {
            class: "vxe-upload--file-item-loading-icon"
          }, [
            h("i", {
              class: getIcon().UPLOAD_LOADING
            })
          ]) : renderEmptyElement($xeUpload),
          showProgress && isLoading && cacheItem ? h("div", {
            class: "vxe-upload--file-item-loading-text"
          }, progressText ? import_xe_utils100.default.toFormatString(`${import_xe_utils100.default.isFunction(progressText) ? progressText({}) : progressText}`, { percent: cacheItem.percent }) : getI18n("vxe.upload.uploadProgress", [cacheItem.percent])) : renderEmptyElement($xeUpload),
          !isLoading && (isError && showErrorStatus || isPending && showSubmitButton && !autoSubmit) ? h("div", {
            class: "vxe-upload--file-item-rebtn"
          }, [
            h(button_default, {
              icon: isError ? getIcon().UPLOAD_IMAGE_RE_UPLOAD : getIcon().UPLOAD_IMAGE_UPLOAD,
              mode: "text",
              status: "primary",
              content: isError ? getI18n("vxe.upload.reUpload") : getI18n("vxe.upload.manualUpload"),
              onClick() {
                handleReUpload(item);
              }
            })
          ]) : renderEmptyElement($xeUpload),
          h("div", {
            class: "vxe-upload--file-item-btn-wrapper"
          }, actionSlot ? getSlotVNs2(actionSlot({ option: item, isMoreView, options: fileList, readonly: formReadonly })) : [
            cornerSlot ? h("div", {
              class: "vxe-upload--file-item-action"
            }, getSlotVNs2(cornerSlot({ option: item, isMoreView, options: fileList, readonly: formReadonly }))) : renderEmptyElement($xeUpload),
            showDownloadButton && !(isLoading || isPending) ? h("div", {
              class: "vxe-upload--file-item-download-btn",
              onClick(evnt) {
                downloadFileEvent(evnt, item);
              }
            }, [
              h("i", {
                class: getIcon().UPLOAD_FILE_DOWNLOAD
              })
            ]) : renderEmptyElement($xeUpload),
            showRemoveButton && !formReadonly && !isDisabled && !isLoading ? h("div", {
              class: "vxe-upload--file-item-remove-btn",
              onClick(evnt) {
                removeFileEvent(evnt, item, index);
              }
            }, [
              h("i", {
                class: getIcon().UPLOAD_FILE_REMOVE
              })
            ]) : renderEmptyElement($xeUpload)
          ])
        ]);
      });
    };
    const renderFileAction = (isMoreView) => {
      const { showUploadButton, buttonText, buttonIcon, showButtonText, showButtonIcon, autoHiddenButton } = props;
      const { fileList } = reactData;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const showTipText = computedShowTipText.value;
      const defTipText = computedDefTipText.value;
      const overCount = computeOverCount.value;
      const defaultSlot = slots.default;
      const tipSlot = slots.tip || slots.hint;
      if (formReadonly || !showUploadButton) {
        return renderEmptyElement($xeUpload);
      }
      return h("div", {
        class: "vxe-upload--file-action"
      }, [
        autoHiddenButton && overCount ? renderEmptyElement($xeUpload) : h("div", {
          class: "vxe-upload--file-action-btn",
          onClick: clickEvent
        }, defaultSlot ? getSlotVNs2(defaultSlot({ isMoreView, options: fileList, $upload: $xeUpload })) : [
          h(button_default, {
            class: "vxe-upload--file-action-button",
            content: isMoreView || showButtonText ? buttonText ? `${import_xe_utils100.default.isFunction(buttonText) ? buttonText({}) : buttonText}` : getI18n("vxe.upload.fileBtnText") : "",
            icon: showButtonIcon ? buttonIcon || getIcon().UPLOAD_FILE_ADD : "",
            disabled: isDisabled
          })
        ]),
        showTipText && (defTipText || tipSlot) ? h("div", {
          class: "vxe-upload--file-action-tip"
        }, tipSlot ? getSlotVNs2(tipSlot({ isMoreView, options: fileList, $upload: $xeUpload })) : `${defTipText}`) : renderEmptyElement($xeUpload)
      ]);
    };
    const renderAllMode = () => {
      const { showList, moreConfig, dragSort } = props;
      const { fileList, isDragMove } = reactData;
      const moreOpts = computeMoreOpts.value;
      const { maxCount, showMoreButton, layout } = moreOpts;
      const isHorizontal = layout === "horizontal";
      const moreBtnSlot = slots.moreButton || slots["more-button"];
      let currList = fileList;
      let overMaxNum = 0;
      if (maxCount && fileList.length > maxCount) {
        overMaxNum = fileList.length - maxCount;
        currList = fileList.slice(0, maxCount);
      }
      return h("div", {
        key: "all",
        class: "vxe-upload--file-wrapper"
      }, showList ? [
        showMoreButton && moreConfig && isHorizontal ? renderEmptyElement($xeUpload) : renderFileAction(true),
        currList.length || showMoreButton && isHorizontal ? h("div", {
          class: ["vxe-upload--file-list-wrapper", {
            "is--horizontal": isHorizontal
          }]
        }, [
          currList.length ? dragSort ? h(TransitionGroup, {
            name: `vxe-upload--drag-list${isDragMove ? "" : "-disabled"}`,
            tag: "div",
            class: "vxe-upload--file-list"
          }, {
            default: () => renderFileItemList(currList, false)
          }) : h("div", {
            class: "vxe-upload--file-list"
          }, renderFileItemList(currList, false)) : renderEmptyElement($xeUpload),
          showMoreButton && overMaxNum ? h("div", {
            class: "vxe-upload--file-over-more"
          }, moreBtnSlot ? getSlotVNs2(moreBtnSlot({ options: fileList })) : [
            h(button_default, {
              mode: "text",
              content: getI18n("vxe.upload.moreBtnText", [fileList.length]),
              status: "primary",
              onClick: handleMoreEvent
            })
          ]) : renderEmptyElement($xeUpload),
          showMoreButton && moreConfig && isHorizontal ? renderFileAction(false) : renderEmptyElement($xeUpload)
        ]) : renderEmptyElement($xeUpload)
      ] : [
        renderFileAction(false)
      ]);
    };
    const renderImageItemList = (currList, isMoreView) => {
      const { showRemoveButton, showProgress, progressText, showPreview, showErrorStatus, dragSort, autoSubmit, showSubmitButton } = props;
      const { fileList, fileCacheMaps } = reactData;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const imageOpts = computeImageOpts.value;
      const imgStyle = computeImgStyle.value;
      const optionSlot = slots.option;
      const actionSlot = slots.action;
      const cornerSlot = slots.corner;
      const ons = {
        onMousedown: handleItemMousedownEvent
      };
      if (dragSort && currList.length > 1) {
        ons.onDragstart = handleDragSortDragstartEvent;
        ons.onDragover = handleDragSortDragoverEvent;
        ons.onDragend = handleDragSortDragendEvent;
      }
      return currList.map((item, index) => {
        const fileKey = getFieldKey(item);
        const cacheItem = fileCacheMaps[fileKey];
        let isLoading = false;
        let isError = false;
        let isPending = false;
        if (cacheItem) {
          isLoading = cacheItem.loading;
          isError = cacheItem.status === "error";
          isPending = cacheItem.status === "pending";
        }
        return h("div", Object.assign({ key: dragSort ? fileKey : index, class: ["vxe-upload--image-item", {
          "is--preview": showPreview,
          "is--circle": imageOpts.circle,
          "is--loading": isLoading,
          "is--pending": isPending,
          "is--error": isError
        }], fileid: fileKey, draggable: dragSort ? true : null }, ons), optionSlot ? getSlotVNs2(optionSlot({ option: item, isMoreView, options: fileList })) : [
          h("div", {
            class: "vxe-upload--image-item-box",
            style: isMoreView ? null : imgStyle,
            onClick(evnt) {
              if (!isLoading && !isError) {
                handlePreviewImageEvent(evnt, item, index);
              }
            }
          }, [
            isLoading && cacheItem ? h("div", {
              class: "vxe-upload--image-item-loading"
            }, [
              h("div", {
                class: "vxe-upload--image-item-loading-icon"
              }, [
                h("i", {
                  class: getIcon().UPLOAD_LOADING
                })
              ]),
              showProgress ? h("div", {
                class: "vxe-upload--image-item-loading-text"
              }, progressText ? import_xe_utils100.default.toFormatString(`${import_xe_utils100.default.isFunction(progressText) ? progressText({}) : progressText}`, { percent: cacheItem.percent }) : getI18n("vxe.upload.uploadProgress", [cacheItem.percent])) : renderEmptyElement($xeUpload)
            ]) : renderEmptyElement($xeUpload),
            h("div", {
              class: "vxe-upload--image-item-img-wrapper",
              title: getI18n("vxe.upload.viewItemTitle")
            }, [
              h("img", {
                class: "vxe-upload--image-item-img",
                src: getThumbnailFileUrl(item)
              })
            ]),
            !isLoading && (isError && showErrorStatus || isPending && showSubmitButton && !autoSubmit) ? h("div", {
              class: "vxe-upload--image-item-rebtn"
            }, [
              h(button_default, {
                icon: isError ? getIcon().UPLOAD_IMAGE_RE_UPLOAD : getIcon().UPLOAD_IMAGE_UPLOAD,
                mode: "text",
                status: "primary",
                content: isError ? getI18n("vxe.upload.reUpload") : getI18n("vxe.upload.manualUpload"),
                onClick() {
                  handleReUpload(item);
                }
              })
            ]) : renderEmptyElement($xeUpload),
            h("div", {
              class: "vxe-upload--image-item-btn-wrapper",
              onClick(evnt) {
                evnt.stopPropagation();
              }
            }, actionSlot ? getSlotVNs2(actionSlot({ option: item, isMoreView, options: fileList, readonly: formReadonly })) : [
              cornerSlot ? h("div", {
                class: "vxe-upload--file-item-action"
              }, getSlotVNs2(cornerSlot({ option: item, isMoreView, options: fileList, readonly: formReadonly }))) : renderEmptyElement($xeUpload),
              showRemoveButton && !formReadonly && !isDisabled && !isLoading ? h("div", {
                class: "vxe-upload--image-item-remove-btn",
                onClick(evnt) {
                  evnt.stopPropagation();
                  removeFileEvent(evnt, item, index);
                }
              }, [
                h("i", {
                  class: getIcon().UPLOAD_IMAGE_REMOVE
                })
              ]) : renderEmptyElement($xeUpload)
            ])
          ])
        ]);
      });
    };
    const renderImageAction = (isMoreView) => {
      const { showUploadButton, buttonText, buttonIcon, showButtonText, showButtonIcon, autoHiddenButton } = props;
      const { fileList } = reactData;
      const formReadonly = computeFormReadonly.value;
      const showTipText = computedShowTipText.value;
      const defTipText = computedDefTipText.value;
      const overCount = computeOverCount.value;
      const imgStyle = computeImgStyle.value;
      const defaultSlot = slots.default;
      const tipSlot = slots.tip || slots.hint;
      if (formReadonly || !showUploadButton || autoHiddenButton && overCount) {
        return renderEmptyElement($xeUpload);
      }
      return h("div", {
        key: "action",
        class: "vxe-upload--image-action"
      }, [
        h("div", {
          class: "vxe-upload--image-action-btn",
          onClick: clickEvent
        }, defaultSlot ? defaultSlot({ isMoreView, options: fileList, $upload: $xeUpload }) : [
          h("div", {
            class: "vxe-upload--image-action-box",
            style: isMoreView ? null : imgStyle
          }, [
            showButtonIcon ? h("div", {
              class: "vxe-upload--image-action-icon"
            }, [
              h("i", {
                class: buttonIcon || getIcon().UPLOAD_IMAGE_ADD
              })
            ]) : renderEmptyElement($xeUpload),
            isMoreView || showButtonText ? h("div", {
              class: "vxe-upload--image-action-content"
            }, buttonText ? `${import_xe_utils100.default.isFunction(buttonText) ? buttonText({}) : buttonText}` : getI18n("vxe.upload.imgBtnText")) : renderEmptyElement($xeUpload),
            showTipText && (defTipText || tipSlot) ? h("div", {
              class: "vxe-upload--image-action-hint"
            }, tipSlot ? getSlotVNs2(tipSlot({ isMoreView, options: fileList, $upload: $xeUpload })) : `${defTipText}`) : renderEmptyElement($xeUpload)
          ])
        ])
      ]);
    };
    const renderImageMode = () => {
      const { showList, dragSort } = props;
      const { fileList, isDragMove } = reactData;
      const moreOpts = computeMoreOpts.value;
      const moreBtnSlot = slots.moreButton || slots["more-button"];
      const { maxCount, showMoreButton } = moreOpts;
      let currList = fileList;
      let overMaxNum = 0;
      if (maxCount && fileList.length > maxCount) {
        overMaxNum = fileList.length - maxCount;
        currList = fileList.slice(0, maxCount);
      }
      return h("div", {
        key: "image",
        class: "vxe-upload--image-wrapper"
      }, showList ? [
        dragSort ? h(TransitionGroup, {
          name: `vxe-upload--drag-list${isDragMove ? "" : "-disabled"}`,
          tag: "div",
          class: "vxe-upload--image-list"
        }, {
          default: () => renderImageItemList(currList, false).concat([
            showMoreButton && overMaxNum ? h("div", {
              key: "om",
              class: "vxe-upload--image-over-more"
            }, moreBtnSlot ? getSlotVNs2(moreBtnSlot({ options: fileList })) : [
              h(button_default, {
                mode: "text",
                content: getI18n("vxe.upload.moreBtnText", [fileList.length]),
                status: "primary",
                onClick: handleMoreEvent
              })
            ]) : renderEmptyElement($xeUpload),
            renderImageAction(false)
          ])
        }) : h("div", {
          class: "vxe-upload--image-list"
        }, renderImageItemList(currList, false).concat([
          showMoreButton && overMaxNum ? h("div", {
            class: "vxe-upload--image-over-more"
          }, moreBtnSlot ? getSlotVNs2(moreBtnSlot({ options: fileList })) : [
            h(button_default, {
              mode: "text",
              content: getI18n("vxe.upload.moreBtnText", [fileList.length]),
              status: "primary",
              onClick: handleMoreEvent
            })
          ]) : renderEmptyElement($xeUpload),
          renderImageAction(false)
        ]))
      ] : [
        h("div", {
          class: "vxe-upload--image-list"
        }, [
          renderImageAction(false)
        ])
      ]);
    };
    const renderVN = () => {
      const { showErrorStatus, dragToUpload, pasteToUpload, dragSort } = props;
      const { isDragUploadStatus, showMorePopup, isActivated, dragIndex } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isImage = computeIsImage.value;
      const ons = {
        onMousedown: handleItemMousedownEvent
      };
      if (dragToUpload && dragIndex === -1) {
        ons.onDragover = handleUploadDragoverEvent;
        ons.onDragleave = handleUploadDragleaveEvent;
        ons.onDrop = handleUploadDropEvent;
      }
      return h("div", Object.assign({ ref: refElem, class: ["vxe-upload", {
        [`size--${vSize}`]: vSize,
        "is--active": isActivated,
        "is--readonly": formReadonly,
        "is--disabled": isDisabled,
        "is--paste": pasteToUpload,
        "show--error": showErrorStatus,
        "is--drag": isDragUploadStatus
      }] }, ons), [
        isImage ? renderImageMode() : renderAllMode(),
        dragSort ? h("div", {
          ref: refDragLineElem,
          class: "vxe-upload--drag-line"
        }) : renderEmptyElement($xeUpload),
        isDragUploadStatus && !showMorePopup ? h("div", {
          class: "vxe-upload--drag-placeholder"
        }, getI18n("vxe.upload.dragPlaceholder")) : renderEmptyElement($xeUpload)
      ]);
    };
    const listFlag = ref(0);
    watch(() => props.modelValue ? props.modelValue.length : 0, () => {
      listFlag.value++;
    });
    watch(() => props.modelValue, () => {
      listFlag.value++;
    });
    watch(listFlag, () => {
      updateFileList();
    });
    onMounted(() => {
      if (props.multiple && props.singleMode) {
        errLog("vxe.error.errConflicts", ["[upload] multiple", "single-mode"]);
      }
      if (props.imageStyle) {
        warnLog("vxe.error.delProp", ["[upload] image-style", "image-config"]);
      }
      if (props.dragSort) {
        initTpImg();
      }
      globalEvents.on($xeUpload, "paste", handleGlobalPasteEvent);
      globalEvents.on($xeUpload, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeUpload, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      reactData.isDragUploadStatus = false;
      globalEvents.off($xeUpload, "paste");
      globalEvents.off($xeUpload, "mousedown");
      globalEvents.off($xeUpload, "blur");
    });
    updateFileList();
    $xeUpload.renderVN = renderVN;
    return $xeUpload;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/upload/index.js
var VxeUpload = Object.assign({}, upload_default, {
  install(app) {
    app.component(upload_default.name, upload_default);
  }
});
dynamicApp.use(VxeUpload);
VxeUI.component(upload_default);
VxeUI.saveFile = saveLocalFile;
VxeUI.readFile = readLocalFile;
var Upload = VxeUpload;
var upload_default2 = VxeUpload;

// node_modules/vxe-pc-ui/es/watermark/src/watermark.js
var import_xe_utils102 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/watermark/src/util.js
var import_xe_utils101 = __toESM(require_xe_utils());
var canvasEl = null;
var fontEl = null;
var fontCacheMaps = {};
function getMarkCanvas() {
  if (!canvasEl) {
    canvasEl = document.createElement("canvas");
    canvasEl.style.position = "absolute";
    canvasEl.style.top = "0";
    canvasEl.style.left = "0";
  }
  return canvasEl;
}
function removeMarkElement(elem) {
  if (elem) {
    const parentEl = elem.parentNode;
    if (parentEl) {
      parentEl.removeChild(elem);
    }
  }
}
function calcFontWH(text, fontSize) {
  const fKey = `${fontSize}_${text}`;
  if (!fontCacheMaps[fKey]) {
    if (!fontEl) {
      fontEl = document.createElement("span");
    }
    if (!fontEl.parentNode) {
      document.body.append(fontEl);
    }
    fontEl.textContent = text;
    fontEl.style.fontSize = toCssUnit(fontSize);
    const width = fontEl.offsetWidth;
    const height = fontEl.offsetHeight;
    fontCacheMaps[fKey] = {
      width,
      height
    };
  }
  return fontCacheMaps[fKey];
}
function calcContentWH(contList) {
  let contentWidth = 0;
  let contentHeight = 0;
  contList.forEach((item) => {
    contentWidth = Math.max(item.width, contentWidth);
    contentHeight = Math.max(item.height, contentHeight);
  });
  return {
    contentWidth,
    contentHeight
  };
}
function calcCanvasWH(contentWidth, opts) {
  const { gap } = opts;
  const [gapX = 0, gapY = 0] = gap ? import_xe_utils101.default.isArray(gap) ? gap : [gap, gap] : [];
  const canvasWidth = contentWidth + import_xe_utils101.default.toNumber(gapX);
  const canvasHeight = contentWidth + import_xe_utils101.default.toNumber(gapY);
  return {
    canvasWidth,
    canvasHeight
  };
}
function getFontConf(item, key, opts) {
  return (item.font ? item.font[key] : "") || (opts.font ? opts.font[key] : "");
}
function createMarkFont(contConf, defaultFontSize, opts) {
  const { offset } = opts;
  const text = import_xe_utils101.default.toValueString(contConf.textContent);
  const fontSize = import_xe_utils101.default.toNumber(getFontConf(contConf, "fontSize", opts) || defaultFontSize) || 14;
  const [offsetX = 0, offsetY = 0] = offset ? import_xe_utils101.default.isArray(offset) ? offset : [offset, offset] : [];
  const { width, height } = calcFontWH(text, fontSize);
  return {
    text,
    fontSize,
    font: contConf.font,
    width: width + import_xe_utils101.default.toNumber(offsetX),
    height: height + import_xe_utils101.default.toNumber(offsetY)
  };
}
function drayFont(ctx, item, opts) {
  const fontWeight = getFontConf(item, "fontWeight", opts);
  ctx.fillStyle = `${getFontConf(item, "color", opts) || "rgba(0, 0, 0, 0.15)"}`;
  ctx.font = [
    getFontConf(item, "fontStyle", opts) || "normal",
    fontWeight === "bold" || fontWeight === "bolder" ? "bold" : "",
    toCssUnit(item.fontSize),
    getFontConf(item, "fontFamily", opts) || "sans-serif"
  ].join(" ");
}
function getContentUrl(content, defaultFontSize, options) {
  const opts = Object.assign({}, options);
  const { rotate } = opts;
  const deg = import_xe_utils101.default.toNumber(rotate);
  const contList = (import_xe_utils101.default.isArray(content) ? content : [content]).map((item) => {
    if (item) {
      if (item.textContent) {
        return createMarkFont(item, defaultFontSize, opts);
      }
      return createMarkFont({
        textContent: `${item}`
      }, defaultFontSize, opts);
    }
    return createMarkFont({
      textContent: ""
    }, defaultFontSize, opts);
  });
  removeMarkElement(fontEl);
  return new Promise((resolve) => {
    const canvasEl2 = getMarkCanvas();
    if (!canvasEl2.parentNode) {
      document.body.append(canvasEl2);
    }
    const ctx = canvasEl2.getContext("2d");
    if (ctx && contList.length) {
      const { contentWidth, contentHeight } = calcContentWH(contList);
      const { canvasWidth, canvasHeight } = calcCanvasWH(contentWidth, opts);
      canvasEl2.width = canvasWidth;
      canvasEl2.height = canvasHeight;
      const x = (canvasWidth - contentWidth) / 2;
      const y = (canvasHeight - contentHeight) / 2;
      const drayX = x + contentWidth / 2;
      const drayY = y + contentHeight / 2;
      ctx.save();
      ctx.translate(drayX, drayY);
      ctx.rotate(deg * Math.PI / 180);
      ctx.translate(-drayX, -drayY);
      let offsetHeight = 0;
      contList.forEach((item) => {
        const align = getFontConf(item, "align", opts);
        drayFont(ctx, item, opts);
        ctx.fillText(item.text, x + (align === "center" ? (contentWidth - item.width) / 2 : 0), y + (contentHeight + contentHeight) / 2 + offsetHeight, contentWidth);
        offsetHeight += item.height;
      });
      ctx.restore();
      resolve(canvasEl2.toDataURL());
      removeMarkElement(canvasEl2);
    } else {
      resolve("");
      removeMarkElement(canvasEl2);
    }
  });
}

// node_modules/vxe-pc-ui/es/watermark/src/watermark.js
var watermark_default = defineVxeComponent({
  name: "VxeWatermark",
  props: {
    width: String,
    height: String,
    imageUrl: String,
    rotate: {
      type: [Number, String],
      default: () => getConfig().watermark.rotate
    },
    gap: {
      type: [Array, Number, String],
      default: () => import_xe_utils102.default.clone(getConfig().watermark.gap, true)
    },
    content: [String, Array],
    font: Object,
    offset: Object,
    zIndex: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils102.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({
      markUrl: ""
    });
    const refMaps = {
      refElem
    };
    const computeFontOpts = computed(() => {
      return import_xe_utils102.default.assign({}, import_xe_utils102.default.clone(getConfig().watermark.font, true), props.font);
    });
    const computeWrapperStyle = computed(() => {
      const { width, height, zIndex } = props;
      const { markUrl } = reactData;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (markUrl) {
        stys.backgroundImage = `url(${markUrl})`;
      }
      if (zIndex) {
        stys.zIndex = zIndex;
      }
      return stys;
    });
    const computeMaps = {};
    const $xeWatermark = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $watermark: $xeWatermark }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const updateMarkStyle = () => {
      const { content, gap, rotate, offset } = props;
      const el = refElem.value;
      const fontOpts = computeFontOpts.value;
      if (el) {
        if (content) {
          getContentUrl(content, getComputedStyle(el).fontSize, {
            font: fontOpts,
            rotate,
            gap,
            offset
          }).then((url) => {
            reactData.markUrl = url;
          });
        }
      }
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeWatermark, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const wrapperStyle = computeWrapperStyle.value;
      return h("div", {
        ref: refElem,
        class: "vxe-watermark",
        style: wrapperStyle
      });
    };
    watch(() => props.imageUrl, () => {
      updateMarkStyle();
    });
    watch(() => props.content, () => {
      updateMarkStyle();
    });
    watch(() => props.gap, () => {
      updateMarkStyle();
    });
    watch(() => props.rotate, () => {
      updateMarkStyle();
    });
    watch(() => props.width, () => {
      updateMarkStyle();
    });
    watch(() => props.height, () => {
      updateMarkStyle();
    });
    watch(() => props.font, () => {
      updateMarkStyle();
    });
    onMounted(() => {
      updateMarkStyle();
      globalEvents.on($xeWatermark, "resize", import_xe_utils102.default.throttle(() => {
        updateMarkStyle();
      }, 300, { trailing: true, leading: true }));
    });
    onUnmounted(() => {
      globalEvents.off($xeWatermark, "resize");
    });
    $xeWatermark.renderVN = renderVN;
    return $xeWatermark;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/watermark/index.js
var VxeWatermark = Object.assign({}, watermark_default, {
  install(app) {
    app.component(watermark_default.name, watermark_default);
  }
});
dynamicApp.use(VxeWatermark);
VxeUI.component(watermark_default);
var WatermarkController = {
  load(options) {
    checkDynamic();
    dynamicStore.globalWatermark = Object.assign({}, options);
    return Promise.resolve();
  },
  clear() {
    dynamicStore.globalWatermark = null;
    return Promise.resolve();
  }
};
VxeUI.watermark = WatermarkController;
var Watermark = VxeWatermark;
var watermark_default2 = VxeWatermark;

// node_modules/vxe-pc-ui/es/components.js
var { setI18n: setI18n2, setLanguage: setLanguage2, setTheme: setTheme2, setConfig: setConfig2 } = VxeUI;
var components = [
  alert_default2,
  anchor_default2,
  anchor_link_default2,
  avatar_default2,
  badge_default2,
  breadcrumb_default2,
  breadcrumb_item_default2,
  button_default2,
  button_group_default2,
  calendar_default2,
  card_default2,
  carousel_default2,
  carousel_item_default2,
  checkbox_default2,
  checkbox_button_default,
  checkbox_group_default,
  col_default2,
  collapse_default2,
  collapse_pane_default2,
  color_picker_default2,
  countdown_default2,
  date_panel_default2,
  date_picker_default2,
  date_range_picker_default2,
  drawer_default2,
  empty_default2,
  form_default2,
  form_gather_default,
  form_group_default2,
  form_item_default2,
  icon_default2,
  icon_picker_default2,
  image_default2,
  image_group_default,
  image_preview_default,
  input_default2,
  layout_aside_default2,
  layout_body_default2,
  layout_container_default2,
  layout_footer_default2,
  layout_header_default2,
  link_default2,
  list_default2,
  loading_default2,
  menu_default2,
  modal_default2,
  notice_bar_default2,
  number_input_default2,
  optgroup_default2,
  option_default2,
  pager_default2,
  password_input_default2,
  print_page_break_default,
  print_default2,
  pulldown_default2,
  radio_default2,
  radio_button_default,
  radio_group_default,
  rate_default2,
  result_default2,
  row_default2,
  select_default2,
  splitter_default2,
  splitter_panel_default2,
  split_default,
  split_pane_default,
  slider_default2,
  steps_default2,
  switch_default2,
  tab_pane_default2,
  table_select_default2,
  tabs_default2,
  tag_default2,
  text_ellipsis_default2,
  text_default2,
  textarea_default2,
  tip_default2,
  tooltip_default2,
  tree_default2,
  tree_select_default2,
  upload_default2,
  watermark_default2
];
function install(app, options) {
  setConfig2(options);
  components.forEach((component2) => app.use(component2));
}
var defaultLanguage = "zh-CN";
setI18n2(defaultLanguage, zh_CN_default);
setLanguage2(defaultLanguage);
setTheme2("light");
var loading = LoadingController;
var modal = ModalController;
var drawer = DrawerController;
var watermark = WatermarkController;
var print = printHtml;
var saveFile = saveLocalFile;
var readFile = readLocalFile;

// node_modules/vxe-pc-ui/es/index.esm.js
var index_esm_default2 = components_exports;
export {
  Alert,
  Anchor,
  AnchorLink,
  Avatar,
  Badge,
  Breadcrumb,
  BreadcrumbItem,
  Button,
  ButtonGroup,
  Calendar,
  Card,
  Carousel,
  CarouselItem,
  Checkbox,
  CheckboxButton,
  CheckboxGroup,
  Col,
  Collapse,
  CollapsePane,
  ColorPicker,
  Countdown,
  DatePanel,
  DatePicker,
  DateRangePicker,
  Drawer,
  DrawerController,
  Empty,
  Form,
  FormGather,
  FormGroup,
  FormItem,
  GLOBAL_EVENT_KEYS,
  Icon,
  IconPicker,
  Image2 as Image,
  ImageGroup,
  ImagePreview,
  Input,
  LayoutAside,
  LayoutBody,
  LayoutContainer,
  LayoutFooter,
  LayoutHeader,
  Link,
  List,
  Loading,
  LoadingController,
  Menu,
  Modal,
  ModalController,
  NoticeBar,
  NumberInput,
  Optgroup,
  Option,
  Pager,
  PasswordInput,
  Print,
  PrintPageBreak,
  Pulldown,
  Radio,
  RadioButton,
  RadioGroup,
  Rate,
  Result,
  Row,
  Select,
  Slider,
  Split,
  SplitPane,
  Splitter,
  SplitterPanel,
  Steps,
  Switch,
  TabPane,
  TableSelect,
  Tabs,
  Tag,
  Text,
  TextEllipsis,
  Textarea,
  Tip,
  Tips,
  Tooltip,
  Tree,
  TreeSelect,
  Upload,
  VxeAlert,
  VxeAnchor,
  VxeAnchorLink,
  VxeAvatar,
  VxeBadge,
  VxeBreadcrumb,
  VxeBreadcrumbItem,
  VxeButton,
  VxeButtonGroup,
  VxeCalendar,
  VxeCard,
  VxeCarousel,
  VxeCarouselItem,
  VxeCheckbox,
  VxeCheckboxButton,
  VxeCheckboxGroup,
  VxeCol,
  VxeCollapse,
  VxeCollapsePane,
  VxeColorPicker,
  VxeCore,
  VxeCountdown,
  VxeDatePanel,
  VxeDatePicker,
  VxeDateRangePicker,
  VxeDrawer,
  VxeEmpty,
  VxeForm,
  VxeFormGather,
  VxeFormGroup,
  VxeFormItem,
  VxeIcon,
  VxeIconPicker,
  VxeImage,
  VxeImageGroup,
  VxeImagePreview,
  VxeInput,
  VxeLayoutAside,
  VxeLayoutBody,
  VxeLayoutContainer,
  VxeLayoutFooter,
  VxeLayoutHeader,
  VxeLink,
  VxeList,
  VxeLoading,
  VxeMenu,
  VxeModal,
  VxeNoticeBar,
  VxeNumberInput,
  VxeOptgroup,
  VxeOption,
  VxePager,
  VxePasswordInput,
  VxePrint,
  VxePrintPageBreak,
  VxePulldown,
  VxeRadio,
  VxeRadioButton,
  VxeRadioGroup,
  VxeRate,
  VxeResult,
  VxeRow,
  VxeSelect,
  VxeSlider,
  VxeSplit,
  VxeSplitPane,
  VxeSplitter,
  VxeSplitterPanel,
  VxeSteps,
  VxeSwitch,
  VxeTabPane,
  VxeTableSelect,
  VxeTabs,
  VxeTag,
  VxeText,
  VxeTextEllipsis,
  VxeTextarea,
  VxeTip,
  VxeTooltip,
  VxeTree,
  VxeTreeSelect,
  VxeUI,
  VxeUpload,
  VxeWatermark,
  Watermark,
  WatermarkController,
  checkVersion,
  clipboard,
  commands,
  component,
  config,
  coreVersion,
  createEvent,
  index_esm_default2 as default,
  drawer,
  formats,
  getComponent,
  getConfig,
  getI18n,
  getIcon,
  getLanguage,
  getSlotVNs,
  getTheme,
  globalEvents,
  globalResize,
  globalStore,
  handleCheckInfo,
  hasComponent,
  hasLanguage,
  hooks,
  install,
  interceptor,
  loading,
  log,
  menus,
  modal,
  permission,
  print,
  readFile,
  renderCustomIcon,
  renderEmptyElement,
  renderGlobalIcon,
  renderer,
  saveFile,
  setConfig,
  setI18n,
  setIcon,
  setLanguage,
  setTheme,
  setup,
  use,
  useFns,
  usePermission,
  useSize,
  validators,
  version2 as version,
  watermark
};
//# sourceMappingURL=vxe-pc-ui.js.map
